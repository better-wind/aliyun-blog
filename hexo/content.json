[{"title":"个人项目经验","date":"2018-05-10T03:01:38.000Z","path":"2018/05/10/2018-05-10-interview-work-peoject/","text":"本文 需 3 分钟左右 阅读时间 格家网络2017.03 - 至今商家后台负责项目的构建 模块化 组件化开发负责项目的开发与维护 2017.07 - 至今商品库管理负责项目的构建 模块化 组件化开发负责项目的开发与维护 在这一段时间独自开发了商家后台 和 商品库管理系统期间碰到了很多问题 举几个例子架构层面1.作为传统的管理页面 很多都是查询搜索结果页 那么能不能作为业务组件抽离出来做成可配置的 ？能不能从把它项目中抽离出来进行托管 然后在别的项目中应用 ？2.对于重复请求 二次点击 有没有通用的拦截实现 ？对于请求的成功失败 有没有全局通用的错误回调机制 ？3.什么样的设计能满足组件 接口 路由 vuex 等的合理调用呢 ？什么样的代码结构 能满足 拓展性呢 ？业务逻辑层面搜索页面中 能不能对搜索选项进行判断 能不能根据已有的搜索选项地址 进行加载 ？全局的回车搜索 ？批量上传 如何保证顺序 ？省市区选择树 如何保证页面不卡 ？分页选择 再次进入当前页 如何渲染上次的选择 ？布局层面如何适应不同窗口 ？如何定义基础样式 ？ 目前为止 我搭建的项目架构 已在组内 推广使用我本地项目已将 部分业务组件 托管在npm上 期间明白开发前的前后端沟通 很重要想清楚再写 很重要在信息共享时代 想法和视野 很重要 项目地址 琐碎的个人时间这个想了想还是放第二吧这一年 基本上大部分的时间 都花在处理 业务逻辑 上对于项目中用到的各种框架 其实知之甚少期间 有过不少想法 但实际落地甚少但是 回头看看 感觉自己比之前还是有点进步的这一年多研究过各种框架源码 也能明个大概发现css 其实很难 但从其设计角度研究研究 其实也不难 很多时候顺其自然 反倒效果更好发现js 基础真的很重要 时不时看看总能研究出点新东西发现canvas 其实能做的事真的很多 意料之外情理之中发现前端自动化脚本 也只是js 可以随心所欲发现各种 .xxx 文件其实也不那么 可怕发现请求协议 再怎么复杂多变 还是有迹可循发现服务器部署维护 也不是那么遥不可及发现代码的托管 真的也只是托管我的代码发现所有的框架 都只是为了方便服务开发发现技术真的没有好坏 只有适不适用业务 Holo网站一个朋友让我帮他写的网站 用作他现在创业项目的宣传他们团队能提供的 就是一个服务器的账号密码 和 设计稿要求是 兼容所有设备解决方案 响应式 ？ 自适应 ？ 网站地址 想去网这期间 有快一年是只有我一个前端大部分的项目 前后端没有分离 前端采用的 velocity 模版那会对于网站的日常开发 是基于zeptocss预处理用的是scss 并且自己写了一套 rem的布局方案对于日常的活动开发 放弃第三方的框架 自己封装了个基础库 （包括基础的dom操作 工具 懒加载等）能共用的也基本上共用了(分享 活动模版等)大部分项目构建工具用的是gulp 也能配置热加载 自动更新 印象里 那段时间其实做了很多东西但现在回过头看 其实好像没做什么 网站地址 2015.08 – 2017.03 双十一活动、双十二活动、年中活动、年终活动 二周年活动、情人节活动、类黑凤梨传播活动、 微信书法、运营日常活动模板等等2017.02 微信推广联盟后台 负责项目构建 开发2017.01 微信小程序开发（好设计精选） 负责项目架构，登录逻辑，下单支付主流程开发2016.07 - 2016.08 网站交易模块重构 负责交易相关逻辑接口梳理和重写 包括下单，二次支付，合并付款，优惠券选择 商家版买家版订单管理，购物车，商品详情等2016.06 - 2016.07 网站退货退款模块 新增网站退货退款功能 移动端App内嵌H5页面2016.03 - 2016.04 微信商城 H5微信商城页面改版 感谢阅读当然 文字是苍白的 我更倾向于面对面的交流","tags":[{"name":"interview","slug":"interview","permalink":"//blog.fenghou.site/tags/interview/"}]},{"title":"一颗关于省市区的树","date":"2018-04-20T06:17:54.000Z","path":"2018/04/20/2018-04-20-js-province-city-district/","text":"如何绘制一个省市区三级可选择的树？ 开始首先你拥有的数据结构 所有省市区的信息列表 以及已经选中的信息用的是element-ui的 el-tree1234567891011121314const cityStorage = &#123; provinceList:[ &#123;id: 1, provinceId: \"110000\", name: \"北京市\"&#125; ],//所有省 cityList:[ &#123;id: 1, cityId: \"110100\", name: \"北京市\", provinceId: \"110000\", zipCode: \"102600\"&#125; ],//所有市 districtList:[ &#123;id: 1, districtId: \"110101\", name: \"东城区\", cityId: \"110100\"&#125; ],//所有区 &#125;const selectList = [ &#123; provinceId: \"110000\",cityId: \"110100\",districtId: \"110101\"&#125;] // 所有选中的省市区 ID 保存的时候也是这个格式 按需渲染首先 作为有相对要求的开发人员 不会考虑说 直接的去渲染出整个树 那整个省市区加载的速度绝对会是感人的 那么 可行的解决方法是 一开始 只展示 所有省的信息 点击展开 时再去渲染下一层 数据 这个对应关系 相对还容易找 每次点击展开能获得当前的层级和id 根据层级和id去对应的city和district中过滤就行 这里分享一个小技巧 不通过判断的方式去对应 而是通过数据的方式12345678910111213141516//level , idconst levelConfig = &#123; 1: &#123; idLabel: 'cityId', fetchLabel: 'cityList', perIdLabel: 'provinceId' &#125;, 2: &#123; idLabel: 'districtId', fetchLabel: 'districtList', perIdLabel: 'cityId' &#125;&#125;// 那么过滤就可以这么写cityStorage[levelConfig[level].fetchLabel].filter(item =&gt; item[levelConfig[level].perIdLabel] == id) 获取数据 然后加载对应下一层 一切到现在为止 都还可以 赋值渲染再往下 如果我有初始数据呢？ 在只展示省信息的情况下 结合前面给的数据格式 怎么展示 这个省是 全选 半选(表示省中有选择的市或者区但没选全) 和 不选 ？ 第一 你需要设法知道省份满足全选的条件第二 你需要设法知道已经选择的情况 所以这个时候 需要做的 是计数 也就 ++遍历一遍 cityStorage.provinceList 和 cityStorage.cityList往Map中初始化 provinceId cityId 对应的计数在遍历 cityStorage.districtList 过程中往Map 对应provinceId cityId 增加计数 那么 有没有什么别的基础数据 是要在这个时候初始化的呢？例如 只给你一个 districtId 你怎么才能最快的 找到他对应的 cityId 和 provinceId或者 只给你一个 id 怎么最快找到他 对应的 name 呢Map我们可以构建一个Map来记录我们需要的信息districtId:cityIdcityId:provinceId那么 我可以通过 Map[districtId] 找到cityId Map[Map[districtId]] 找到 provinceIdid 和 name 的对应关系 也是如此而这些 可以在 计数的 过程进行 接着 通过已经选择地区 的 列表 获取provinceId cityId的数据 的计数 两份数据都有了 在渲染 省的时候 判断 两份Map中对应的计数 是否相同来渲染勾选 那半选的状态怎么表示呢？el-tree并不支持设置半选的状态，必须是通过数据的形式呢？ 通过模拟子节点的方法 当满足不全选的情况 模拟两个子节点123456789101112var children = [ &#123; id:provinceId+'111', label:name, type:'none' &#125;, &#123; id:provinceId+'222', label:name, type:'none' &#125;] 然后选中 其中一个 父元素自然就是半选状态 保存提交最后是保存提交时候的数据处理 由于模拟了半选状态 所以最后获取到的选中的数据 会有两种 一种常规的6位 还是一种是模拟的d{6}xxx 而且如果 是出现这种d{6}xxx的数据 代表的是它所在的一级有些被选中了 而这些数据还没有出现在 渲染树中 这是就 需要有一个数据结构记录 这种情况 在已选择的数据 初始化计数的时候 新构建一个Map 存储 provinceId cityId出现的数据的下标(我这边保存的是districtId)provinceId:[districtId,districtId,districtId]cityId:[districtId,districtId,districtId]至此 我们最后能拿到的 选中的 id 有 [310000,410000111,510100,610101]此时这份数据中 有provinceId cityId districtId 以及 模拟的半选数据 怎么尽可能的优雅的生成我们需要的格式呢？ 首先是分类 可以发现 xx0000表示的是省 xxx000 xxxx00 表示的是市1234567891011121314let _zeo = item.match(/(0+)$/g), type = _zeo ? _zeo[0] : '0' switch (type) &#123; case '0': districtList.push(item) break; case '00': case '000': cityList.push(item) break; case '0000': provinceList.push(item) break; &#125; 而这种410000111 数据 可以通过 先前的 Map 将数据并入 districtList 中 接着就是净化数据 省选择了 不需要市的所有id 市选择了 不需要区的所有id 总结 判断条件12345var sub = item.substr(0,2)var re =new RegExp('\\^' +sub+'\\\\d&#123;4&#125;'); // 省// var sub = item.substr(0,4)// var re =new RegExp('\\^' +sub+'\\\\d&#123;2&#125;'); // 市cityList.filter(code=&gt;!code.match(re)) 最后 provinceList cityList districtList 都是有效的选中值遍历一遍 cityStorage.districtList 将其中在provinceList cityList中存在id的数据并入 districtList中 此时 districtList 是最终有效的所有选中的 districtId值此时 cityId = Map[districtId] province=Map[cityId] 展示归并保存后希望展示成当选择了一个省份全部地区的时候展示省份名称当选择了一个省份下的部分市时展示市的名称当选择了一个市下的所有地区时,只展示市的名称当选择了一个市下的部分地区时,括号内展示地区名称 首先还是通过计数 获取 已经选中的有效的 provinceList cityList districtList数据格式{provinceId: “110000”,cityId: “110100”,districtId: “110101”} 构建一个存 selectNameList 用于存放已经选中的 name name可以通过前面的Map[id]获取 provinceList 选择的省没问题 直接推入 cityList 遍历 构建新的数据 格式 {provinceId: “110000”,cityId: “110100”,districtId: “1”}并入 districtList 中 对districtList 根据 cityId 排序 最后 遍历 districtList 通过标记判断每次是否是重复的cityId 设置数组 indeterminateNameList 记录不是全选的市的name不重复 将标记记为当前cityId 如果上一个元素的 districtCode 是 1 将 indeterminateNameList 存入 selectNameList 中selectNameList.push(‘(‘ + indeterminateNameList.join(‘，’) + ‘)’)districtId == 1 全选 存入 selectNameListdistrictId != 1 不是全选 存入 indeterminateNameList = [cityId]在这个过程中 有需要 还可以记录 cityId 和 indeterminateNameList的管理关系 最终 selectNameList.join(‘，’) 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730&lt;template&gt; &lt;div&gt; &lt;div class=\"title\"&gt; &lt;span&gt;管理配送模板&lt;/span&gt; &lt;/div&gt; &lt;p class=\"btn-wrap\"&gt; &lt;el-button type=\"primary\" @click=\"showTplLayer()\"&gt;新增配送模板&lt;/el-button&gt; &lt;/p&gt; &lt;div class=\"section\"&gt; &lt;div v-if=\"isReady\"&gt; &lt;div class=\"section-item\" v-for=\"(item,index) in distributionList\" :key=\"index\"&gt; &lt;div class=\"block-item o-h\"&gt; &lt;span&gt;模板名称：&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;el-button class=\"fl-r\" type=\"primary\" size=\"small\" @click=\"deleteTpl(index)\"&gt;删除&lt;/el-button&gt; &lt;el-button class=\"fl-r\" style=\"margin-right: 10px\" type=\"primary\" size=\"small\" @click=\"showTplLayer(index+'')\"&gt;修改 &lt;/el-button&gt; &lt;/div&gt; &lt;div class=\"block-item\"&gt; &lt;span v-if=\"item.type==1\"&gt;限制类型：仅发以下地区&lt;/span&gt; &lt;span v-else-if=\"item.type==2\"&gt;限制类型：以下地区不发货&lt;/span&gt; &lt;span v-else-if=\"item.type==3\"&gt;限制类型：限制仅发货省份中的不发货区县&lt;/span&gt; &lt;/div&gt; &lt;div class=\"block-item\"&gt; &lt;span&gt;限制地区：&lt;span v-if=\"isCityDetail\" v-html=\"limitName[index]\"&gt;&lt;/span&gt; &lt;i v-else class=\"el-icon-loading c-red\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"block-item\"&gt; &lt;span&gt;模板描述：&#123;&#123;item.desc&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div v-else class=\"block-item-loading\"&gt; &lt;i class=\"el-icon-loading c-red\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;el-dialog :title=\"tplLayer.title\" size=\"large\" v-model=\"tplLayer.show\"&gt; &lt;div class=\"price-ct\"&gt; &lt;div class=\"input-ct\"&gt; &lt;div&gt; &lt;span&gt;模板名称：&lt;/span&gt; &lt;el-input v-model=\"tplLayer.inputName\" placeholder=\"请输入内容\"&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;限制类型：&lt;/span&gt; &lt;el-radio-group v-model=\"tplLayer.radioType\"&gt; &lt;el-radio :label=\"1\"&gt;仅发以下地区&lt;/el-radio&gt; &lt;el-radio :label=\"2\"&gt;以下地区不发货&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;限制地区：&lt;/span&gt; &lt;div class=\"limit-tree-wrap\"&gt; &lt;!--:load=\"loadLimit\"--&gt; &lt;el-tree :data=\"limitData\" show-checkbox node-key=\"id\" ref=\"tree\" @node-expand=\"nodeExpand\" @node-collapse=\"nodeCollapse\" @current-change=\"checkChange\" @node-click=\"nodeClick\" highlight-current :props=\"defaultProps\"&gt; &lt;/el-tree&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;模板描述：&lt;/span&gt; &lt;el-input v-model=\"tplLayer.inputDesc\" placeholder=\"请输入内容\"&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div slot=\"footer\" class=\"dialog-footer\"&gt; &lt;el-button type=\"primary\" @click=\"saveTpl\"&gt;确 定&lt;/el-button&gt; &lt;el-button @click=\"cancelTpl\"&gt;取 消&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;el-dialog title=\"提示\" v-model=\"dialogVisible\" size=\"tiny\"&gt; &lt;span&gt;确定删除【&#123;&#123;distributionListName&#125;&#125;】模板？&lt;/span&gt; &lt;span slot=\"footer\" class=\"dialog-footer\"&gt; &lt;el-button @click=\"dialogVisible = false\"&gt;取 消&lt;/el-button&gt; &lt;el-button type=\"primary\" @click=\"confirmDelete\"&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123;mapState, mapActions&#125; from 'vuex' export default &#123; name: 'distributionTemplate', created ()&#123; this.initView() &#125;, data: () =&gt; (&#123; isReady:false, isCityDetail:false, tplLayer: &#123; show: false, title: '', inputName: '', inputDesc: '', radioType: 1, index: 0, cityArr: [], &#125;, limitName:[], localAllCity: &#123; provinceList: [], cityList: [], districtList: [] &#125;, dialogVisible: false, index: null, distributionListName: '', distributionList: [], limitData: [// &#123;// id: 1,// label: '一级 1',// children: [// &#123;// id: 4,// label: '二级 1-1',// children: [// &#123;// id: 9,// label: '三级 1-1-1'// &#125;// ]// &#125;]// &#125; ], defaultProps: &#123; children: 'children', label: 'label' &#125;, mapLimitData:&#123; &#125;, limitCheckList:&#123; province:[], city:[], district:[] &#125;, mapAllAreaName:&#123;&#125;, mapAllArea:&#123;&#125;, mapAllAreaList:[], mapAreaLength:&#123; &#125;, mapProvinceAreaLength:&#123;// 1:1 &#125;, mapCityAreaLength:&#123;// 1:&#123;// _len:1,// id:''// &#125; &#125;, checkMapAreaLength:&#123;&#125;, indeterminateArea:&#123;&#125; &#125;), computed: &#123; ...mapState(['allCity']) &#125;, methods: &#123; ...mapActions(['getDistributionTemplate', 'deleteDeliverTpl', 'saveDeliverTpl', 'getAllCity', 'callSetNotice']), initView() &#123; if (!Util.storage.get('CityStorage')) &#123; this.getAllCity() .then(() =&gt; &#123; Util.storage.set('CityStorage', this.allCity.data) this.initList() &#125;) &#125; else &#123; this.initList() &#125; &#125;, initList() &#123; this.setAreaBase() this.callGetDistributionTemplate() &#125;, setAreaBase()&#123; var allList = Util.storage.get('CityStorage') this.localAllCity.provinceList = allList.provinceList this.localAllCity.cityList = allList.cityList this.localAllCity.districtList = allList.districtList //初始化处理省 市 区 全选计数 this.localAllCity.provinceList.forEach((item)=&gt;&#123; this.mapProvinceAreaLength[item.provinceId] = 0 this.mapAllAreaName[item.provinceId] = item.name// this.mapAllAreaList[item.provinceId] = [] &#125;) this.localAllCity.cityList.forEach((item)=&gt;&#123; this.mapCityAreaLength[item.cityId] = &#123; len:0, id:item.provinceId &#125; this.mapAllArea[item.cityId] = item.provinceId// this.mapAllAreaList[item.cityId] = []// this.mapAllAreaList[item.provinceId].push(item.cityId) this.mapAllAreaName[item.cityId] = item.name &#125;) this.localAllCity.districtList.map((item)=&gt;&#123; if(this.mapCityAreaLength[item.cityId])&#123; this.mapCityAreaLength[item.cityId].len++ this.mapProvinceAreaLength[this.mapCityAreaLength[item.cityId].id] ++ &#125; item.provinceId = this.mapAllArea[item.cityId] this.mapAllArea[item.districtId] = item.cityId// this.mapAllAreaList[item.cityId].push(item.districtId) this.mapAllAreaName[item.districtId] = item.name &#125;) &#125;, callGetDistributionTemplate()&#123; this.isReady = false this.getDistributionTemplate() .then((rs) =&gt; &#123; //遍历城市编码转换城市名称 this.distributionList = rs // 延时加载// this.$nextTick(() =&gt; &#123;// this.setLimitAreaName()// &#125;) this.isReady = true this.isCityDetail = false this.limitName = [] setTimeout(function()&#123; this.setLimitAreaName() this.isCityDetail = true &#125;.bind(this),1000) &#125;) &#125;, setLimitAreaName()&#123; for (let i = 0, j = this.distributionList.length; i &lt; j; i++) &#123; let list = this.distributionList[i].limitAreaList let _checkMapAreaLength = &#123;&#125;, _province = [], _city = [], _district = [] for (let n = 0, m = list.length; n &lt; m; n++) &#123; let item = list[n] if (!_checkMapAreaLength[item.provinceCode]) &#123; _checkMapAreaLength[item.provinceCode] = 1 &#125; else &#123; _checkMapAreaLength[item.provinceCode]++ &#125; if (!_checkMapAreaLength[item.cityCode]) &#123; _checkMapAreaLength[item.cityCode] = 1 &#125; else &#123; _checkMapAreaLength[item.cityCode]++ &#125; &#125; for (let i in _checkMapAreaLength) &#123; // 选择的 省 if (_checkMapAreaLength[i] == this.mapProvinceAreaLength[i]) &#123; _province.push(i) &#125; // 选择 的 市 if (this.mapCityAreaLength[i] &amp;&amp; _checkMapAreaLength[i] == this.mapCityAreaLength[i].len) &#123; _city.push(i) &#125; &#125; _district = list.filter(item =&gt; !_province.includes(item.provinceCode) &amp;&amp; !_city.includes(item.cityCode)) let _sNameList = [], _limitList = [] _limitList = _limitList.concat(_district) _province.forEach((item) =&gt; &#123; _sNameList.push(this.mapAllAreaName[item]) &#125;) _city.forEach((item) =&gt; &#123; if (!_province.includes(this.mapAllArea[item])) &#123; let _opts = &#123; provinceCode: '', cityCode: item, districtCode: 1, &#125; _limitList.push(_opts) &#125; &#125;) _limitList.sort((a, b) =&gt; &#123; return a.cityCode - b.cityCode &#125;) let current = '', _subList = [] _limitList.forEach((item, idx) =&gt; &#123; if (item.cityCode != current) &#123; current = item.cityCode if (_limitList[idx - 1] &amp;&amp; _limitList[idx - 1].districtCode != 1) &#123; _sNameList.push(this.mapAllAreaName[_limitList[idx - 1].cityCode] + '(&lt;span style=\"color:#aaa\"&gt;' + _subList.join('，') + '&lt;/span&gt;)') &#125; if (item.districtCode == 1) &#123; _sNameList.push(this.mapAllAreaName[item.cityCode]) &#125; else &#123; _subList = [this.mapAllAreaName[item.districtCode]] &#125; &#125; else &#123; _subList.push(this.mapAllAreaName[item.districtCode]) &#125; &#125;) this.limitName.push(_sNameList.join('，')) &#125; &#125;, showTplLayer(index)&#123; this.index = index || null this.tplLayer.title = index ? '修改配送模板' : '新增配送模板' this.tplLayer.show = true if (index) &#123; var _thisTplObj = this.distributionList[index] this.tplLayer.inputName = _thisTplObj.name this.tplLayer.inputDesc = _thisTplObj.desc this.tplLayer.radioType = _thisTplObj.type this.setLimitCheckList(_thisTplObj.limitAreaList) &#125; else &#123; this.tplLayer.inputName = '' this.tplLayer.inputDesc = '' this.tplLayer.radioType = 1 &#125; this.limitDefault() &#125;, limitDefault()&#123; let _check = [] this.localAllCity.provinceList.forEach((item) =&gt; &#123; let _opts = &#123; id: item.provinceId, label: item.name, type:'provinceId', provinceId:item.provinceId, cityId:'', districtId:'', children:[ &#123; id:item.provinceId+'111', label:item.name, type:'none' &#125;, &#123; id:item.provinceId+'222', label:item.name, type:'none' &#125; ], &#125; this.limitData.push(_opts) if(this.limitCheckList.province.includes(item.provinceId))&#123; _check.push(item.provinceId) _check.push(item.provinceId+'111') _check.push(item.provinceId+'222') &#125; else if(this.checkMapAreaLength[item.provinceId])&#123; _check.push(item.provinceId+'111') &#125; &#125;) this.setCheckLimitArea(_check) &#125;, mockData()&#123; let _list = [ &#123; provinceCode:'110000', cityCode:'110100', districtCode:'110228' &#125;, &#123; provinceCode:'110000', cityCode:'110100', districtCode:'110229' &#125;,// &#123;// provinceCode:'110000',// cityCode:'110100',// districtCode:'110230'// &#125; ] var _len = new Array(17).fill(1) _len.map((item,idx)=&gt;&#123; let _code = '1101' + (idx &lt; 9 ? '0' : '') + (idx+1) if(idx != 9)&#123; let _opts = &#123; provinceCode:'110000', cityCode:'110100', districtCode:_code &#125; _list.push(_opts) &#125; &#125;) return _list &#125;, setLimitCheckList(rs)&#123;// let list = this.mockData() let list = rs list.forEach((item) =&gt; &#123; //已选择 的 省份 计数 if (!this.checkMapAreaLength[item.provinceCode]) &#123; this.checkMapAreaLength[item.provinceCode] = 1 this.indeterminateArea[item.provinceCode] = [item.cityCode] &#125; else &#123; this.checkMapAreaLength[item.provinceCode]++ if(!this.indeterminateArea[item.provinceCode].includes(item.cityCode))&#123; this.indeterminateArea[item.provinceCode].push(item.cityCode) &#125; &#125; //已选择 的 城市 计数 if (!this.checkMapAreaLength[item.cityCode]) &#123; this.checkMapAreaLength[item.cityCode] = 1 this.indeterminateArea[item.cityCode] = [item.districtCode] &#125; else &#123; this.checkMapAreaLength[item.cityCode]++ if(!this.indeterminateArea[item.cityCode].includes(item.districtCode))&#123; this.indeterminateArea[item.cityCode].push(item.districtCode) &#125; &#125; //选择的 区 this.limitCheckList.district.push(item.districtCode) &#125;) for (let i in this.checkMapAreaLength) &#123; // 选择的 省 if (this.checkMapAreaLength[i] == this.mapProvinceAreaLength[i]) &#123; this.limitCheckList.province.push(i) &#125; // 选择 的 市 if (this.mapCityAreaLength[i] &amp;&amp; this.checkMapAreaLength[i] == this.mapCityAreaLength[i].len) &#123; this.limitCheckList.city.push(i) &#125;// if(this.mapProvinceAreaLength[i])&#123;// console.log(i,this.checkMapAreaLength[i],this.mapProvinceAreaLength[i])// &#125;// if(this.mapCityAreaLength[i])&#123;// console.log(i,this.checkMapAreaLength[i],this.mapCityAreaLength[i].len)// &#125; &#125;// console.log(this.limitCheckList.city) &#125;, nodeExpand(data, node)&#123; let id = data.id, _level = node.level, _checked = node.checked, _indeterminate = node.indeterminate // 已经展开 back if (this.mapLimitData[id]) return this.mapLimitData[id] = true // 市 区 对应map let _levelMap = &#123; 1: &#123; idLabel: 'cityId', fetchLabel: 'cityList', perIdLabel: 'provinceId' &#125;, 2: &#123; idLabel: 'districtId', fetchLabel: 'districtList', perIdLabel: 'cityId' &#125; &#125; let configLevel = _levelMap[_level] let _list = [], selectId = [] this.localAllCity[configLevel.fetchLabel].filter(item =&gt; item[configLevel.perIdLabel] == id).forEach((item) =&gt; &#123; let _opts = &#123; id: item[configLevel.idLabel]+'', label: item.name, provinceId: item.provinceId || '', cityId: item.cityId, districtId: item.districtId || '', type: configLevel.idLabel &#125; if (_level &lt; 2) &#123; _opts.children = [ &#123; id: item[configLevel.idLabel] + '111', label: item.name, type: 'none' &#125;, &#123; id: item[configLevel.idLabel] + '222', label: item.name, type: 'none' &#125; ] &#125; // 父 选择 if (_checked) &#123; selectId.push(item[configLevel.idLabel]) &#125; // 父 未选择 但是有子元素选择 else if (_indeterminate) &#123; if (this.limitCheckList.city.includes(item[configLevel.idLabel])) &#123; selectId.push(item[configLevel.idLabel]) selectId.push(item[configLevel.idLabel]+'111') selectId.push(item[configLevel.idLabel]+'222') &#125; else if (this.checkMapAreaLength[item[configLevel.idLabel]]) &#123; selectId.push(item[configLevel.idLabel] + '111') &#125; if (this.limitCheckList.district.includes(item[configLevel.idLabel])) &#123; selectId.push(item[configLevel.idLabel]) &#125; &#125; _list.push(_opts) &#125;)// console.log(selectId) data.children = _list this.setCheckLimitArea(selectId) &#125;, nodeCollapse(data, node)&#123; &#125;, checkChange(data)&#123; &#125;, nodeClick(data,node)&#123;&#125;, setCheckLimitArea(list)&#123; if (!list.length) return; this.$nextTick(() =&gt; &#123; let _checkList = this.$refs.tree.getCheckedKeys().concat(list) this.$refs.tree.setCheckedKeys(_checkList); &#125;) &#125;, loadLimit(node,resolve)&#123; if (node.level === 0) &#123; return resolve(this.limitData); &#125; let configLevel = &#123; idLabel:'', fetchLabel:'', perIdLabel:'' &#125;, id = node.data.id if (node.level === 1) &#123; configLevel.fetchLabel = 'cityList' configLevel.idLabel = 'cityId' configLevel.perIdLabel = 'provinceId' &#125; else if (node.level === 2) &#123; configLevel.fetchLabel = 'districtList' configLevel.idLabel = 'districtId' configLevel.perIdLabel = 'cityId' &#125; else &#123; return resolve([]); &#125; let _limitData = [] this.localAllCity[configLevel.fetchLabel].filter(item=&gt;item[configLevel.perIdLabel] == id).forEach((item)=&gt;&#123; let _opts = &#123; id: item[configLevel.idLabel], label: item.name, &#125; _limitData.push(_opts) &#125;) return resolve(_limitData); &#125;, cancelTpl()&#123; this.tplLayer.show = false this.limitData = [] this.mapLimitData = &#123;&#125; this.limitCheckList = &#123; province:[], city:[], district:[] &#125; this.checkMapAreaLength = &#123;&#125; this.indeterminateArea = &#123;&#125; &#125;, deleteTpl(index)&#123; this.index = index this.distributionListName = this.distributionList[index].name this.dialogVisible = true &#125;, saveTpl()&#123; var limitAreaList = [] if (!this.tplLayer.inputName) &#123; this.getNotice('请输入运费模板名称') return false &#125; if (!this.tplLayer.inputDesc) &#123; this.getNotice('请输入运费模板描述') return false &#125; limitAreaList = this.changeSelectCodeToList(this.$refs.tree.getCheckedKeys())// return false const opts = &#123; id: this.index === null ? '' : this.distributionList[this.index].id, name: this.tplLayer.inputName, desc: this.tplLayer.inputDesc, type: this.tplLayer.radioType, limitAreaList: limitAreaList, exceptAreaList: [] &#125; this.saveDeliverTpl(opts) .then(() =&gt; &#123; this.callGetDistributionTemplate() this.cancelTpl() &#125;) &#125;, changeSelectCodeToList(list)&#123;// //xx0000 省份// // xxxx00 市// // xx0000xxx 省份半选// // xxxx00xxx 市半选 let indeterminate = [], districtList = [], cityList = [], provinceList = [] for (let i = 0, j = list.length; i &lt; j; i++) &#123; let item = list[i] if (item.length &gt; 6) &#123; let _item = item.replace(/\\d&#123;3&#125;$/, '') if(_item.match(/0000$/g))&#123; indeterminate = indeterminate.concat(this.indeterminateArea[_item]) &#125; else &#123; indeterminate.push(_item) &#125; continue; &#125; let _zeo = item.match(/(0+)$/g) let type = _zeo ? _zeo[0] : '0' switch (type) &#123; case '0': districtList.push(item) break; case '00': case '000': cityList.push(item) break; case '0000': provinceList.push(item) break; &#125; &#125;// console.log('i',indeterminate)// console.log('d',districtList)// console.log('c',cityList)// console.log('p',provinceList)// return false indeterminate.forEach((item)=&gt;&#123; if(this.indeterminateArea[item])&#123; districtList = districtList.concat(this.indeterminateArea[item]) &#125; &#125;) provinceList.forEach((item)=&gt;&#123; let _sub = item.substr(0,2) var re =new RegExp('\\^' +_sub+'\\\\d&#123;4&#125;','g'); cityList = cityList.filter((code)=&gt;&#123; return !code.match(re) &#125;) districtList = districtList.filter((code)=&gt;&#123; return !code.match(re) &#125;) &#125;) cityList.forEach((item)=&gt;&#123; let _sub = item.substr(0,4) var re =new RegExp('\\^' +_sub+'\\\\d&#123;2&#125;','g'); districtList = districtList.filter((code)=&gt;&#123; return !code.match(re) &#125;) &#125;) let _limitList = [] districtList.forEach((item)=&gt;&#123; let _opts = &#123; provinceCode:this.mapAllArea[this.mapAllArea[item]], cityCode:this.mapAllArea[item], districtCode:item &#125; _limitList.push(_opts) &#125;) this.localAllCity.districtList.forEach((item)=&gt;&#123; if(cityList.includes(item.cityId) || provinceList.includes(item.provinceId))&#123; let _opts = &#123; provinceCode:item.provinceId, cityCode:item.cityId, districtCode:item.districtId &#125; _limitList.push(_opts) &#125; &#125;)// console.log('d',districtList)// console.log('c',cityList)// console.log('p',provinceList)//// console.log('limit',_limitList) return _limitList &#125;, confirmDelete()&#123; this.deleteDeliverTpl(&#123; templateId: this.distributionList[this.index].id &#125;).then(() =&gt; &#123; this.callGetDistributionTemplate() this.dialogVisible = false &#125;) &#125;, getNotice(msg)&#123; const notice = &#123; isShow: true, msg: msg, &#125; this.callSetNotice(notice) &#125;, &#125; &#125;&lt;/script&gt;&lt;style lang='less' rel=\"stylesheet/less\" scoped&gt; .block-item-loading&#123; text-align: center; line-height: 400px; font-size: 30px; &#125; .slide-fade-enter, .slide-fade-leave-to &#123; transform: translateX(60px); opacity: 1; &#125;&lt;/style&gt;","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"},{"name":"vue","slug":"vue","permalink":"//blog.fenghou.site/tags/vue/"}]},{"title":"前端异常监控","date":"2018-03-26T01:40:57.000Z","path":"2018/03/26/2018-03-26-fe-error-statistics/","text":"前端页面报错监听 统计 异常捕获script errorwindow.error 进行全局捕获对于从cdn引入的js script type123456789101112131415161718192021222324252627282930313233343536373839404142//VueVue.config.errorHandler = function (err, vm, info) &#123; let &#123; message, // 异常信息 name, // 异常名称 script, // 异常脚本url line, // 异常行号 column, // 异常列号 stack // 异常堆栈信息 &#125; = err; console.log(err)&#125;//Reactclass ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; this.setState(&#123; hasError: true &#125;); // 将异常信息上报给服务器 logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; return '出错了'; &#125; return this.props.children; &#125;&#125;//windowwindow.onerror = function(errorMessage, scriptURI, lineNo, columnNo, error) &#123; console.log('errorMessage: ' + errorMessage); // 异常信息 console.log('scriptURI: ' + scriptURI); // 异常文件路径 console.log('lineNo: ' + lineNo); // 异常行号 console.log('columnNo: ' + columnNo); // 异常列号 console.log('error: ' + error); // 异常堆栈信息&#125;; 异常上报模拟图片请求 异常分析nginx 日志分析 页面 图形可视化 把前端监控做到极致","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"},{"name":"nginx","slug":"nginx","permalink":"//blog.fenghou.site/tags/nginx/"}]},{"title":"css-world","date":"2018-03-16T02:04:47.000Z","path":"2018/03/16/2018-02-26-css-world/","text":"Css 神奇的width:auto块级元素 常规定位时 宽度默认展开为父元素的宽度 遇到margin padding 会减小宽度float absolute定位时 宽度包裹内部元素 单当 left和right一起出现时 根据父元素宽度展开 block inline外在表现盒子 内在盒子display:inline-block脑补display:inline-inlinedisplay:block-block","tags":[{"name":"css","slug":"css","permalink":"//blog.fenghou.site/tags/css/"}]},{"title":"Knowledge","date":"2018-03-09T03:18:48.000Z","path":"2018/03/09/2018-03-09-interview/","text":"MVVM 模板引擎String-based 模板技术 (基于字符串的parse和compile过程)Dom-based 模板技术 (基于Dom的link或compile过程)杂交的Living templating 技术 (基于字符串的parse 和 基于dom的compile过程) RegularJS 作者对前端模板技术的总结 界面之下：还原真实的MV*模式 ReactReact 生命周期类型校验 PropTypes prop-typesVirtual DOM渲染优化 Redux让变化可控制控制数据流 要修改 state 必须通过 dispatch 一个 action为了描述 action 如何改变 state 树 必须编写 reducersmiddlewaremiddleware react-redux contextProvider 构建根节点 将store 写入contextconnect 根据传入的参数 将store中的state dispatch 混入 组件props中 react-router React.js cheatsheetSyntheticEventreact小书123456&lt;style&gt; #wrapper~div,#granted-modal&#123; opacity:0!important; display:none!important; &#125;&lt;/style&gt; 深度剖析：如何实现一个 Virtual DOM 算法MobX redux connectreact-redux Provider router-route Vue","tags":[{"name":"React","slug":"React","permalink":"//blog.fenghou.site/tags/React/"},{"name":"Vue","slug":"Vue","permalink":"//blog.fenghou.site/tags/Vue/"}]},{"title":"Knowledge","date":"2018-03-08T03:19:05.000Z","path":"2018/03/08/2018-03-08-interview/","text":"Node &amp;&amp; Linux &amp;&amp; Nginx &amp;&amp; 自动化脚本 Linux依赖的安装 xshell链接的配置 Nginx代理nginx 反向代理静态资源服务器 资源压缩gzip 压缩 日志分析分析请求日志前端异常监控 Node服务器服务器 sessionexpress 服务 express-session 数据库node 链接 mysql 文件处理远程文件拉取脚手架配置 爬虫网络爬虫puppeteer gulpgulp 前端自动化 rollup深入学习rollup来进行打包 webpack###配置配置合并 分离本质实现原理 ###启动命令行启动 配合node启动 webpack详解","tags":[{"name":"Node","slug":"Node","permalink":"//blog.fenghou.site/tags/Node/"},{"name":"Linux","slug":"Linux","permalink":"//blog.fenghou.site/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"//blog.fenghou.site/tags/Nginx/"}]},{"title":"Knowledge","date":"2018-03-07T09:22:43.000Z","path":"2018/03/07/2018-03-07-interview/","text":"Canvas &amp;&amp; Js Canvas颜色提取毛笔字连线小球烟花星空 Js规范命名规范命名规范检查eslint APIES5/ES6/ES730-seconds-of-code 类型类型存储对象 正则元字符限定符test exec matchreplace 事件模型事件冒泡 从点击外外 false事件捕获 从点击外往里 true事件委托 作用域和上下文函数作用域作用域链执行环境执行上下文 事件机制eventLoop 闭包函数私有化柯里化IIFE 原型原型原型链 继承继承方式 thisapply call bind 剪头函数 模块化commonJSimport 异步PromiseGeneratorasync await图片预览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748getFileImage:(src)=&gt;&#123; return new Promise((resolve,reject) =&gt; &#123; var image = new Image(); image.onload = function()&#123; const width = image.width const height = image.height resolve(&#123;width,height&#125;) &#125; image.onerror = function(err)&#123; reject(err) &#125; image.src = src; &#125;) &#125;, getFileReaderImage:(file)=&gt;&#123; return new Promise((resolve,reject)=&gt; &#123; var fr = new FileReader(); fr.onload = async function(_file) &#123; try&#123; const imageWh = await UtilTool.getFileImage(_file.target.result) const size = file.size const type = file.type resolve(&#123;...imageWh,size,type&#125;) &#125; catch (err) &#123; reject(err) &#125; // var image = new Image(); // image.onload = function()&#123; // const width = image.width // const height = image.height // const size = file.size // const type = file.type // resolve(&#123;width,height,size,type&#125;) // &#125; // image.onerror = function(err)&#123; // reject(err) // &#125; // image.src = _file.target.result; &#125; fr.onerror = function(err)&#123; reject(err) &#125; fr.readAsDataURL(file); &#125;) &#125;","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"//blog.fenghou.site/tags/canvas/"}]},{"title":"Knowledge","date":"2018-03-06T02:45:29.000Z","path":"2018/03/06/2018-03-06-interview/","text":"通信 &amp;&amp; 浏览器 通信Httphttp协议客户端请求 服务端响应 单次链接无状态 对处理的事务没有记忆request headerscontent-type 请求传输的MIME类型常用的application/json json数据格式 {username:”name”,password:”pwd”}application/x-www-from-urlencoded 经过编码的键值对请求字符串 username=name&amp;password=pwd注意点：这边转换的时候需要进行encodeURIComponent转码处理 response headerscontent-type 返回资源的MIME类型text/htmlimage/jpegapplication/javascripttext/cssapplication/json 请求类POSTGET听说『99% 的人都理解错了 HTTP 中 GET 与 POST 的区别』？？HTTP｜GET 和 POST 区别？网上多数答案都是错的！rfc文档HTTP权威指南pdf 密码 7p7m HttpsHttp协议的安全版本在TCP协议删加了一层SSL协议网络七层协议 TCPTCP协议连接时三次握手TCP协议断开时四次握手 AjaxAsynchronous Javascript And XML 异步JavaScript和XMLXMLHttpRequestAPI事件状态 websocket双工通信websocket协议本质上是一个基于TCP的协议是先通过HTTP/HTTPS协议发起一条特殊的HTTP请求进行握手后创建一个用于交换数据的TCP连接此后服务端与客户端通过此TCP连接进行实时通信 跨域nginx 代理1234567891011121314server &#123; listen 80; server_name music.fenghou.site; root /admin/fenghou/www/super_music/view/dist; location / &#123; index index.html; &#125; location /nateAPI/ &#123; proxy_pass http://localhost:4000; &#125; location /MusicAPI/ &#123; proxy_pass http://localhost:4000/; &#125; &#125; node 中间件123456789101112var express = require('express')var app = express()var proxyMiddleware = require('http-proxy-middleware')let _opts = &#123; target: 'http://114.215.198.55:9004', changeOrigin: true, pathRewrite: &#123; '^/goodsAdmin': '' &#125;, &#125;app.use(proxyMiddleware('/goodsAdmin', _opts))app.listen() webpack dev-server12345678910111213141516171819202122232425262728293031module.exports = &#123; devServer: &#123; clientLogLevel: 'warning', historyApiFallback: &#123; rewrites: [ &#123; from: /.*/, to: path.join('/', 'index.html') &#125;, ], &#125;, hot: true, contentBase: false, // since we use CopyWebpackPlugin. compress: true, host: 'localhost', port: '8080', open: true, overlay: &#123; warnings: false, errors: true &#125;, publicPath: '/', proxy: &#123; '/goodsAdmin': &#123; target: 'http://114.215.198.55:9004', changeOrigin: true, pathRewrite: &#123; '^/goodsAdmin': '' &#125;, &#125;, &#125;, quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; poll: false, &#125; &#125;,&#125; XSS：跨站脚本（Cross-site scripting）CSRF：跨站请求伪造（Cross-site request forgery） 浏览器缓存缓存主要设置在请求头request headerPragmaCache-Control no-cache、no-store、max-ageif-none-matchif-modified-since response headerEtagexpireslast-modified 存储cookielocalStoragelocalSession 渲染页面加载域名解析-页面解析-渲染渲染流程dom解析成 DOM Tree 此时遇到资源文件开始下载遇到css下载 并且开始解析遇到js文件下载 并且开始解析遇到图片资源 开始下载所以说js 放在头部加载 会阻塞 dom解析 css 解析 CSS Rule Tree 并且合并到DOM Tree 成 Rendering Tree 这是用到的css 里的图片资源开始请求加载Rendering Tree 渲染树并不等同于DOM树 因为一些像display:none的东西就没必要放在渲染树中了。然后 计算每个Element的位置 又叫layout和reflow过程最后通过调用操作系统Native GUI的API绘制 js加载事件 windows.onload dom节点 资源全部加载完成 重排和重绘 动画优化 浏览器工作原理 WebKit for DevelopersVelocityConf: Rendering Performance Case StudiesGPU Accelerated Compositing in ChromeHigh Performance AnimationsPreventing layout thrashingHow Browsers Work: Behind the scenes of modern web browsers16毫秒的优化——Web前端性能优化的微观分析CSS3动画那么强，requestAnimationFrame还有毛线用？Compositing in Blink / WebCore: FromWebCore::RenderLayer to cc:LayerWebkit技术内幕","tags":[{"name":"浏览器","slug":"浏览器","permalink":"//blog.fenghou.site/tags/浏览器/"}]},{"title":"Knowledge","date":"2018-03-05T01:29:55.000Z","path":"2018/03/05/2018-03-05-interview/","text":"Html &amp;&amp; CssQuestions-AnswersQuestions-Answers Htmlhtml的规范首先是标签的语义化语义化 顾名思义就是 什么时候该用什么标签 例如header section footer接着是标签的嵌套规则典型的就是 h1-h6 p 标签中不能再嵌套块级元素 原则上行内元素内不能嵌套块级元素 meta标签用于提供页面的元信息 比如12345678针对搜索引擎 &lt;meta name=\"robots\" content=\"noarchive\" /&gt; 关键词 &lt;meta name=\"Keywords\" content=\"关键字\" /&gt;描述 &lt;meta name=\"Description\" content=\"页面的描述\" /&gt;重定向 &lt;meta http-equiv=\"Refresh\" content=\"5;url=https://fenghou.site\" /&gt;通知浏览器接收类型 &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;网页可视区域的设置 &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,user-scalable=no\" /&gt;不识别数字为电话号码 &lt;meta content=\"telephone=no\" name=\"format-detection\" /&gt;针对iphone 允许全屏模式浏览 &lt;meta content=\"yes\" name=\"apple-mobile-web-app-capable\" /&gt; csscss的规范css方面的规范 首先体现在命名规范上 例如 BEM 规范 block(块) Element(元素) Modifier(修饰器)命名方式如下 block__element-modifier 基本上采用BEM表示该元素出现的频率很高例如下面的一个商品列表12345678&lt;div class=\"product\"&gt; &lt;div class=\"product__header-wrap\"&gt; &lt;div class=\"product__header\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"product__footer-wrap\"&gt; &lt;div class=\"product__footer\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; BEM 需要配合postcss-salad 或者 postcss-bem 使用无非就是在复杂的容器中如何正确的命名元素 也不是BEM是必须的 但起码这种思想是可以借鉴的就是命名划分的维度 块 元素 修饰符 预处理传统的css不支持 方法嵌套 以及兼容性的拓展 而预处理就是解决了这一系列问题如sass 允许在在css 中使用 变量 方法 和嵌套如postcss 允许我们配置插件在处理css 例如 autoprefixer插件 用来自动补充需要兼容的浏览器前缀 盒模型盒模型其实是元素框处理元素内容、内边距、边框和外边距的规定方式容器真实宽度的计算 width(真实) = content-box-width + padding-box-width + border-box-widthcontent-box 标准盒模型 width(真实) = width(设置的宽度) + padding-box-box + border-box-widthborder-box IE盒模型 width(真实) = width(设置的宽度)也就是说 在标准盒模型中 设置的width 其实是 content-box 的width在 IE盒模型中 设置的width 是 整个盒模型的width 盒模型下的背景css中背景的渲染也提供了不同的计算方式background-origin 规定了背景开始渲染的位置background-clip 规定了背景实际显示的位置background-position 表示从这张背景图片的什么位置 开始渲染在 元素背景上background-position:X% Y%(百分比值) 表示会把图片 横向X% 纵向的Y% 的点与 元素 横向X% 纵向的Y%点对齐background-position:Xpx Ypx(数值) 表示图片距离背景起始绘制点的距离 FC(Formatting Context)FC 格式化上下文BFC 块级格式化上下文内部的Box会在垂直方向 一个接一个地放置。BFC就是页面上的一个隔离的独立容器 容器里面的子元素不会影响到外面的元素 反之也如此 例如 消除margin重叠计算BFC的高度时 浮动元素也参与计算 例如 清除浮动BFC的区域不会和 float Box 重合 例如 两列布局 IFC 行内格式化上下文IFC从包含块水平方向 一个接一个放置 margin padding在水平方向有效IFC默认对齐方式 vertical-align:baseline 所以同时存在有内容的内联元素和没内容的内联元素 有内容的 会往下掉 GFC 网格布局格式化上下文display值为grid的元素将会获得一个独立的渲染区域我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间FFC 自适应格式化上下文display值为flex或者inline-flex的元素将会生成自适应容器（flex container）Flex Box 由伸缩容器和伸缩项目组成通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。W3C文档BFCW3C文档IFCBFC 神奇背后的原理 布局之道布局 简单的可以理解为在文档流下 元素的排版规则在传统的布局按照文档流正常排布遇到需要脱离文档流的 一般通过absolute定位或float浮动来解决为了解决程序员日益增长的精神需要同浏览器传统的布局之间的矛盾css3中新增了 flex布局和grid布局 FFC和GFC 应运而生flexbox plygroundflex文档grid布局指南CSS布局解决方案（终结版） 移动端布局移动端的布局跟pc基本一样主要区别在于 移动端样式中的1px 不等于 屏幕上的1px1px!=1px移动端rem布局淘宝rem方案 是将页面划分为10rem 1rem表示的就是页面的1/10 但这对设计稿并不友好可以自定义一个转换方法 准换为 设计稿的尺寸1234@function remChange($args) &#123; @return $args / 750 * 10rem;&#125; 响应式和自适应简单来说就是能适应不同的尺寸浏览器常见的做法 根据屏幕宽度的100%来布局淘宝的rem方案也是一种解决方案跟rem方案异曲同工的是通过 可视单位 vw vh解决vw 相对于视窗的宽度：视窗宽度是100vwvh 相对于视窗的高度：视窗宽度是100vh上面的做法严格上来说是自适应的范畴 在不同的终端显示相同 而相应式 通俗的讲 就是大屏我能放下三个div 小点我能放下两个div一般的做法是通过 css的媒体查询来配置不同尺寸下的样式123@media screen and (max-width: 1080px)&#123; //小于1080时代码生效&#125; 各种居中的方案传统布局中图片垂直水平居中内部需要居中的图片absolute 定位top left bottom right 设为0margin:auto浏览器会计算容器的margin外部容器的宽度 = 内部容器宽度 + 定位left + 定位right + margin-left + margin-right 浏览器会根据这个规则分配 居中对于 Flex Box 和 Grid布局来说有点太儿戏 动画css动画三剑客transform 变形transitions 过渡animation 动画 css中的层叠关系css中的层叠规则 一些注意点和技巧利用多重背景叠加规则 是 先写的在上面1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt;.box&#123; width: 100px; height: 100px; background-image: linear-gradient( transparent 8%, rgba(0, 0, 0, 0.1) 8%, rgba(0, 0, 0, 0.1) 14%, transparent 14%, transparent 86%, rgba(0, 0, 0, 0.1) 86%, rgba(0, 0, 0, 0.1) 92%, transparent 92% ), linear-gradient( rgba(255, 255, 255, 0.75), rgba(255, 255, 255, 0) ), linear-gradient( 45deg, transparent 40%, rgba(0, 0, 0, 0.1) 40%, rgba(0, 0, 0, 0.1) 60%, transparent 60% ), linear-gradient(white, white); background-size: cover, cover, 4px 4px, cover; &#125;&lt;/style&gt; css背景莫名的空白line-height和vertical-align利用盒模型计算规则制作几何图形123456789101112131415&lt;style&gt;.box&#123; box-sizing: border-box; width: 50px; border-left:50px solid rgb(255,255,0); border-bottom: 25px solid transparent; border-top: 25px solid transparent;&#125;.box2&#123; box-sizing: border-box; width: 50px; border-left:50px solid rgb(255,255,0); border-bottom: 50px solid transparent;&#125;&lt;/style&gt; 文字溢出的省略表示123456789101112131415//单行.clamp&#123;width: 150px;overflow: hidden;white-space: nowrap;text-overflow: ellipsis;&#125;//多行.line-clamp&#123;width: 150px;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical;overflow: hidden;&#125; 单行文字溢出单行文字溢出单行文字溢出多行文字溢出多行文字溢出多行文字溢出多行文字溢出多行文字溢出负边距margin-top 设为负值 容器会往上margin-bottom 设为赋值 容器会从下往上搜索拓展 俩容器内容不同 保证高度一致12345678910111213141516171819&lt;style&gt;.wrap&#123; overflow: hidden;&#125;.box&#123; margin-bottom: -10000px; padding-bottom: 10000px;&#125;.wrap&#123; display: table-row;&#125;.box&#123; display: table-cell;&#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/div&gt;伪元素和伪类伪元素::before ::after ::first-letter ::first-line伪类: css2 :hover :active :focus :first-child … css3 :checked :nth-child(n) :last-child …/ 为不同语言指定引号的表现 /:lang(ch) &gt; q { quotes: ‘“’ ‘”’; }:lang(en) &gt; q { quotes: ‘“‘ ‘“‘; }:lang(no) &gt; q { quotes: ‘«’ ‘»’; }/ 在 q 标签的前后插入引号 /q:before { content: open-quote; }q:after { content: close-quote; }这本书很赞！This book is very good!denne bog er fantastisk!","tags":[{"name":"css","slug":"css","permalink":"//blog.fenghou.site/tags/css/"},{"name":"html","slug":"html","permalink":"//blog.fenghou.site/tags/html/"}]},{"title":"查看Nginx日志","date":"2018-02-03T09:35:27.000Z","path":"2018/02/03/2018-02-03-nginx-log/","text":"Nginx 日志分析 日志组成nginx的默认日记位置123#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info; nginx的默认日志配置文件 12345log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log logs/access.log main; 位置和格式都可以在 nginx.conf配置中设置 查看日志实时监控 tail -f filename 获取对应格式(访问的ip) awk ‘{print $1}’ 过滤信息(16点到17点的日志) grep “03/Feb/2018:1[6-7]” filename-o 只输出匹配的内容 组合 tail -f filename | grep “03/Feb/2018:1[6-7]” filename | awk ‘{print $1}’ 翻阅(awk处理nginx日志)[http://blog.csdn.net/KimmKing/article/details/52727845]","tags":[{"name":"linux","slug":"linux","permalink":"//blog.fenghou.site/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"//blog.fenghou.site/tags/nginx/"}]},{"title":"巧用数组存储","date":"2017-12-11T01:43:41.000Z","path":"2017/12/11/2017-12-11-array-storage-memory/","text":"多重数组赋值12345678910111213141516171819202122232425262728293031var cates = [ &#123; label:'', value:'', cates:[ &#123; label:'', value:'', cates:[ &#123; label:'me', value:'', cates:[] &#125; ] &#125; ] &#125; ]//现在我想给label='me'的cates 赋值怎么做//假如我知道他的结构层级是[0,0,0]//you can cates[0].cates[0].cates[0].cates = [1,2,3,4]// other waylet _item = [0,0,0]let _arr = []_item.map((item)=&gt;&#123; _arr = cates[item]&#125;)_arr = [1,2,3,4]//此时 _arr 和 cates[0].cates[0].cates[0].cates 指向 相同 存储空间","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"},{"name":"vue","slug":"vue","permalink":"//blog.fenghou.site/tags/vue/"}]},{"title":"根据图片色调生成渐变背景","date":"2017-12-01T02:00:00.000Z","path":"2017/12/01/2017-12-01-canvas-image-node-color/","text":"有这么个需求有个容器 容器里面有个图片容器的背景需要根据图片的颜色渐变显示让整个风格不突兀 What Color首先很明确 怎么提取图片中的颜色canvas getImageData 可以获取图片中每个像素点的rgb值通过一系列的 计算可以获取到 出现最多的几种颜色此处省略好多字(代码下次补) And Then假设我们拿到颜色了 结束 但是如果没拿到呢 总所周知 canvas 的getImageData 是不能处理跨域图片当然如果图片的服务器 指定了 Access-Control-Allow-Origin *那么 通过 img.crossOrigin = “Anonymous” 就可以获取 但是我的项目 需要的图片是某云音乐里拉出来图片妥妥的跨域好在 我的项目是通过node部署的所以我是通过node中间转了一层由node服务去请求 图片 然后再 返给前端这样就不存在跨域的 行为了","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"},{"name":"canvas","slug":"canvas","permalink":"//blog.fenghou.site/tags/canvas/"}]},{"title":"Git命令行","date":"2017-11-21T05:33:37.000Z","path":"2017/11/21/2017-11-21-git-cmd/","text":"Git命令行操作-收纳 About 分支1234567891011121314151617git checkout &lt;branchName&gt; 切换分支git branch &lt;branchName&gt; 新建分支git branch -a 本地分支列表git branch -r 远程分支列表git branch -D &lt;branchName&gt; 删除本地分支Git v1.7.0 之后git push origin --delete &lt;branchName&gt; 删除远程分支之前git push origin :&lt;branchName&gt;git merge &lt;branchName&gt; 合并分支到当前分支 About 版本123456789git stash 推入缓存区git stash pop 从缓存列表中获取 并且在缓存中删除这条数据git log -3 查看最近三次commitgit log --pretty=oneline commit单行显示git reset --hard &lt;版本号&gt;git push -f origin master 强制提交git reflog 333333 modify pull 3222222 modify pull 2111111 modify pull 1已经push的版本号有3个如果现在 git reset –hard 222222会回退会222222的版本 提交的时候会提示有commit需要拉取这时强制提交的话版本记录会变成 l 2222222 modify pul111111 modify pull 1 本地的commit回退push之后commit会指向提交的版本 回退前的版本会消失 这时需要找到 之前的版本号git reflog 命令222222 HEAD@{0}: reset: moving to 222222333333 HEAD@{1}: pull origin master: Fast-forward222222 HEAD@{2}: reset: moving to 222222333333 HEAD@{3}: commit: modify pull 3","tags":[{"name":"git","slug":"git","permalink":"//blog.fenghou.site/tags/git/"}]},{"title":"HTML标签语义","date":"2017-11-20T10:09:08.000Z","path":"2017/11/20/2017-11-20-html-tag/","text":"HTML语义化整理块级元素 常见的div p ul行内元素 常见的span a 元素间的嵌套什么是语义化12345678&lt;p&gt; &lt;div&gt;&lt;/div&gt;&lt;/p&gt;&lt;!--会变成--&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;!--h1~h6 p 块级元素内不能再内嵌块级元素--&gt; 行内元素内 原则上不应该内嵌块级元素 但没有强制限制","tags":[{"name":"html","slug":"html","permalink":"//blog.fenghou.site/tags/html/"}]},{"title":"vue-about","date":"2017-11-17T06:30:23.000Z","path":"2017/11/17/2017-11-17-vue-about/","text":"VUE-ABOUT .vue中 scope的实现vue文件可以实现当前文件的css作用域实现手法是通过vue-loader后生成一个随机字符串属性 通过内置css属性选择器实现like that123456789101112131415&lt;template&gt; &lt;div class=\"scope-div\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;style scope&gt; .scope-div&#123; width: 200px; &#125;&lt;/style&gt;&lt;!--打包处理后--&gt;&lt;style&gt; .scope-div[data-v-7af99ee4]&#123; width: 200px; &#125;&lt;/style&gt;&lt;div class=\"scope-div\" data-v-7af99ee4&gt;&lt;/div&gt; VuexVuex 中模块的划分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import mutations from './mutations'import actions from './actions'import ware from './module/wareModule'const store = new Vuex.Store(&#123; state: &#123; viewImageConfig:&#123; isShow:false, url:'' &#125; &#125;, mutations, // 修改store方法 actions, // 调用修改store方法 modules: &#123; ware &#125;,&#125;)//actions.jsexport default &#123; demoAction(&#123;commit&#125;)&#123; &#125;&#125;//ware.jsconst state = &#123; demoWareStore:'345'&#125;const getters = &#123; getDemoWareStore: state =&gt; state.demoWareStore&#125;const actions = &#123; demoWareAction(&#123;commit,state&#125;,rs)&#123; console.log(rs) commit('DEMO_WARE_MUT',rs) &#125;&#125;const mutations = &#123; DEMO_WARE_MUT(state,rs)&#123; console.log(rs) state.demoWareStore = '123' &#125;&#125;export default &#123; state, getters, actions, mutations&#125; vuex 实例会混入vue的实例中通过this.$store而模块中引入的 action mutations getters 都会和全局混合在一起this.$store._actions[demoWareAction,demoAction]而state会根据module分割this.$store.store.viewImageConfigthis.$store.store.ware.demoWareStore Vue中路由 层级的渲染首先Router和route 会混入到vue的实例中去vue-router 提供了 一个 router-view 的组件如果是嵌套的路由 vue-router 是怎么实现对应的显示首先在 在显示 当前组件时 vue-router 会根据当前路由生成一个 已经匹配过的数组12345678910111213141516$route = &#123; path:'/part', matched:[ &#123; path:'', name:'Home', ... &#125;, &#123; path:'/part', name:'Part', ... &#125;, ], ...&#125; 渲染 vue-router 时 会去判断 当前组件的层级然后对应去 这个 matched 中取层级下标对应的值1234567891011121314const route = parent.$routelet depth = 0let inactive = falsewhile (parent &amp;&amp; parent._routerRoot !== parent) &#123; if (parent.$vnode &amp;&amp; parent.$vnode.data.routerView) &#123; depth++ &#125; if (parent._inactive) &#123; inactive = true &#125; parent = parent.$parent &#125; const matched = route.matched[depth] //此时mathed 就是匹配到要渲染的 组件 举例说明路由配置如下1234567891011121314151617const router = new Router(&#123; routes:[ &#123; path: '/', name: 'Home', component: Home, children: [ &#123; path: '/part', name: 'Part', component: Part, &#125; ] &#125; ]&#125;) 123456789101112131415161718192021222324&lt;!--App--&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;!--Home--&gt;&lt;template&gt; &lt;div v-if=\"readyMenu\"&gt; &lt;v-head /&gt; &lt;v-menu&gt;&lt;/v-menu&gt; &lt;div class=\"content-box\"&gt; &lt;transition name=\"move\" mode=\"out-in\"&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; &lt;/div&gt; &lt;v-load /&gt; &lt;v-toast /&gt; &lt;/div&gt;&lt;/template&gt;&lt;!--Part--&gt;&lt;template&gt; &lt;div&gt; Part &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536// 路由为 localhost:8010/#/时 $route = &#123; path:'/', matched:[ &#123; path:'', name:'Home', ... &#125; ], ...&#125;// 此时depth = 0const matched = route.matched[depth]// 路由为 localhost:8010/#/part时 $route = &#123; path:'/part', matched:[ &#123; path:'', name:'Home', ... &#125;, &#123; path:'', name:'Part', ... &#125; ], ...&#125;//先渲染Home之后depth = 1const matched = route.matched[depth]","tags":[{"name":"vue","slug":"vue","permalink":"//blog.fenghou.site/tags/vue/"}]},{"title":"node-webpack","date":"2017-11-16T03:29:13.000Z","path":"2017/11/16/2017-11-16-webpack-rules/","text":"webpack - 笔记 CSS样式表webpack可以做的预处理语言转换 (scss-loader等)提取样式表文件 (extract-text-webpack-plugin)补全浏览器前缀 (postcss-loader autoprefixer)打包压缩 webpack 加载器的加载规则12345678910111213141516171819model:&#123; rules:[ &#123; test:'', //多个loader建议配置 use:[ &#123; loader:'', options:&#123;&#125; &#125;, &#123;&#125; ] &#125;, &#123; test:'',//单个loader建议配置 loader:'', options:&#123;&#125; &#125; ]&#125; 对于要抽离出来的css文件的配置123456789101112131415161718192021var ExtractTextPlugin = require('extract-text-webpack-plugin')rules:[ &#123; test:/\\.css$/, use: ExtractTextPlugin.extract('css-loader','style-loader') &#125;, &#123; test:/\\.css$/, use: ExtractTextPlugin.extract(&#123; use:[ &#123; loader:'css-loader', options:&#123; sourceMap:true &#125; &#125; ] &#125;) &#125;, ] 使用postcss-loader时需要配置 .postcssrc.js安装 autoprefixer 并且指定兼容(package.json中配置)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//.postcssrc.jsmodule.exports = &#123; \"plugins\": &#123; // to edit target browsers: use \"browserlist\" field in package.json \"autoprefixer\": &#123;&#125; &#125;&#125;//package.json\"browserslist\": [ \"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\" ]/*last 2 versions: the last 2 versions for each browser.最后2个版本：每个浏览器的最后2个版本。last 2 Chrome versions: the last 2 versions of Chrome browser.最后2个chrome版本：chrome浏览器的最后2个版本。&gt; 5%: versions selected by global usage statistics. &gt;=, &lt; and &lt;= work too.&gt; 5％：由全局使用统计选择的版本。&gt; =，&lt;和&lt;=也工作。&gt; 5% in US: uses USA usage statistics. It accepts two-letter country code.&gt; 5% in US: 使用美国使用统计。它接受两个字母的国家代码。&gt; 5% in alt-AS: uses Asia region usage statistics. List of all region codes can be found at caniuse-lite/data/regions.&gt; 5% in alt-AS: 使用亚洲地区使用情况统计。所有地区代码清单可在caniuse-lite / data / regions中找到。&gt; 5% in my stats: uses custom usage data.&gt; 5% in my stats: 使用自定义使用数据extends browserslist-config-mycompany: take queries from browserslist-config-mycompany npm package.扩展browserslist-config-mycompany: 从browserslist-config-mycompany npm包中获取查询。ie 6-8: selects an inclusive range of versions.ie 6-8: 选择包含范围的版本Firefox &gt; 20: versions of Firefox newer than 20. &gt;=, &lt; and &lt;= work too.Firefox &gt; 20: Firefox的版本比20更新。&gt; =，&lt;和&lt;=也可以。iOS 7: the iOS browser version 7 directly.iOS 7: 直接使用ios浏览器版本7Firefox ESR: the latest [Firefox ESR] version.Firefox esr：最新的[firefox esr]版本。unreleased versions or unreleased Chrome versions: alpha and beta versions.未发布的版本或未发布的Chrome版本：alpha和beta版本。last 2 major versions or last 2 iOS major versions: all minor/patch releases of last 2 major versions.最后2个主要版本或最后2个主要版本: 最后2个主要版本的所有次要/补丁版本 since 2015 or last 2 years: all versions released since year 2015 (also since 2015-03 and since 2015-03-10).自2015年或最近2年以来: 自2015年以来发布的所有版本（自2015-03和2015-03-10以来） dead: browsers from last 2 version query, but with less than 0.5% in global usage statistics and without official support or updates for 24 months. Right now it is IE 10, IE_Mob 10, BlackBerry 10, and BlackBerry 7.dead: 来自上次2版本查询的浏览器，但全球使用情况统计信息少于0.5％，并且24个月没有官方支持或更新defaults: Browserslist’s default browsers (&gt; 0.5%, last 2 versions, Firefox ESR, not dead). defaults://默认配置not ie &lt;= 8: exclude browsers selected by previous queries. not ie &lt;= 8: 排除先前查询选择的浏览器 */ 使用 optimize-css-assets-webpack-plugin 插件压缩css可以考虑 将 css-loader 相关的加载处理抽出来处理webpack 说到底就是一份配置文件完全可以自由的拼拆(webpack-merge) extract-text-webpack-plugin抽取样式 请配合 plugins使用抽取样式 请配合 plugins使用抽取样式 请配合 plugins使用 三遍new ExtractTextPlugin(‘style.css’) babel关于es6 babel的转换transform-runtime 转换语法 ES6 的语法转换成ES5的通俗理解为 转换语法糖不转换新增API Map Set。。。includes等如果需要实现 则需要通过引入 babel-polyfill来实现123456789const a = [1,2,3]a.push('5')console.log(a.includes('5'))// 如上代码 会转换成var a = [1, 2, 3];a.push('5');console.log(a.includes('5')); 公共模块抽离webpack抽离公共的模块 name 打包的名称 minChunks: number|Infinity|function(module, count) -&gt; boolean, // 在传入 公共chunk(commons chunk) 之前所需要包含的最少数量的 chunks 。 // 数量必须大于等于2，或者少于等于 chunks的数量 // 传入 Infinity 会马上生成 公共chunk，但里面没有模块。 // 你可以传入一个 function ，以添加定制的逻辑（默认是 chunk 的数量） 并且调用函数时会传入 module 和 count 参数。 module 参数代表每个 chunks 里的模块，这些 chunks 是你通过 name/names 参数传入的 module.context: The directory that stores the file. For example: ‘/my_project/node_modules/example-dependency’ module.resource: The name of the file being processed. For example: ‘/my_project/node_modules/example-dependency/index.js’ count 参数表示 module 被使用的 chunk 数量 可以通过传参minChunks来控制你希望重复出现几次的module 被提取出来打包。也就是说你自己可以控制当一个模块被引入几次可以被打包到共用的chunk中，还可以规定如果这个公共模块小于一个值 minSize，就不被提取出来这些都可以帮助你控制你想要的粒度。当你改的不是公共模块的代码，理论上webpack 打包的时候本来就不会影响其他代码。但是webpack 在使用 CommoChunkPlugin会生成一段 runtime 代码，而哪怕你不改变common 里的代码这个 runtime 仍然是会跟随着打包变化的并且打入你的common 中，所以你的common 的hash 就会开始变化了。但是也有办法，就是独立把生成的runtime 代码抽出来。（manifest）像下面一样，这个是从 vue-cli 中学习而来 123456789101112new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function (module, count) &#123; // any required modules inside node_modules are extracted to vendor return (module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf(path.join(__dirname, '../node_modules')) === 0 ) &#125; &#125;) new webpack.optimize.CommonsChunkPlugin(&#123; name: 'mainfest', chunks: ['vendor'] &#125;) 模块异步加载第一个参数 依赖的文件 第二个参数回调 第三个参数 命名名称12345678910111213output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].[chunkhash].js'), chunkFilename: utils.assetsPath('js/[name].[chunkhash].js') &#125;require.ensure([], require =&gt; &#123; require('../Component/Index') &#125;,'Index')// 传入第三个参数的 js/Index.xxxxxxxx.js// 不传的 js/id.xxxxxxxx.js// 第三个参数相同的会打包到一个js 中 Vue中路由实现123Home = resolve =&gt; require.ensure([],()=&gt;&#123;resolve(require('@/components/common/Home'))&#125;)Home = resolve =&gt; require.ensure([],()=&gt;&#123;resolve(require('@/components/common/Home')),'Home'&#125;)Home = resolve =&gt; require(['@/components/common/Home'], resolve) react中路由实现12345678910const Home = (location, resolve) =&gt; &#123; require.ensure([], require =&gt; &#123; resolve(null, require('../Component/Home').default) &#125;)&#125;const Home = (location, resolve) =&gt; &#123; require.ensure([], require =&gt; &#123; resolve(null, require('../Component/Home').default) &#125;,'Home')&#125; 普通js实现12345678910111213load = ()=&gt;&#123; require.ensure([], require =&gt; &#123; require('@/assets/js/demo') &#125;)&#125;load()//demo.js console.log('I load')function V()&#123; console.log('I will V')&#125;V() devServer关于webpack的devServer如下配置12345678910111213devServer:&#123; contentBase:path.resolve(__dirname,'../static'), publicPath:'/', port:8888, open:true, host:'192.168.0.246', hot:true, &#125;/** Project is running at http://192.168.0.246:8888/* webpack output is served from /* Content not from webpack is served from E:\\github\\firework\\static* */ contentBase 指定的是 页面中引用的不是通过webpack打包的文件的 获取目录publicPath 指定的是 页面中引用的是通过webpack打包的文件的获取目录 hot 指的是是否开启热重载需要搭配 new webpack.HotModuleReplacementPlugin() 插件一起使用","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"},{"name":"webpack","slug":"webpack","permalink":"//blog.fenghou.site/tags/webpack/"}]},{"title":"node-sms-boom","date":"2017-11-13T01:27:44.000Z","path":"2017/11/13/2017-11-13-node-sms-boom/","text":"利用puppeteer进行短信轰炸 puppeteer安装ERROR: Failed to download Chromium r508693! Set “PUPPETEER_SKIP_CHROMIUM_DOWNLOAD” env variable to skip download. 原因 安装 puppeteer 时会去下载 chromium（实验版chrome），但是由于网络的原因，下载失败了 解决win npm config set PUPPETEER_SKIP_CHROMIUM_DOWNLOAD truelinux export PUPPETEER_SKIP_CHROMIUM_DOWNLOAD = true linux centos 7.3 下载chromium 失败 待解决 http://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html从这里下载 http://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Linux_x64/515411//admin/fenghou/www/chrome/chrome-linux/chrome","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"}]},{"title":"node-npm","date":"2017-11-08T08:25:10.000Z","path":"2017/11/08/2017-11-08-node-npm/","text":"NPM - 笔记 切换npm源https://registry.npmjs.org/npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/distnpm config delete registrynpm config delete disturlnpm config listnpm config edit sass安装出错SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install node-sass –save-dev 更新node版本window 官网下载.msi文件 安装覆盖老版本 npm 版本npm版本5.5.1会生成 package-lock.json 锁定当前安装的 package 包rm -rf package-lock.json管理员身份 npm install 还有有问题 没解决 版本回退到5之前 npm publish登录 npm addUser源切换 https://registry.npmjs.org/不然会 no_perms Private mode enable, only admin can publish this module 关于–save-devpublish上去的包中的devDependencies中依赖的包 下载时不会被安装 关于包的安装依赖以及删除npm view package versions 查看所有版本npm view package version 查看最新版本 npm ls package 查看安装的版本 npm i package@version 安装指定版本 npm i package@latesd 安装最新版本 package.json 的版本依赖x.y.z x:主版本号 y:次版本号 z:补丁版本号以下用 大 中 小 代替~ 会匹配最新的小版本依赖包，比如~1.2.3会匹配所有1.2.z版本，但是不包括1.3.0^ 会匹配最新的中版本依赖包，比如^1.2.3会匹配所有1.y.z的包，包括1.3.0，但是不包括2.0.0 会匹配最新的版本vue:’2.5.2’ 安装 2.5.2版本vue:’~2.5.2’ 安装最近更新的小版本 2.5.z版本（z&gt;=3）vue:’^2.5.2’ 安装最近跟新的中版本 2.y.z版本 (y&gt;=5)(y = 5 ? z &gt;= 2 : z)vue:’*’ 安装最新版本 npm update package 依赖～ ^版本规则webpack:’3.7.0’ npm update webpack 不更新webpack:’~3.7.0’ npm update webpack 3.7.0 —&gt; 3.7.1 小版本最新版本webpack:’^3.7.0’ npm update webpack 3.7.0 —&gt; 3.11.0 中版本最新版本webpack:’*’ npm update webpack 最新版本 npm uninstall package 删除依赖包 npm cache clean 清除缓存","tags":[]},{"title":"Css-Specification","date":"2017-11-07T07:08:16.000Z","path":"2017/11/07/2017-11-07-css-Specification/","text":"css规范笔记css规范文档12345678910h1 &#123; font-weight: bold; font-size: 12pt; line-height: 14pt; font-family: Helvetica; font-variant: normal; font-style: normal;&#125;h1 &#123; font: bold 12pt/14pt Helvetica &#125;","tags":[{"name":"css","slug":"css","permalink":"//blog.fenghou.site/tags/css/"}]},{"title":"css-Box-Model","date":"2017-11-07T01:56:43.000Z","path":"2017/11/07/2017-11-07-css-box-model/","text":"css-box 总结 盒模型的计算盒模型 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式 盒模型 宽高的计算box-sizing 属性可以通俗的理解为 给box设置的宽高从哪里开始计算盒模型的真实宽高 = border-box + padding-box + content-box box-sizing: content-box(标准盒模型) 表示设置的宽高是 content-box的宽高 那渲染在页面上真实的宽高还要加上 padding-box 和 border-boxwidth(真实) = width(content-box设置的width) + padding-box + border-box box-sizing: border-box(IE盒模型) 表示设置的宽高是 border-box的宽高 那渲染在页面上真实的宽高就是 设置的宽高width(真实) = width(设置的width) box-sizing: inherit 从父元素继承 BFC &amp;&amp; IFCBFC 块级格式化上下文可以通过构建BFC 解决margin 重合 清除浮动float的值不为noneposition的值不为static或者relativedisplay的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个overflow的值不为visible IFC 内联格式化上下文默认对齐方式 vertical-align:baseline 所以同时存在有内容的内联元素和没内容的内联元素 有内容的 会往下掉vertical-align:top 背景的起始background-clip 表示背景在盒模型中显示的位置border-box 从border-box开始有背景padding-box 从padding-box开始有背景content-box 从content-box开始有背景background-origin 表示背景在盒模型中开始渲染的位置border-box 背景从border-box 处开始渲染padding-box 背景从padding-box 处开始渲染content-box 背景从content-box 处开始渲染 background-position 表示从这张背景图片的什么位置 开始渲染在 元素背景上background-position:X% Y%(百分比值) 表示会把图片 横向X% 纵向的Y% 的点与 元素 横向X% 纵向的Y%点对齐background-position:Xpx Ypx(数值) 表示图片距离背景起始绘制点的距离 background-position: /","tags":[{"name":"css","slug":"css","permalink":"//blog.fenghou.site/tags/css/"}]},{"title":"从源码看webpack","date":"2017-10-25T02:21:01.000Z","path":"2017/10/25/2017-10-25-webpack-source-code/","text":"研究研究 源码总结总结 心得 配置webpack 这边的配置主要还是根据项目来灵活的配置大的项目根据运行环境来区分 开发 测试 线上本地的调试通过node来搭建小的项目可以通过命令行的形式直接敲命令 devServer devServer可以用来配置热加载 请求代理 静态资源访问等12345678// 可以配置在webpack配置对象里的devServer里面devServer: &#123; hot:true, contentBase:path.resolve(__dirname,'../'), publicPath:path.resolve(__dirname,'../assets/') &#125;// 或者在调用的时候传入var server = new WebpackDevServer(compiler,devServer) 通过 webpack-dev-server的源码可以看到热加载是通过 sockjs来实现的 123456789101112131415161718//实现原理 server.jsvar sockjs_opts = &#123;sockjs_url: \"http://cdn.jsdelivr.net/sockjs/1.0.1/sockjs.min.js\"&#125;;var sockjs = sockjs.createServer(sockjs_opts);sockjs.on('connection', function(conn) &#123; conn.on('data', function(message) &#123; conn.write(message); // 向客户端 发送 &#125;)&#125;);var app = express(); var server = http.createServer(app);sockjs.installHandlers(server, &#123;prefix:'/demo'&#125;);// client.jsvar sockjs_url = '/demo';var sockjs = new SockJS(sockjs_url);sockjs.onmessage = function(e) &#123; // e.data window.location.reload()&#125;; 这也是为什么 要在 entry中将 webpack-dev-server/client?http://localhost:8080/引进来的原因 devServer的proxy是依赖http-proxy-middleware实现 而 devServer中的publicPath指定的是根据 dev-server服务请求中的静态资源的目录 devtool source-map 几种模式 主要还是解决 多模块文件的调试和明确报错提示 命令行webpack 的启动可以通过命令行调用 webpack --w --config --progress --color 通过这个命令可以启动webpack 监听 配置文件config路径 以及进程和颜色具体的实现过程 输入命令行后会 执行 node_modules/.bin/webpack 这个脚本然后会启动 node_modules/webpack/bin/webpack.js通过 yargs 这个node插件可以获取 在命令行中输入的参数 123456789101112131415161718192021222324252627282930//config-yargs.jsmodule.exports = function(yargs) &#123; yargs .help(\"help\") .alias(\"help\", \"h\") .version() .alias(\"version\", \"v\") .options(&#123; \"watch\": &#123; type: \"boolean\", alias: \"w\", describe: \"Watch the filesystem for changes\", group: BASIC_GROUP &#125;, ... &#125;)&#125;//webpack.jsvar options = require(\"./convert-argv\")(yargs, argv);//通过convert-argv.js 进行加工 返回一个混合配置文件的最终 optionsprocessOptions(options);function processOptions(options)&#123; var webpack = require(\"../lib/webpack.js\"); var compiler = webpack(options); if(options.watch) &#123; compiler.watch(watchOptions, compilerCallback); &#125; else compiler.run(compilerCallback);&#125; node通过vue-cli构建的vue项目 开发是依赖 webpack他是通过自己启动服务 将webpack作为中间件来运行然后通过各种插件实现 代理 热加载等功能通过express 来实现热加载 是依赖 webpack-hot-middleware实现通过webpack构建的实例是继承tapable的tapable 用于事件发布执行的插件通过 plugin注册事件通过applyPlugin等响应事件 1234567891011121314151617181920212223var webpackConfig = require('./webpack.config')var compiler = webpack(webpackConfig)var hotMiddleware = require('webpack-hot-middleware')(compiler,&#123; log:()=&gt;&#123;&#125;&#125;)//通过 html-webpack-plugin-after-emit 来触发 行为compiler.plugin('compilation', function (compilation) &#123; compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) &#123; console.log('------------') hotMiddleware.publish(&#123; action: 'reload' &#125;) cb() &#125;)&#125;)//clientrequire('eventsource-polyfill')var hotClient = require('webpack-hot-middleware/client?noInfo=true&amp;reload=true')// 响应 刷新页面hotClient.subscribe(function (event) &#123; if (event.action === 'reload') &#123; window.location.reload() &#125;&#125;) 通过webpack的源码可以看到 webpack启动时 根据watch参数和回调来判断是否开启监听12345678910var mergeConfig = merge(webpackConfig,&#123; watch:true&#125;)webpack(mergeConfig) //监听webpack(mergeConfig,function()&#123;&#125;) //监听// 没有 回调 没有watch 执行watchcompiler = webpack(mergeConfig)compiler.watch() 原理可以看到webpack的流程都是基于tapable订阅和发布机制来实现而tapable的设计思想 是面向切面的编程设计aop1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//例子 统计A方法的调用次数// 直接写在A方法里 耦合了A的业务逻辑// 通过回调参数解决 增加后期维护难度function A()&#123; console.log('执行A的逻辑') &#125;function B()&#123; console.log('执行B的逻辑') &#125;//AOPFunction.prototype.logCount = function(fn)&#123; var _self = this return function()&#123; fn.apply(this,arguments) return _self.apply(this,arguments) &#125;&#125;var A_log = A.logCount(B)A_log()// 业务解耦 面向切面进行拓展`tapable`就是一句这种思想进行设计function ComP()&#123; this._plugins = &#123;&#125;&#125;ComP.prototype.plugin = function()&#123;&#125;ComP.prototype.applyPlugins = function()&#123;&#125;//webpack 的plugins 提供一个 apply 方法作为插件的入口//并在这个方法中 发布时间//在webpack构建时 调用apply方法function WebP(options)&#123; var compiler = new ComP(); compiler.apply.apply(compiler,options.plugins) compiler.run();&#125;// options.plugins 是个数组 这里使用apply的技巧 第二个参数接受数组 在调用的方法里转成列表ComP.prototype.apply = function()&#123; for(var i = 0; i &lt; arguments.length; i++) &#123; arguments[i].apply(this); &#125;&#125;function plugDemo()&#123;&#125;//plugDemo 订阅emit事件 当webpack的构建流程到emit时执行plugDemo.prototype.apply = function(compiler)&#123; compiler.plugin(\"emit\", (callback) =&gt; &#123; setTimeout(function()&#123; console.log('第一次执行') callback() &#125;,1500) &#125;);&#125;var _obj = &#123; plugins:[ new plugDemo() ],&#125;WebP(_obj)","tags":[{"name":"webpack","slug":"webpack","permalink":"//blog.fenghou.site/tags/webpack/"}]},{"title":"canvas 图片裁剪","date":"2017-10-10T08:50:07.000Z","path":"2017/10/10/2017-10-10-canvas-clip-image/","text":"心血来潮想实现一个图片编辑器 需求实现图片根据选择区域裁剪选择区域大小可以拖动改变 实现思路 裁切drawImage(image,x,y,w,h,_x,_y,_w,_h) x 裁切图片中x坐标y 裁切图片中y坐标w 裁切图片中的宽h 裁切图片中的高_x canvas中显示的x坐标_y canvas中显示的y坐标_w canvas中显示的宽_h canvas中显示的高 所以思路是 在图片上显示一个选择区域 可以拖动 获取相对于图片的位置 在canvas中加载图片 拉伸大小 宽度拉伸 可以通过在选择区域中绝对定位一个元素来模拟边框 监听它上面的move事件来处理这里注意事件的执行机制事件的执行机制分为冒泡型和捕获型冒泡型事件 从当前节点开始执行 一路传递给绑定当前事件的父元素 知道根节点为止捕获型事件 从最外层绑定该事件的元素往子元素传递addEventListener第三个参数默认false true表示冒泡事件 false表示捕获事件可以通过event.stopPropagation()来阻止事件的冒泡event.preventDefault()这个是用来阻止事件的默认操作 旋转 通过控制Img旋转来控制一开始的想法是通过旋转选择区域来选取，但这样选择区域的获取图片数据会很繁琐而且意义不大旋转通过样式transform:rotate(0deg)在js获取样式时 要通过getComputedStyle这个API来获取style获取的是元素style属性中的样式 可读可写所以通过style设置的元素回出现在元素的style属性中getComputedStyle 获取的是最终作用在节点上的样式 只读currentStyle IE自娱自乐产物 语法跟style类似 功能跟 getComputedStyle类似 12345var clipV = window.getComputedStyle(clip,null)var clipTrans = clip.getPropertyValue('transform')// or var clipTrans = clip.transform// 这时候获取的是一个二维矩阵// 型如 matrix(20, 10, 10, 10, 0, 0) 关于matrix matrix(a,b,c,d,e,f)e,f 控制 x, y轴的偏移位置 a,b,c,d 控制旋转 旋转的角度(θ) matrix(cosθ,sinθ,-sinθ,cosθ,0,0) 角度计算 angle = Math.round(Math.atan2(b, a) (180 / Math.PI))缩放计算有旋转时x轴缩放 scaleX = Math.sqrt(a a + b b)y轴缩放 scaleY = Math.sqrt(c c + d * d)无旋转时x轴缩放 scaleX = ay轴缩放 scaleY = b matrix(1,tan(θy),tan(θx),1,0,0)拉伸计算x轴拉伸角度 skewX = Math.atan(c)y轴拉伸角度 skewX = Math.atan(b) css动画界三巨头 transform transitions animation举个例子王者农药 新出一个英雄 浪一技能(transition) 标记敌人 设置过度效果二技能(transform) 命中敌人 变化敌人三技能(animation) 命中目标 设置过度效果 变化敌人并带有过度效果(只产生效果)被动(style.) 二技能命中标记一技能的目标 会使二技能有过度效果；普攻第三次 变化敌人 硝烟弥漫的峡谷中 刚刚结束一场战斗 我方四名英雄死于敌方小兵之手这时。。。我方浪出现在中路 对线敌方诸葛亮 李白 红蓝双buff在手一技能 成功标记诸葛亮(李白逃脱) transition:transform 100ms linear反手 一个二技能 transform:translate(0px,100px)(移动到我方中路一塔下) 命中对方诸葛亮 和 李白李白唰一下出现在我方塔下(效果如闪现) 诸葛亮也慢跑到塔下…浪 double kill对面鲁班 苏烈过来支援 反手一个 大招 animation:scale_leg(腿缩短至十分之一) 100ms 4 alternate linear只见 鲁班 苏烈一会变高 一会变矮 …浪 quadra kill木兰从草丛杀出 一技能 怼脸上 transition:display 100ms linear 蓝条空了普攻 普攻 丝血 闪现接普攻 触发被动缓缓的消失吧，木兰！！ document.querySelector(‘花木兰’).style.display = ‘none’浪 penta kill 总结css相关的还是要经常温故温故 不然真的容易忘了 参考获取元素CSS值之getComputedStyle方法熟悉理解CSS3 transform中的Matrix(矩阵)","tags":[{"name":"canvas","slug":"canvas","permalink":"//blog.fenghou.site/tags/canvas/"}]},{"title":"Js类型","date":"2017-09-19T02:02:58.000Z","path":"2017/09/19/2017-09-19-js-input-check/","text":"总结一些输入框中类型的判断 列举几个常用判断为空的情况以下等于(==)不等于(!=) 对象 不等于 等于 undefined ‘’ false 0 [] null null ‘’ false 0 [] undefined ‘’ null undefined false 0 [] 0 null undefined false ‘’ [] false null undefined 0 ‘’ [] [] null undefined false 0 ‘’ 12345678910111213var a = undefined || null || '' || 0 || falseif(!a)&#123; console.log('会执行')&#125;var b = a || 'test'console.log(b) // test//判断是否输入了//转成string 一来replace可以调用 而来 如果数据是一开始写入的0var _s = (inputVal+'').replace(/(^\\s*)|(\\s*$)/g,'')if(_s)&#123; //输入有效&#125;","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"Node-Session","date":"2017-08-20T02:20:32.000Z","path":"2017/08/20/2017-08-20-node-session-cookie/","text":"Node中使用Session server.js 1234567891011121314var bodyParser = require('body-parser');var session = require('express-session');var app = require('express')()var router = require('./models/user')app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(session(&#123; name:'SESSION', secret: 'recommand 128 bytes random string', cookie: &#123; maxAge: 60 * 60 * 1000 &#125;&#125;));app.use('/', router);app.listen(4000) ./models/user.js 1234567var express = require('express');var router = express.Router();var userControl = require('../controller/user')router.post('/user/login',userControl.login)router.post('/user/check',userControl.check)router.post('/user/create',userControl.createUser)module.exports = router; ../controller/user.js 12345678910111213var userService = require('../service/user')module.exports = &#123; login: function(req,res)&#123; userService.login(req,res) &#125;, check: function(req,res)&#123; userService.check(req,res) &#125;, createUser: function (req,res) &#123; userService.createUser(req,res) &#125;&#125; ../service/user.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var User = require('./../dataBase/user')module.exports = &#123; login:function(req,res)&#123; const name = req.body.name, pwd = req.body.pwd var user = new User(&#123; name:name, password:pwd &#125;) user.findUser(user.name,user.password) .then((rs)=&gt;&#123; let _data = &#123;&#125; if(rs.length)&#123; _data = &#123; code:200, data:rs[0] &#125; req.session.user = rs[0].id; &#125; else &#123; _data = &#123; code:500, msg:'用户名或密码不正确', &#125; &#125; res.send(_data) &#125;) &#125;, check:function(req,res)&#123; let _data = &#123;&#125; if(req.session.user)&#123; _data = &#123; code:200, data:true &#125; &#125; else &#123; _data = &#123; code:200, data:false &#125; &#125; res.send(_data) &#125;, createUser:function(req,res)&#123; const name = req.body.name, pwd = req.body.pwd var user = new User(&#123; name:name, password:pwd &#125;) user.createUser(user.name,user.password) .then((rs)=&gt;&#123; let _data = &#123;&#125; _data = &#123; code:200, data:rs[0] &#125; req.session.user = rs[0].id; res.send(_data) &#125;) &#125;,&#125;","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"},{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"Linux 使用 Mysql","date":"2017-08-18T02:20:08.000Z","path":"2017/08/18/2017-08-18-linux-mysql/","text":"Linux 中使用 Mysql记录 安装关于安装 完全按着教程走 没有什么大问题具体的教程 按照 安装的 mysql版本 自行搜索linux mysqlx.x.x 安装 操作基本都是数据库原理里面有交的学校学的时候一开始还用过命令行后来都是用可视化工具了全忘光了 mysql -uroot -p //输入密码后 操作mysqlshow databases; //查看库create database 库名; //新建数据库use 库名; // 打开数据库show tables; // 显示表describe 表名; // 查看表结构drop database 库名; //删除库drop table 表名; //删除表//新建库的话 直接导入来的快一点mysql -u用户名 -p密码 数据库名 &lt; 数据库名.sql 导入 不涉及复杂操作的话 这些命令基本够用了 参考最全的mysql 5.7.13 安装配置方法图文教程(linux) 强烈推荐!","tags":[{"name":"linux","slug":"linux","permalink":"//blog.fenghou.site/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"//blog.fenghou.site/tags/mysql/"}]},{"title":"浏览器中js事件运行机制","date":"2017-08-08T08:28:27.000Z","path":"2017/08/08/2017-08-08-js-event-loop/","text":"总结一下 浏览器中js事件运行机制起因是女票今天问我一个问题问题如下 alert引起的争论123456789101112var count = 0, domProcess = document.querySelector('#process'), inter = nullinter = setInterval(function()&#123; if(count == 100)&#123; domProcess.innerText = count+'%' console.log(count) alert('加载完成') clearInterval(inter) &#125;&#125;,100)//弹框时 为什么页面上process显示的是99%？ 因为前段时间了解过Event-Loop的机制 知道怎么去解决它但是要跟女票讲清楚 还是得在总结总结 毕竟自己也是了解的不深 单线程 &amp;&amp; 任务队列 &amp;&amp; Event-Loop 图片来自Philip Roberts的演讲《Help, I’m stuck in an event-loop》Help, I’m stuck in an event-loop优酷地址 首先Js是单线程的 异步是浏览器的事(宿主环境)主线程运行的时候 产生堆(heap)和栈(stack)主线程将运行中碰到的事件推入 执行栈中 开始执行执行结束后 弹出执行栈 推入下一个事件当执行到webAPI时 会将它当做任务源(相当于是分发任务)来执行 并且弹出这时候会产生一个待执行的任务当这个任务满足执行条件时 会进入到任务队列当中当执行栈 为空时 主线程会不断的去调取任务队列中任务 推入 执行栈中执行 这个运行机制就是 Event-Loop而任务队列 可以分为 宏任务队列(macro-task) 和 微任务队列(micro-task)当执行栈为空时 主线程会先去micro-task中调取任务 micro-task为空时才会去 macro-task调取任务执行 触发任务的webAPIDOM(DOCUMENT),AJAX,setTimeOut,setInterval,Promise,process.nextTick,setImmediate其中 加入宏队列中任务 DOM(DOCUMENT),AJAX,setTimeOut,setInterval,setImmediate加入微任务队列中的任务 Promise,process.nextTick 真相所以 上面的js在执行中遇到 document.querySelector(&#39;#process&#39;).innerText = count+&#39;%&#39;推入执行栈 由于是DOM操作判定为任务源 推出执行栈满足执行条件 加入到 宏任务队列遇到 console.log(count)推入执行栈 控制台输出 100 推出执行栈遇到 alert(&#39;加载完成&#39;)推入执行栈 开始执行 主线程挂起 等待弹框确认弹窗确认后 推出执行栈遇到 clearInterval(inter)推入执行栈 执行 推出执行栈此时执行栈为空 开始调用 任务队列微任务队列为空 直接调用宏任务队列将 document.querySelector(&#39;#process&#39;).innerText = count+&#39;%&#39; dom操作分发的执行任务推入执行栈渲染页面数据 推出执行栈 所以要解决这个问题 只需要加个setTimeout就能解决问题123setTimeout(function()&#123; alert('加载完成') &#125;,0) 这里有个问题就是 碰到这个webAPI时 并不是把 这些webAPI推入任务队列在执行栈中 这些webAPI还是立即执行的 是把它分发的任务 推入任务队列1234567//譬如setTimeout(function()&#123; console.log('log')&#125;,1000)//setTimeOut 会立即进入执行栈 并且执行//它的第一个参数就是他要分发的任务 会在满足它的分发条件后进入任务队列 // 上例就是1000ms后进入任务队列 再看下面的两个例子123456789101112131415161718192021222324252627282930313233//demo 1setTimeout(function A() &#123; setTimeout(function B()&#123;console.log(8);&#125;,0); console.log(5); Promise.resolve().then(()=&gt;&#123; console.log(7); &#125;) console.log(6)&#125;,0);console.log(1)new Promise(function(reslove)&#123; console.log(2); reslove()&#125;).then(()=&gt;&#123; console.log(4)&#125;)console.log(3)//demo 2function A(x)&#123; setTimeout(function()&#123; console.log(2.2+x) &#125;,0) Promise.resolve().then(()=&gt;&#123; console.log(2.1+x); &#125;) console.log(1+x)&#125;function B()&#123; A('B')&#125;A('A')B() 联系上面的分析第一题的输出 应该是 1 2 3 4 5 6 7 8 第二题的输出 应该是 1A 1B 2.1A 2.1B 2.2A 2.2B 写在一块输出 应该是 1 2 1A 1B 3 4 2.1A 2.1B 5 6 7 2.2A 2.2B 8 参考文章js的单线程和异步JavaScript 运行机制详解：再谈Event Loop前端基础进阶（十二）：深入核心，详解事件循环机制","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"Js异步编程","date":"2017-08-02T02:19:25.000Z","path":"2017/08/02/2017-08-02-js-promise/","text":"异步 总结 promise通过简易实现 promise 了解原理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&#123; const PENDING = 'PENDING' const FULFILLED = 'FULFILLED' const REJECTED = Symbol(); function TP(fn)&#123; let state = PENDING let value = null let handel = [] function fulfill(result)&#123; state = FULFILLED value = result handel.forEach(next) &#125; function resolve(result,idx)&#123; let then = result &amp;&amp; result.then &amp;&amp; typeof result.then == 'function' ? result.then : null; // let then = typeof result if (then) &#123; then.bind(result)(resolve) return &#125; fulfill(result) // console.log(result) // console.log('resolve~~~',idx) // fulfill(result) &#125; function next(&#123;onFulfill&#125;,idx)&#123; // console.log('next~~~',idx) switch (state)&#123; case FULFILLED: onFulfill &amp;&amp; onFulfill(value) break case PENDING: handel.push(&#123;onFulfill&#125;) break &#125; &#125; this.then = function(onFulfill,idx)&#123; return new TP((resolve)=&gt;&#123; // console.log('then~~~',idx) next(&#123; onFulfill:(val)=&gt;&#123; resolve(onFulfill(val),idx) &#125; &#125;,idx) &#125;) &#125; fn(resolve) &#125; new TP((resolve)=&gt;&#123; // console.log('TP-1') setTimeout(function()&#123; resolve('TP-Resolve1',0) &#125;,2000) &#125;).then((s)=&gt;&#123; console.log('TP-1',s) return new TP((resolve)=&gt;&#123; setTimeout(function()&#123; resolve('TP-Resolve2',0) &#125;,2000) &#125;) &#125;,1).then((s)=&gt;&#123; console.log('TP-2',s) &#125;,2).then(()=&gt;&#123; console.log('---END---') &#125;)&#125; 可以看到 promise 回调是通过调用 promise中的 rosolve去触发回调函数的关于promise状态的改变 只会触发一次 由pedding 变为 resolve 或者 reject12345const start = new Promise((reslove,reject)=&gt;&#123; reslove() reject()&#125;)//即只会执行 reslove 关于异常的捕获 在声明时的异常可以在 reject或者catch中捕获而在then中的异常只能在catch中捕获12345678910const start = new Promise((reslove)=&gt;&#123; throw new Error('我能在Reject中和catch中捕获')&#125;)start.then(()=&gt;&#123; throw new Error('我能在catch中捕获')&#125;,()=&gt;&#123; console.log('我只能捕获new Promise()中的异常')&#125;).catch(()=&gt;&#123; console.log('我能捕获所有异常 如果在reject中捕获了 那我就不捕获了') &#125;) Promise的嵌套 then可以返回的个promise对象支持链式回调12345678910111213141516171819const A = new Promise((resolve)=&gt;&#123; resolve('A')&#125;)const B = new Promise((resolve)=&gt;&#123; resolve('B')&#125;)A.then((rs)=&gt;&#123; console.log(rs) return B&#125;).then((rs)=&gt;&#123; console.log(rs)&#125;)//而不是A.then((rs)=&gt;&#123; console.log(rs) B.then((rs)=&gt;&#123; console.log(rs) &#125;)&#125;) generator1234567891011121314function* genT(arr)&#123; for(let i = 0,_len = arr.length;i&lt;_len;i++)&#123; if(typeof arr[i] === 'number')&#123; yield arr[i] &#125; else &#123; yield* genT(arr[i]) &#125; &#125;&#125;let _arr = [1,2,[3,4]]for(let g of genT(_arr))&#123; console.log(g)&#125; async await可以理解为generator 的语法糖实现过程将generator 的表述移到语法内部实现(await)async函数返回一个 Promise 对象，可以使用then方法添加回调函数await 后面一般跟promise 如果不是的话会执行promise.reslove()await 只能作用在 async方法中 譬如1234567new Promise().then(()=&gt;&#123; await start()&#125;)[].forEach(()=&gt;&#123; await start()&#125;)//都会报错 await 返回的应该是 一个promise.resolve()中返回的数据 1234567891011121314const awaitLoad = ()=&gt; new Promise((reslove)=&gt;&#123; var arr = [1,2,3,4,5] reslove(arr)&#125;)const start = async ()=&gt;&#123; var load = await awaitLoad() console.log(load) //[1,2,3,4,5] return load&#125;start().then((rs)=&gt;&#123; console.log(rs) //[1,2,3,4,5]&#125;) 关于异常返回从处理如果 await 后面的promise异常执行了reject 那么 后面的命令不再执行因此要把问题抛出来12345678910111213const start = async ()=&gt;&#123; //一种写法 try &#123; await fn() &#125; catch(err)&#123; console.log(err) &#125; //第二种 await fn().catch((err)=&gt;&#123; console.log(err) &#125;) &#125; 避免async/await 地狱promise 有一个好玩的特性，你可以在一行代码中得到一个 promise 对象，在另一行代码中得到这个 promise 的执行结果。这是逃离 async/await 地狱的关键。12345678910111213141516async function init()&#123; const pizzaData = await getPizzaData() const drinkData = await getDrinkData() const chosenPizza = choosePizza() const chosenDrink = chooseDrink() await addPizzaToCart(chosenPizza) await addDrinkTOCart(chosenDrink) orderItems()&#125;async function orderItems()&#123; const items = await getCartItems() const noOfItems = items.length for(var i = 0;i&lt;noOfItems;i++)&#123; await sendRequest(items[i]) &#125;&#125; 多余的等待 drinkData 不需要多余的等待 1234567891011121314151617181920212223242526272829async function selectPizza()&#123; const pizzaData = await getPizzaData() const chonsePizza = choosePizza() await addPizzaToCart()&#125;async function selectDrink()&#123; const drinkData = await getDrinkData() const chosenDrink = chooseDrink() await addDrinkToCart()&#125;async function init()&#123; const pizzaPromise = selectPizza() const drinkPromise = selectDrink() await pizzaPromise await drinkPromise orderItems() //或者直接promise.all // Promise.all([selectPizza(),selectDrink()]).then(orderItems)&#125;async function orderItems()&#123; const items = await getCartItems() const noOfItems = items.length let promises = [] for(var i = 0;i&lt;noOfItems;i++)&#123; const orderPromise = sendRequest(items[i]) promises.push(orderPromise) &#125; await Promise.all(promises)&#125; 如何逃离 async/await 地狱","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"Vue事件","date":"2017-07-20T02:18:56.000Z","path":"2017/07/20/2017-07-20-vue-event/","text":"vue 中通过[$on]注册事件[$emit]来触发事件这里来模拟一下它内部的实现机制超简易 初始化Vue123456789function V()&#123; this._init()&#125;function initMixin(v)&#123; v.prototype._init = function()&#123; initEvent(this) &#125;&#125;initMixin(V) 初始化事件123function initEvent(v)&#123; v._events = Object.create(null)&#125; 混合事件123456789101112131415161718192021function eventsMixin(v)&#123; v.prototype.$on = function(name,fn)&#123; this._events[name] = fn &#125; v.prototype.$emit = function(event)&#123; let cbs = this._events[event] let args = toArray(arguments,1) cbs.apply(this,args) &#125;&#125;eventsMixin(V)function toArray (list, start) &#123; start = start || 0 let i = list.length - start const ret = new Array(i) while (i--) &#123; ret[i] = list[i + start] &#125; return ret&#125; 调用12345var v = new V()v.$on('click',function(msg)&#123; console.log(msg)&#125;)v.$emit('click','emit')","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"},{"name":"vue","slug":"vue","permalink":"//blog.fenghou.site/tags/vue/"}]},{"title":"Nginx配置https","date":"2017-07-12T09:40:27.000Z","path":"2017/07/12/2017-07-12-nginx-ssl/","text":"最近刚续费阿里云服务器，肉疼中。。。今天先尝试了下 把http改成https 在这里记录一下 Http和Https关于http和https的差别 就不说了反正不是只多了个s就对了~~ Linux中配置nginx服务器上的项目是通过nginx跑起来的所以主要还是围绕着nginx配置展开 ssl on ;我服务器上nginx配置编译的时候没有把ssl的模块编译进去所以在这里报了缺少ssl指令的错误 so 需要重新编译nginx找到nginx下载目录 没了就就重新下~~ ./configure –with-http_ssl_module很好 如果服务器上面已经安装了openssl 那么基本可以编译通过yum install openssl openssl-devel恩 如果编译的时候没有加载默认的 那么就需要手动配置./configure –with-http_ssl_module –with-openssl=/usr/bin/openssl敲黑板 这么写 编译的时候openssl会去从–with-openssl 那里取所以这里必须是源码目录 不应该安装目录 补充：填了安装目录 编译失败 竟然也找到了编译通过的方法。。修改方法12345678910# vi auto/lib/openssl/confCORE_INCS=\"$CORE_INCS $OPENSSL/openssl/include\"CORE_DEPS=\"$CORE_DEPS $OPENSSL/openssl/include/openssl/ssl.h\"CORE_LIBS=\"$CORE_LIBS $OPENSSL/openssl/lib/libssl.a\"CORE_LIBS=\"$CORE_LIBS $OPENSSL/openssl/lib/libcrypto.a\"改为：CORE_INCS=\"$CORE_INCS $OPENSSL/include\"CORE_DEPS=\"$CORE_DEPS $OPENSSL/include/openssl/ssl.h\"CORE_LIBS=\"$CORE_LIBS $OPENSSL/lib/libssl.a\"CORE_LIBS=\"$CORE_LIBS $OPENSSL/lib/libcrypto.a\" 但是 make 的时候还是会报错 make 打包成功后会在nginx源码目录的objs下生成nginx cp objs/nginx nginx配置目录/sbin拷贝覆盖 即可 然后配置12345678listen 443;ssl on;ssl_certificate /---------------------.pem;ssl_certificate_key /-----------------.key;ssl_session_timeout 5m;ssl_ciphers -----------------------------------------------;ssl_protocols ------------------------;ssl_prefer_server_ciphers on; 配置ssl证书 基本就ok了 sbin/nginx -t nginx: [emerg] getpwnam(“www”) failed 错误的原因是没有创建www这个用户 解决办法 1 在nginx.conf中 把user nobody的注释去掉既可2 /usr/sbin/groupadd -f www /usr/sbin/useradd -g www www 关于证书生成步骤 百度。。。 startSSL 注册申请 生成ctr…捣腾许久 终于配置成功 微信打开失败 不被认证 Symantec Ltd 在阿里云 免费申请ssl证书nginx如果配置是全局https受认证只能是 申请ssl时填写的域名xx.xx 申请xx.xx.xx 不被认证 结论不想搞运维的前端不是个好架构 补充今天下班 被分配到 小黑屋封闭开发没空调。。 nginx安装","tags":[{"name":"nginx","slug":"nginx","permalink":"//blog.fenghou.site/tags/nginx/"},{"name":"https","slug":"https","permalink":"//blog.fenghou.site/tags/https/"}]},{"title":"谈谈我的vue项目","date":"2017-06-25T12:17:35.000Z","path":"2017/06/25/2017-06-25-vue-modules/","text":"Vue相关-整理中","tags":[{"name":"vue","slug":"vue","permalink":"//blog.fenghou.site/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"//blog.fenghou.site/tags/vuex/"}]},{"title":"XX云音乐","date":"2017-06-20T08:30:19.000Z","path":"2017/06/20/2017-06-20-node-simple-netease-cloud-music/","text":"整理中 前端 React数据库 暂时不用服务端 express —&gt; koa 迁移API (网易云Node音乐API)[https://binaryify.github.io/NeteaseCloudMusicApi/#/] redux 中的 dispatch 行为会被所有的reducer 捕获react-redux 的 connect 中 传入的 state 会混合在 组件的 props传入的action 如果有值 会 传入调用 调用dispatch()的方法 如果不传 则会 传入 dispatch方法12345678910111213141516171819202122232425262728293031323334353637383940414243export default connect( (state)=&gt;&#123; let &#123;count&#125; = state.User return &#123; count &#125; &#125;, (dispatch) =&gt; &#123; const type = &#123; type: 'CAT' &#125; return &#123; onIncreaseClick: () =&gt; dispatch(type) &#125; &#125;)(Index)class Index extends React.Component &#123; constructor()&#123; super() &#125; render() &#123; const &#123; count, onIncreaseClick &#125; = this.props return ( &lt;div&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onClick=&#123;onIncreaseClick&#125;&gt;Increase&lt;/button&gt; &lt;/div&gt; ) //如果不传第二个参数 const &#123; count, dispatch &#125; = this.props return ( &lt;div&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onClick=&#123;()=&gt;&#123; const type = &#123; type: 'CAT' &#125; dispatch(type) &#125;&#125;&gt;Increase&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; react 中 默认props123456//way Aclass Index extends React.Component &#123; static defaultProps = &#123; demo : 12 &#125;&#125;// way BIndex.defaultProps = &#123; demo : 12 &#125; react 中的 props 验证React.PropTypes 自 React v15.5 起已弃用。请使用 prop-types 库代替123456Demo.propTypes = &#123; name: PropTypes.string.isRequired&#125;// 是propTypes 不是PropTypes 也不是 propsTypes// 是propTypes 不是PropTypes 也不是 propsTypes// 是propTypes 不是PropTypes 也不是 propsTypes 关于路由react-router 版本 &gt; 4.0exact 全匹配Switch 匹配一个后不向下匹配 下面两个都会匹配 可以通过 exact 和 Switch 解决 strict 匹配链接的斜杠true /one 只匹配 /onefalse /one 匹配 /one /one/ /one/twoRoute component={XXX} render={()=&gt; XXX} children 不管path是否被匹配 都会映射 默认是链接渲染 前端react react-router react-redux 服务端koa express pm2","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"},{"name":"react","slug":"react","permalink":"//blog.fenghou.site/tags/react/"}]},{"title":"前端的请求","date":"2017-05-17T03:28:09.000Z","path":"2017/05/17/2017-05-17-content-type/","text":"request &amp;&amp; responsecontent-type 参考跨域资源共享 CORS 详解","tags":[{"name":"http","slug":"http","permalink":"//blog.fenghou.site/tags/http/"}]},{"title":"浅析vue数据响应","date":"2017-04-15T12:16:29.000Z","path":"2017/04/15/2017-04-15-vue-observe-watch/","text":"Vue相关-整理中模板解析 指令解析数据劫持过程中监听 set 和 getget 过程时 判断是否在模板解析时用到数据通知 Dep 收集 当前 属性 的监听watch 中 往 dep中添加 要收集的订阅 set 时Dep 通知 watch 可以发布订阅watch 发布订阅","tags":[{"name":"vue","slug":"vue","permalink":"//blog.fenghou.site/tags/vue/"}]},{"title":"Nginx在前端","date":"2017-03-31T01:55:58.000Z","path":"2017/03/31/2017-03-31-nginx-proxy-vue/","text":"总结一些我碰到的Nginx在前端的应用 服务器nginx可以用来当做静态文件的服务器如 本文所在的博客 就是通过nginx来部署的通过root来指定 访问的静态资源的目录123456789101112131415server &#123; listen 443; ssl on; ssl_certificate /admin/ali-ssl/fenghou_site.pem; ssl_certificate_key /admin/ali-ssl/fenghou_site.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; server_name fenghou.site; root /admin/fenghou/www/aliyun-blog/hexo; location / &#123; index index.html; &#125;&#125; 反向代理前后端分离的项目中nginx除了起到服务器的作用还可以用来做请求代理 解决一系列的跨域问题说道代理 有的叫正向代理 有的叫反向代理那么是怎么区分的呢？ 很简单正向代理 服务器不知道 真实的用户反向代理 用户不知道 真实的服务器 1234567891011121314server &#123; listen 80; server_name demo.fenghou.site; root /admin/fenghou/www/demo/view/dist; location / &#123; index index.html; &#125; location /demoAPI/ &#123; proxy_pass http://localhost:4000; &#125; location /logAPI/ &#123; proxy_pass http://localhost:5000/; &#125;&#125;","tags":[{"name":"nginx","slug":"nginx","permalink":"//blog.fenghou.site/tags/nginx/"}]},{"title":"骗到手的第八年@陈妞妞@我才是香坊大呲花","date":"2017-03-23T02:22:59.000Z","path":"2017/03/23/2017-03-23-love/","text":"八年九十六个月两千九百二十二天 那会还很瘦的陈妞妞(当然现在也不怎么胖) (是的，陈妞妞现在的形象) 当陈妞妞意识到自己变胖了以后深深的自责，忏悔着but~~ 高中那会我跟陈妞妞说你负责貌美如花我负责赚钱养家 (I Love You) 现在我正在努力陈妞妞不仅仅是花还兼职当上了小仙女~~~ 多年后幼儿园很多小朋友争得面红耳赤“我妈是老师！”“我爸是警察！”“我爸是局长！” 而我家小孩 云淡风轻 一脸不屑“呵，我妈可是仙女！” (该打赏打赏，都别客气)","tags":[{"name":"随笔","slug":"随笔","permalink":"//blog.fenghou.site/tags/随笔/"}]},{"title":"此去经年@我才是香坊大呲花","date":"2017-03-22T06:05:31.000Z","path":"2017/03/22/2017-03-21-diary/","text":"昨天跟同事一起去打球还没开始打，热身阶段投了会儿球完了，跟跑完1000米一样一样的后来还硬是打了快俩小时今天全身酸爽的不行连走路都走不顺 唉 老是真的老了想想上次打球还是去年毕业前最后的寝室南北对抗赛 (拍照那小子，问什么不把我照进去) 那会虽然体重跟现在差了略微几斤但是照样能跑能跳 大学不是一点儿好处没有它能洗去人的浮华同时让人意志消磨多愁善感酒量大增(有吗) 真正的成长或许就是你开始低下了头无论在行走还是坐着的时候当头颅微微低下成为你日常生活中的主要姿势你就真的长大了总仰着脑袋的一定小屁孩以为自己很牛x其实差远了","tags":[{"name":"随想","slug":"随想","permalink":"//blog.fenghou.site/tags/随想/"},{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"基于Vue的CPS后台","date":"2017-02-27T11:17:43.000Z","path":"2017/02/27/2017-02-27-基于Vue的CPS后台/","text":"上周结束了在想去的最后一个项目公众号联盟的推广后台 技术栈vue应该不需要介绍vuex巴拉巴拉巴拉vue-router。。。。webpack这次用的版本是2.x跟1.x的配置还是有点出入 实现将整个后台按功能抽离成单独的模块header 模块footer 模块menu 模块page 分页模块and 具体功能模块balabalabalabala~~~其实也没什么好说的。。。 坑还是有不少值得注意的地方的 路由切换中页面的刷新12345678//监听路由变化watch: &#123; '$route' (to, from) &#123; if (to.fullPath !== from.fullPath) &#123; this.pageInt() // 刷新处理 &#125; &#125; &#125; store交互数据的延迟1234567891011121314151617181920212223242526272829303132333435363738394041//返回异步操作//actionsgetOrder (&#123;commit&#125;, data) &#123; const opts = &#123; type: 'POST', url: '/union/order/list', data: data &#125; return fetchLoading(commit, 'SET_ORDER', opts)&#125;const fetchLoading = (commit, fn, opts) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; beginLoading(commit) Util.fetch(opts) .then(response =&gt; &#123; stopLoading(commit) if (fn) &#123; commit(fn, response) resolve() &#125; else &#123; resolve(response) &#125; &#125;, error =&gt; &#123; stopLoading(commit) const config = &#123; isShow: true, isToast: true, toastConfig: &#123; toastMsg: '系统繁忙,请稍后再试' &#125; &#125; commit('SET_POP', config) console.error(error) &#125;) &#125;)&#125;//模块中调用actions中方法this.getOrder(opts) .then(() =&gt; &#123; this.getPaging(opts) &#125;) 总结估计这周就离职了额，就这样吧","tags":[{"name":"webpack","slug":"webpack","permalink":"//blog.fenghou.site/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"//blog.fenghou.site/tags/vue/"},{"name":"es6","slug":"es6","permalink":"//blog.fenghou.site/tags/es6/"}]},{"title":"Weex","date":"2017-02-21T11:17:14.000Z","path":"2017/02/21/2017-02-21-Weex/","text":"整理中","tags":[{"name":"weex","slug":"weex","permalink":"//blog.fenghou.site/tags/weex/"}]},{"title":"Rax","date":"2017-02-17T11:16:59.000Z","path":"2017/02/17/2017-02-17-Rax/","text":"整理中","tags":[{"name":"rax","slug":"rax","permalink":"//blog.fenghou.site/tags/rax/"}]},{"title":"PReact","date":"2017-02-13T11:16:39.000Z","path":"2017/02/13/2017-02-13-PReact/","text":"React相关-整理中","tags":[{"name":"PReact","slug":"PReact","permalink":"//blog.fenghou.site/tags/PReact/"}]},{"title":"wx签名出错-URL","date":"2017-02-13T11:16:16.000Z","path":"2017/02/13/2017-02-13-wx签名出错-URL/","text":"上周调试wx收货地址的时候碰到一个签名出错的问题invalid signature 前提为了增强用户体验在下单页选择收货地址的时候如果是微信用户新增添加微信地址的功能 思路调用wxAPI获取地址信息转换地址信息格式将新地址保存 注意点wx.openAddress方法中cancel回调是取消选项 wx地址选择中北京天津等自治区新增县选项北京市 北京市 朝阳区北京市 县 密云县 问题因为方便测试打开页面的方式都是通过打开指定连接的形式http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1一切OK但是从商品详情页进入在选择SKU下单的时候wx.openAddress会调用不了也就是 直接打开 http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1 正常先进商品详情页 ==&gt; http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1 异常invalid signature 解决直接打开链接wx浏览器会对url连接进行转码(encode)wx浏览器内部连接跳转不会对url进行转码处理 wx验证签名信息的时候会将当前页面的链接进行转码处理(encode) 所以直接打开 http://www.xiangqu.com/order/submit/view?skuMap[q90060] = 1wx的验证的URL = http://www.xiangqu.com/order/submit/view?skuMap%5Bq90060%5D=1服务端验证的URL = http://www.xiangqu.com/order/submit/view?skuMap%5Bq90060%5D=1 间接打开的 http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1wx的验证的URL = http://www.xiangqu.com/order/submit/view?skuMap%5Bq90060%5D=1服务端验证的URL = http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1 解决方法很简单在跳转的时候js先对链接进行转码 延伸在处理url编码问题的时候最好的方法就是Javascript先对URL进行编码不通过浏览器编码保证输出结果和服务器得到数据的一致","tags":[{"name":"wx","slug":"wx","permalink":"//blog.fenghou.site/tags/wx/"}]},{"title":"react-redux","date":"2017-02-05T11:15:42.000Z","path":"2017/02/05/2017-02-05-react-redux/","text":"React相关-整理中","tags":[{"name":"react","slug":"react","permalink":"//blog.fenghou.site/tags/react/"}]},{"title":"react-flux","date":"2017-02-04T11:15:20.000Z","path":"2017/02/04/2017-02-04-react-flux/","text":"React相关-整理中","tags":[{"name":"react","slug":"react","permalink":"//blog.fenghou.site/tags/react/"}]},{"title":"react-immutable","date":"2017-02-03T11:14:58.000Z","path":"2017/02/03/2017-02-03-react-immutable/","text":"React相关-整理中","tags":[{"name":"react","slug":"react","permalink":"//blog.fenghou.site/tags/react/"}]},{"title":"Canvas--毛笔字书法","date":"2017-01-21T11:14:18.000Z","path":"2017/01/21/2017-01-21-Canvas毛笔字书法/","text":"继续Canvas这次记录移动端手写书法的实现 抛出问题canvas在移动端应用书法需要解决两个问题1.笔锋问题2.连贯问题 解决方案首先分析一下毛笔字是有笔锋的又粗有细有勾有钩通过点击时间长短决定画笔大小来模拟毛笔力度 通过touchmove事件获取连续移动的两个点计算两点间的直线距离通过循环在canvas画图 代码上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687let domCanvas = document.querySelector('#Calligraphy'), context = domCanvas.getContext('2d'), CONFIG = &#123; lineMin:8, lineMax:20, radius:0 &#125;; let Calligraphy = function()&#123; this.touchFlog = false; this.hasEvent = []; //move数组 this.upEvent = null; //当前操作 this.limitDis = 80; //移动最少距离 this.radius = CONFIG.radius; this.lineMin = CONFIG.lineMin; this.lineMax = CONFIG.lineMax; &#125; Calligraphy.prototype = &#123; start:function()&#123; //开始执行监听事件 this.bindEventDown = this.eventDown.bind(this); this.bindEventMove = this.eventMove.bind(this); this.bindEventUp= this.eventUp.bind(this); domCanvas.addEventListener('touchstart',this.eventDown) domCanvas.addEventListener('touchmove',this.bindEventMove) domCanvas.addEventListener('touchend',this.bindEventUp) &#125;, eventDown:function(e)&#123; console.log('Down') e.preventDefault(); let target = e.changedTouches[e.changedTouches.length-1]; this.touchFlog = true; this.hasEvent = []; // this.upEvent = this.getPoint(target); //当前操作 &#125;, eventMove:function(e)&#123; console.log('Move'); let target = e.changedTouches[e.changedTouches.length-1]; this.drawFont(this.getPoint(target)) &#125;, eventUp:function()&#123; console.log('Up'); e.preventDefault(); this.moveFlog = false; &#125;, drawFont:function(point)&#123; if(!this.touchFlog) return false; let moEvent = point, upEvent = this.upEvent, upRadius = this.radius, dis = 0, //连续点距离 time = 0; //时间 this.hasEvent.unshift(&#123;time:new Date().getTime(),dis:this.getDistance(upEvent,moEvent)&#125;); for (let n = 0; n &lt; this.hasEvent.length-1; n++) &#123; dis += this.hasEvent[n].dis; time += this.hasEvent[n].time-this.hasEvent[n+1].time; if (dis&gt;this.limitDis) break; &#125; let radius = Math.min(time/dis+this.lineMin,this.lineMax)/2; //计算这次画笔半径 this.radius = radius; this.upEvent = moEvent; let len = Math.round(this.hasEvent[0].dis/2)+1; //跟上次画笔半径渐变 for (let i = 0; i &lt; len; i++) &#123; let x = upEvent.x + (moEvent.x-upEvent.x)/len* i, y = upEvent.y + (moEvent.y-upEvent.y)/len* i, r = upRadius + (radius-upRadius)/len*i; context.beginPath(); context.arc(x,y,r,0,2*Math.PI,true); context.fill(); &#125; &#125;, getPoint:function()&#123; return &#123; x: e.clientX - domCanvas.offsetLeft + (document.body.scrollLeft || document.documentElement.scrollLeft), y: e.clientY - domCanvas.offsetTop + (document.body.scrollLeft || document.documentElement.scrollTop), &#125; &#125;, getDistance: function(pre,next)&#123; let x = next.x - pre.x, y = next.y - pre.y; return Math.sqrt(x*x + y*y); &#125; &#125; let calligrapgy = new Calligraphy(); calligrapgy.start();","tags":[{"name":"canvas","slug":"canvas","permalink":"//blog.fenghou.site/tags/canvas/"}]},{"title":"Canvas--黑凤梨","date":"2017-01-20T11:13:46.000Z","path":"2017/01/20/2017-01-20-Canvas黑凤梨/","text":"之前很火的黑凤梨生成性格图片相信大家印象深刻短时间拉了大量粉丝，同时自个儿也被微信封了我们公司当时也做了一个类似的活动想去治病！ 活动流程通过输入生日年月，确定星座每个新座对应几个不同的病症每个病症对应几段不同的文案和商品诊断结果可以分享 初步想法前端通过canvas实现结果图片通过toDataURL转成Image用微信浏览器自带保存图片功能 遇到的问题设计师希望采用第三方字体那显然在前端实现这有点坑用户流量中文不是就26个字母常用词汇加起来2500 大概7M左右这还是一种字体要实现设计稿要求至少需要三种字体 解决办法将字体资源放到服务器有服务端实现生成图片前端上传生成格式和内容 代码实现在代码实现上前端没有什么大问题主要是数据格式的规定上1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586let XZ = &#123; '1':&#123; division:19, items:['MJ','SP'] &#125;, '2':&#123; division:18, items:['SP','SY'] &#125;, '3':&#123; division:20, items:['SY','BY'] &#125;, '4':&#123; division:19, items:['BY','JN'] &#125;, '5':&#123; division:20, items:['JN','SdZ'] &#125;, '6':&#123; division:21, items:['SdZ','JX'] &#125;, '7':&#123; division:22, items:['JX','SlZ'] &#125;, '8':&#123; division:22, items:['SlZ','CN'] &#125;, '9':&#123; division:22, items:['CN','TC'] &#125;, '10':&#123; division:23, items:['TC','TX'] &#125;, '11':&#123; division:22, items:['TX','SS'] &#125;, '12':&#123; division:21, items:['SS','MJ'] &#125;&#125;//星座的判别let oXz = XZ[domInputMonth], sXz = domInputDate &lt;= oXz.division ? oXz.item[0] : oXz.item[1];//病症描述的格式规定['$+@70@&amp;方正兰亭特黑简体&amp;**+$$+@50@&amp;方正兰亭特黑简体&amp;想发个朋友圈+$','结果..$+@50@&amp;方正兰亭特黑简体&amp;俩小时+$过去了...','还在$+@110@&amp;方正兰亭特黑简体&amp;选照片+$']文案分行采取数组形式$+ +$ 包含有特殊字体文本&amp; &amp; 特殊字体@ @ 字号** 替换文案(姓名)//生成文案在显示位置通过本地Canvas模拟生成的图片(字体用系统字体代替)context.ctx.font = nSize+'px arial';context.measureText(sContext).width 来获取长度通过指定宽度容器的比较获取x,y坐标//小技巧//数组的随机Array.prototype.shuffle = function(n)&#123; let len = this.length,num = n ? Math.min(n,len) : len,index, arr = this.slice(0),temp, lib = &#123;&#125;; lib.range = function(min,max)&#123; return min + Math.floor(Math.random()*(max-min+1)) &#125; for(let i =0;i&lt;len;i++)&#123; index = lib.range(i,len-1); temp = arr[i]; arr[i] = arr[index]; arr[index] = temp; &#125; return arr.slice(0,num); &#125;//两个数组的合并[a].concat([b]) 返回结果新数组[].push.apply([a],[b]);返回结果[a] 总结虽然好像跟canvas关系不大但是，好像也没有但是。。。","tags":[{"name":"canvas","slug":"canvas","permalink":"//blog.fenghou.site/tags/canvas/"}]},{"title":"Canvas--星空","date":"2017-01-19T11:13:18.000Z","path":"2017/01/19/2017-01-19-Canvas星空/","text":"Canvas 星空效果嗯 是的 就是左上方的星空效果 设计思路其实星空在实现上很简单一个星星就是一个星星对象实例有属性x坐标，y坐标，半径，移动速度和透明度有方法生成坐标，绘制星星 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&#123; /* * 配置选项 * width:画布宽 * height:画布高 * splitHeight:星星密集分割 * stars:星星数量 * maxStar:星星最大半径 * minStar:星星最小半径 * maxSpeed:星星最大移动速度 * minSpeed:星星最小移动速度 * */ let SkySetting = &#123; width:800, height:300, splitHeight:200, stars:400, maxStar:1.2, minStar:0.6, maxSpeed:0.1, minSpeed:0.02, &#125;, domCanvas = document.querySelector('#Star'), context = domCanvas.getContext('2d'); /* * 画布实例 * */ let starSky = function(width,height,stars)&#123; this.width = width; this.height = height; this.stars = stars; this.aStars = []; &#125; starSky.prototype = &#123; /* * 入口 * */ start:function()&#123; domCanvas.width = this.width; domCanvas.height = this.height; context.fillStyle = 'rgba(0,0,0,1)'; context.fillRect(0,0,this.width,this.height); this.render(); &#125;, /* * 重绘 * */ redraw:function()&#123; context.clearRect(0,0,this.width,this.height); context.fillStyle = 'rgba(0,0,0,1)'; context.fillRect(0,0,this.width,this.height); &#125;, /* * 新建星星实例 * 绘制星星 * window.requestAnimationFrame 动画函数 * */ render:function()&#123; this.redraw(); if(this.aStars.length &lt;= this.stars)&#123; let star = new Star(); this.aStars.push(star); &#125; this.aStars.forEach(function(star)&#123; star.draw(); &#125;) window.requestAnimationFrame(()=&gt;&#123; this.render(); &#125;); &#125;, &#125; /* * 星星构造器 * */ let Star = function()&#123; this.randomPoint(); &#125; Star.prototype = &#123; /* * 随机星星数据 * */ randomPoint:function()&#123; let _x = Math.random()*SkySetting.width, _r = SkySetting.minStar + Math.random()*(SkySetting.maxStar - SkySetting.minStar), _ran = Math.random()*10, _rx = Math.random()*(SkySetting.maxSpeed-SkySetting.minSpeed) + SkySetting.minSpeed, _y = _ran &gt; 2 ? Math.random()*SkySetting.splitHeight: Math.random()*SkySetting.height, _alphaMax = Math.random()*0.8 + 0.2, _alphaMin = 0.2, _alpha = 0; this.x = _x; this.y = _y; this.r = _r; this.rx = _rx; this.alpha = _alpha; this.alphaMax = _alphaMax; this.alphaMin = _alphaMin; this.alphaAction = true; &#125;, /* * 绘制星星 * 星星变化 * */ draw:function()&#123; this.x += this.rx; if(this.x + this.r &gt;= SkySetting.width)&#123; this.x = 0; &#125; if(this.alphaAction)&#123; if(this.alpha &lt; this.alphaMax)&#123; this.alpha += 0.05; &#125;else&#123; this.alphaAction = false &#125; &#125; if(!this.alphaAction)&#123; if(this.alpha &gt; this.alphaMin)&#123; this.alpha -= 0.02; &#125; else&#123; this.alphaAction = true; &#125; &#125; context.beginPath(); context.fillStyle = 'rgba(255,255,255,'+this.alpha.toString()+')'; context.arc(this.x,this.y,this.r,0,Math.PI*2,true); context.closePath(); context.fill(); &#125; &#125; /* * 构造星空实例 * */ let sky = new starSky(SkySetting.width,SkySetting.height,SkySetting.stars); sky.start(); &#125;","tags":[{"name":"canvas","slug":"canvas","permalink":"//blog.fenghou.site/tags/canvas/"}]},{"title":"Canvas--刮刮卡","date":"2017-01-18T11:12:27.000Z","path":"2017/01/18/2017-01-18-Canvas刮刮卡/","text":"到年底了，去回顾了下做过的项目发现有很多跟Canvas有关的这里简单记录一点心得方便日后查阅 一个模拟刮奖的活动设计思路获奖结果上实现一个遮层手指滑动位置遮层对应位置色值清空判断清空数据达到设定值，清除遮层 必备APIgetContext()getImageData() //获取画布像素数据 每个像素包含RGBA四个值fill() //填充rect() //矩形arc() //圆globalCompositeOperation //设置或返回如何将一个源（新的）图像绘制到目标（已有）的图像上 touch事件touchstarttouchmovetouchendchangedTouches:touchlist。对于 touchstart 事件, 这个 TouchList 对象列出在此次事件中新增加的触点对于 touchmove 事件，列出和上一次事件相比较，发生了变化的触点对于 touchend ，列出离开触摸平面的触点（这些触点对应已经不接触触摸平面的手指） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&#123; let domCanvas = document.querySelector('#GGL'), context = domCanvas.getContext('2d'); /* * 构建对象 * width * height * filter 取消遮罩百分比 * */ let clipImage = function(height,width,filter)&#123; this.width = width; this.height = height; this.filter = filter; domCanvas.width = this.width; domCanvas.height = this.height; &#125; clipImage.prototype = &#123; /* * 函数入口 * 开始监听事件 * */ start:function()&#123; context.fillStyle = 'gray'; context.fillRect(0,0,this.width,this.height); context.globalCompositeOperation = 'destination-out'; this.bindEventMove = this.eventMove.bind(this); this.bindEventUp= this.eventUp.bind(this); domCanvas.addEventListener('touchstart',this.eventDown) domCanvas.addEventListener('touchmove',this.bindEventMove) domCanvas.addEventListener('touchend',this.bindEventUp) &#125;, eventDown:function()&#123; console.log('Down') &#125;, eventMove:function(e)&#123; console.log('Move'); let target = e.changedTouches[e.changedTouches.length-1]; this.clearMove(target) &#125;, eventUp:function()&#123; console.log('Up'); this.clearMask(); &#125;, /* * 清除划过画布 * */ clearMove:function(target)&#123; let nX = target.clientX, nY = target.clientY; context.beginPath(); context.arc(nX,nY,15,0,Math.PI * 2); context.fill(); &#125;, /* * 判断像素点清除数是否到达指定百分比 * */ clearMask:function()&#123; let nNum = 0, aImageData = context.getImageData(0,0,this.width,this.height).data, nLength = aImageData.length; aImageData.forEach((item)=&gt;&#123; if(item == 0)&#123; nNum++; &#125; &#125;) if(nNum &gt;= nLength * this.filter)&#123; this.finish(); &#125; &#125;, /* * 完成刮奖 * */ finish:function()&#123; context.beginPath(); context.rect(0,0,this.width,this.height); context.fill(); domCanvas.removeEventListener('touchstart',this.eventDown); domCanvas.removeEventListener('touchmove',this.bindEventMove); domCanvas.removeEventListener('touchend',this.bindEventUp); &#125; &#125; let clip = new clipImage(400,400,.3); clip.start(); &#125;","tags":[{"name":"canvas","slug":"canvas","permalink":"//blog.fenghou.site/tags/canvas/"}]},{"title":"谈谈js的继承","date":"2017-01-03T11:11:44.000Z","path":"2017/01/03/2017-01-03-谈谈js的继承/","text":"继承在JavaScript中不像在别的面向对象语言中那样简单JavaScript使用的是基于对象的继承它可以用来模仿基于类的继承Es6中，新增了Class和extends关键字来支持类的继承在这里记录各种继承的实现方式 类式继承JavaScript对象可以模仿Java中的对象通过函数来声明类用关键字new来创建实例这种方式包括两个步骤1.用一个类的声明定义对象的结构2.实例化该类创建一个新对象123456789//类的实例function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(this.sName);&#125;;var Ls = new Person('Ls');Ls.sayName(); 这种类式继承的方式可以分为五种对象冒充，Call，Apply，原型链和混合模式 对象冒充构造函数使用 this 关键字给所有属性和方法赋值因为构造函数只是一个函数所以可使Person构造函数成为Author的方法，然后调用它Author就会收到Person的构造函数中定义的属性和方法123456789101112131415161718function Person(name)&#123; this.name = name; this.sayName=function()&#123; console.log(this.name); &#125; &#125;function Author(name,book)&#123; this.book = book; this.Person = Person; this.Person(name); delete this.Person; this.sayBook = function()&#123; console.log(this.book) &#125;&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook(); apply&amp;&amp;call继承call和apply方法通过改变函数上下文实现继承1234567891011121314151617function Person(name)&#123; this.name = name; this.sayName=function()&#123; console.log(this.name); &#125; &#125;function Author(name,book)&#123; this.book = book; Person.call(this,name); Person.apply(this,[name]); this.sayBook = function()&#123; console.log(this.book) &#125;&#125;var Ls = new Author('Ls','My Book'); Ls.sayName(); Ls.sayBook(); 原型链使子类原型对象指向父类的实例以实现继承,即重写类的原型对象1234567891011121314151617function Person()&#123;&#125;Person.prototype.sName = '';Person.prototype.sayName = function () &#123; console.log(this.sName);&#125;;function Author(book)&#123; this.book = book;&#125;Author.prototype = new Person();Author.prototype.sayBook= function()&#123; console.log(this.book);&#125;;var Ls = new Author('My book');Ls.sName = 'Ls';Ls.sayName();Ls.sayBook(); 这种模式无法使用带参数的构造函数，不支持多重继承 混合模式继承用对象冒充继承构造函数的属性，用原型链继承 prototype 对象的方法123456789101112131415161718function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(this.name);&#125;;function Author(name,book)&#123; Person.call(this,name); this.book = book;&#125;Author.prototype = new Person();Author.prototype.constructor = Author;Author.prototype.sayBook = function()&#123; console.log(this.book);&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook(); 为了简化类的声明，可以把派生子类的整个过程包装在一个名为extend的函数中空函数F，这样可以避免创建Person的新实例,因为它可能会比较庞大增加superclass这个属性弱化Author与Person之间的耦合并且确保constructor属性被正确设置123456789101112131415161718192021222324252627function extend(subClass.superClass)&#123; var F = function()&#123;&#125;; F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass; subClass.superclass = superClass.prototype; if(subClass.prototype.constructor == Object.prototype.constructor)&#123; subClass.prototype.constructor = subClass; &#125;&#125;function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(this.name);&#125;;function Author(name,book)&#123; Author.superclass.constructor.call(this,name); this.book = book;&#125;extend(Author,Person)Author.prototype.sayBook = function()&#123; console.log(this.book);&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook(); JavaScript中的类式继承仅仅是对正正基于类的继承的一种模仿 原型式继承原型式继承与类式继承截然不同它并不需要用类来定义对象结构，只需要创建一个对象这个对象可以被新的对象重用1234567891011121314151617181920212223var Person = &#123; name:'default name', sayName:function()&#123; console.log(this.name); &#125;&#125;var Author = clone(Person);Author.book = 'default book';Author.sayBook = function()&#123; console.log(this.book);&#125;var Ls = clone(Author);Ls.name = 'Ls';Ls.book = 'My Book';Ls.sayName();Ls.sayBook();//clone 通过把F的prototype属性设置为作为参数obj传去的原型对象//函数返回的结果是一个以给定对象为原型对象的空对象function clone(obj)&#123; function F()&#123;&#125; F.prototype = obj; return new F();&#125; Es6 extendsEs6中引入了Class 和extends关键字12345678910111213141516171819202122class Person&#123; constructor(name)&#123; this.name = name; &#125; sayName()&#123; console.log(this.name) &#125; &#125;class Author extends Person&#123; constructor(name,book)&#123; super(name); this.book = book; &#125; sayBook()&#123; console.log(this.book); &#125;&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook();Ls.__proto__ === Author.prototype; //trueAuthor.prototype.__proto__ === Person.prototype; //true","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"彻底理解Js中的作用域和上下文","date":"2016-12-30T11:11:06.000Z","path":"2016/12/30/2016-12-30-彻底理解Js中的作用域和上下文/","text":"笔记 - 总结 - 心得函数的每次调用都有与之紧密相关的作用域和上下文这俩者是完全不同的作用域(Scope) 是基于函数的作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的而上下文(Context)是基于对象的上下文始终是this关键字的值，它是拥有(控制)当前所执行代码的对象的引用。 作用域(Scope)首先只有函数具有作用域也就是说，在一个函数内部声明的变量在函数外部无法访问JavaScript的作用域是词法性质的这这意味着函数运行在定义它的作用域中而不是在调用它的作用域中12345678910function foo()&#123; var a = 10; function bar()&#123; a *= 2; return a; &#125; return bar;&#125;var baz = foo();baz(); //20 Es6之前 局部变量只能存在于函数体中Es6开始支持let声明变量 局部变量能存在于块级作用域通过var声明的变量会出现变量提升的问题 变量的 声明周期 声明阶段(Declaration phase) 初始化阶段(Initialization phase) 初始化阶段：variable = undefined 赋值阶段(Assignment phase) 赋值阶段后：variable = ‘value’ var变量在函数作用域的开始位置就完成了声明阶段(variable)和初始化阶段(var variable)，这两个阶段之间没有任何间隙let变量通过声明阶段(foo)后，会进去暂时性死区，此时变量不可访问，直到初始化阶段(let foo)之后，变量才可以被访问所以变量提升是变量的耦合声明并且在作用域的顶部完成初始化然而let生命周期中将声明和初始化阶段解耦。这一解耦使 let 的变量提升现象消失。 上下文(Context)上下文通常取决于函数是如何被调用的1234567891011121314151617181920212223242526//当一个函数作为对象中的一个方法被调用的时候,this就设置为调用该方法的对象var foo = &#123; bar:function()&#123; console.log(this === foo) &#125;&#125;foo.bar() // true//当使用new操作符创造对象的实例时,函数的作用域内部this的值被设置为新创建的实例let aThis = [];function foo(x)&#123; this.x = x; aThis.push(this); console.log(this); //foo&#123;x:1&#125; //foo&#123;x:2&#125;&#125;foo.prototype.baz = function()&#123; console.log(this.x); //1 //2&#125;new foo(1);new foo(2);aThis.forEach(function(item)&#123; item.baz();&#125;) 执行环境(execution context)执行环境 定义了变量或函数有权访问的数据，决定它们各自的行为Js是单线程的，当JavaScript解释器初始化执行代码时，会默认进入全局执行环境此后函数的每次调用都会创建一个新的执行环境每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境会被推入一个环境栈中在函数执行完后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个便利的机制控制着执行环境可以分为创建和执行两个阶段。在创建阶段，解析器首先会创建一个变量对象（variable object，也称为活动对象 activation object），它由定义在执行环境中的变量、函数声明、和参数组成。在这个阶段，作用域链会被初始化， this 的值也会被最终确定。在执行阶段，代码被解释执行。 作用域链(scope chain)当代码在一个环境中执行时会创建变量对象的一个作用域链作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问作用域链包含了在环境栈中的每个执行环境对应的变量对象内部环境可以通过作用域链访问所有的外部环境但是外部环境不能访问内部环境中的任何变量和函数这些环境之间的联系是线性的、有次序的 闭包闭包是指有权访问另一函数作用域中的变量的函数在函数内定义一个嵌套的函数时，就构成了一个闭包它允许嵌套函数访问外层函数的变量通过返回嵌套函数，允许你维护对外部函数中局部变量、参数、和内函数声明的访问。1234567891011121314151617181920212223242526272829303132333435363738//模块模式最流行的闭包类型之一，它允许你模拟公共的、私有的、和特权成员let Module = (function()&#123; var privateProperty = 'foo'; fucntion privateMethod()&#123; &#125; return &#123; publicProperty:'', publicMethod:function()&#123; &#125;, privilegedMethod: function()&#123; return privateMethod(arguments); &#125; &#125;&#125;)()//另一种类型的闭包被称为 立即执行的函数表达式(IIFE) Es5中(function(window)&#123; var foo, bar; function private()&#123; // do something &#125; var Module = &#123; public: function()&#123; // do something &#125; &#125;; window.Module = Module;&#125;)(this);//保护全局命名空间免受变量污染var baz;(function()&#123; var foo = 10; var bar = 2; baz = function()&#123; return foo * bar; &#125;&#125;)()baz(); //20//保护私用private变量 apply&amp;call&amp;bindapply和call内建在所有的函数中(它们是Function对象的原型方法)允许你在自定义上下文中执行函数不同点在于，call函数需要参数列表，而apply 函数需要你提供一个参数数组 12345678910111213141516171819202122232425262728//argumentsfunction foo()&#123; [].slice.apply(arguments); [].sort.apply(arguments,function(a,b)&#123; return a&gt;b; &#125;)&#125;//apply在传递参数时会将数组转变成列表集合//在一些只能处理列表的方法中可以巧妙地处理//求数组最大值let a = [1,2,3];Math.max(1,2,3); //3Math.max.apply(this,a); //3//两个数组合并let a = [1,2], b = [3,4];//a.push(b)//a [1,2,[3,4]];[].push.apply(a,b)//a [1,2,3,4];function AA(a,b,c,d)&#123; console.log(a,b,c,d)&#125;AA.apply(AA,[1,2,3,4])function BB([a,b,c,d] = arr)&#123; console.log(a,b,c,d)&#125;BB([1,2,3,4]) 在ES5中引入了 Function.prototype.bind 方法，用于控制函数的执行上下文，它会返回一个新的函数，并且这个新函数会被永久的绑定到 bind 方法的第一个参数所指定的对象上，无论该函数被如何使用。 1234567891011//低版本浏览器，我们可以简单的对它进行实现如下(polyfill)if(!('bind' in Function.prototype))&#123; Function.prototype.bind = function()&#123; var fn = this, context = arguments[0], args = Array.prototype.slice.call(arguments, 1); return function()&#123; return fn.apply(context, args.concat(arguments)); &#125; &#125;&#125; Es6箭头函数S6中的箭头函数可以作为 Function.prototype.bind() 的替代品。和普通函数不同，箭头函数没有它自己的this值，它的 this 值继承自外围作用域。12345678910111213141516171819202122232425var Obj = &#123; baz:.. foo:function()&#123; let self = this; [1,2,4,5].forEach(function(item)&#123; self.baz(item); &#125;) &#125;&#125;//Es5 bindvar Obj = &#123; baz:.. foo:function()&#123; [1,2,4,5].forEach(function(item)&#123; self.baz(item); &#125;.bind(this)) &#125;&#125;//Es6箭头函数var Obj = &#123; baz:.. foo:function()&#123; [1,2,4,5].forEach((item)=&gt;this.baz(item)) &#125;&#125;","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"ECMA-prototype","date":"2016-12-28T11:09:23.000Z","path":"2016/12/28/2016-12-28-ECMA-prototype/","text":"要学好Js，首先必须得先理解原型(prototype)why？js作为面向对象的语言，实现面向对象的机制就是原型！都说js中一切皆对象,那到底什么是对象呢？ 对象是属性的集合，并有一个原型对象。原型对象可以是空值。 按宿主环境分可以分为 原生对象：由ECMAScript规范定义其语义的对象 内置对象：由ECMAScript实现提供，独立于宿主环境的对象，ECMAScript程序开始执行时就存在(所有内置对象是原生对象) 宿主对象：由宿主环境提供的对象，用于完善ECMAScript执行环境(DOM,BOM) 按功能分可以分为： 普通对象：无原型对象 函数对象：有原型对象(函数对象的一个实例) 我们这里只关注函数对象那么到底什么是原型呢？ 1234567891011121314151617181920212223242526272829303132//凡是通过new Function() 创建的对象都是函数对象function Bar()&#123;&#125;var foo = function()&#123;&#125;var baz = new Function();//Bar foo baz 都是函数对象//原型对象本质是函数对象的一个实例function Bar()&#123;&#125;Bar.prototypevar temp = new Bar();Bar.prototype = temp;var temp = new Function();Function.prototype = temp//构造器：创建和初始化对象的函数对象(在原型对象prototype中,prototype.constructor)//原型对象prototype中都有个预定义的constructor属性，用来引用它的函数对象//每个由构造器创建的对象拥有一个执行构造器prototype的属性值的隐式引用//这个引用称之为原型//每个原型可以拥有指向自己原型的隐式引用(原型的原型),就是所谓的原型链//每个对象都有一个__proto__属性来实现对原型的隐式引用function Person()&#123;&#125;Person.prototype = &#123; name:'Louis', age:'24'&#125;var person = new Person();person.__proto__ = Person.prototypePerson.prototype.__proto__ = Object.prototypeObject.prototype.__proto__ = null//person对象由构造器Person创建//所以person对Person.prototype有隐式引用(__proto__)//Person对象又是由构造器Object创建//所以Person对Object.prototype有隐式引用(__proto__)","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"你真的学好Js了吗","date":"2016-12-27T11:08:58.000Z","path":"2016/12/27/2016-12-27-你真的学好Js/","text":"在我看来前端(Js)就好比是个剑客江湖江湖中有人练react宝典，有人练vue神功有人锻造webpack利剑…而Js就是这些的基础心法，决定这些宝典,神功最后在你手上的杀伤力那么作为最基础的心法，你真的参透的了吗？ 这里简单的记录些Js的一些特点 面向对象什么是面向对象 一切事物皆对象对象具有封装和继承特性对象与对象之间使用消息通信，各自存在信息隐藏 众所周知Java采用面向对象思想构造其语言，它实现了类、继承、多态、接口等机制。但是这些机制，只是实现面向对象编程的一种方式实际上，Js是通过原型的方式来实现面向对象编程的Js中的对象是依靠构造器(constructor)利用原型(prototype)构造出来的 1234567891011121314151617//对象的声明//字面式对象声明var person = &#123; name:'Louis', age:'24'&#125;//使用函数构造器构造对象function Person()&#123;&#125;Person.prototype = &#123; name:'Louis', age:'24'&#125;var person = new Person();//这里的new关键字跟java中 的new毫无关系//只是借用了它的关键字new//用来表示调用构造器创建对象 弱类型语言在Js中，定义变量不必声明其类型。但这不意味着变量没有类型。原始类型：布尔型、数值型、字符串类型引用类型：对象类型(数组是一种特殊的对象)、函数类型其他类型：空类型和未定义类型js中的变量可以根据所附的值改变类型原始类型按值传送，在栈内存中存的是变量的值引用类型则按引用传送，在栈内存中存的是 引用对象在堆内存中的地址所以这里涉及到引用类型深拷贝和浅拷贝的问题 1234567891011121314151617181920//浅拷贝 把父对象的属性全部拷贝给子对象//如果父元素的属性对应的值是引用类型，那子对象对应的属性的值还是引用类型的内存地址//这个时候就需要深拷贝function deepCopy(pre)&#123; var ch = pre.constructor === Array ? [] : &#123;&#125;; if(typeof pre !== 'object')&#123; ch = pre; &#125; else if(window.JSON)&#123; ch = JSON.parse(JSON.stringify(pre)) &#125; else&#123; for(var i in pre)&#123; ch[i] = typeof pre[i] === 'object' ? (pre[i].constructor === Array ? pre[i].slice() : deepCopy(pre[i])) : pre[i] &#125; &#125; return ch;&#125; 函数是一等对象在JavaScript中，函数是一等对象可以存储在变量中可以作为参数传给其他函数可以作为返回值从其他函数传出还可以在运行时进行构造可以用function(){…}这样的语法创建匿名函数 12345(function()&#123; var foo = 20; var bar = 2; alert(foo*bar);&#125;)() 这个函数在定义后便会立即执行匿名函数可以用来创建闭包闭包是一个受到保护的变量空间由内嵌函数生成 对象的易变性JavaScript中,一切都是对象除了三种原始类型(布尔型、数值型、字符串类型)即便是这几种类型在必要时候也会被自动封装成对象而且所有对象都是易变的(mutable) 123456789101112131415161718192021222324252627//为函数添加属性function dispalyError(message)&#123; dispalyError.numTimesExecuted++; alert(message);&#125;dispalyError.numTimesExecuted = 0;//对定义的类和实例化的对象进行修改function Person(name,age)&#123; this.name = name; this.age = age;&#125;Person.prototype = &#123; getName:function()&#123; return this.name; &#125;, getAge:function()&#123; return this.age; &#125;&#125;var alice = new Person('Alice',39);var bill = new Person('Bill',20);Person.prototype.getGreeting = function()&#123; return 'Hi '+ this.getName()+'!';&#125;alice.displayGreeting = function()&#123; alert(this.getGreeting);&#125; 继承继承在JavaScript中不像在别的面向对象语言中那样简单JavaScript使用的是基于对象的继承它也可以用来模仿基于类的继承Es6中新增了extends实现继承后面会有文章相信讲讲继承","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"从实时聊天谈谈通信协议","date":"2016-12-26T11:08:20.000Z","path":"2016/12/26/2016-12-26-实时聊天谈谈通信协议/","text":"作为前端开发人员了解前后端通信协议还是很必须的尤其是在用Node写服务端的时候对于请求的响应处理和返回有很大的帮助客户端与服务端的通信协议有HTTP(HTTPS)协议和WebSocket协议HTTP协议是无状态的，服务端进行处理返回response后很难主动向客户端发送数据WebSocket协议实现了客户端与服务端的全双工通信扩展了客户端与服务端的通信功能使服务端也能主动向客户端发送数据在WebSocket协议提出之前要实现即时通信、实时数据这样的功能，经常会使用轮询(polling)和Comet技术 轮询是最原始的实现实时Web应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。明显地，这种方法会导致过多不必要的请求，浪费流量和服务器资源 Comet技术又可以分为长轮询和流技术。长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个HTTP长连接，服务端会不断更新连接状态以保持HTTP长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。 WebSocket，真正实现了Web的实时通信 Http协议HTTP(Hypertext Transfer Protocol 超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议HTTP限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP的常用请求方法 GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 请求和响应都包含请求头或响应头header和可选的请求体或响应体Body(自由的文本) 只有POST请求包含一个Body Content-type常用的MiME类型 application/x-wwwform-urlencoded 经过编码的键值对请求字符串(Body)，web服务器需要解码字符串获得参数 text/xml,application/xml Body是XML文档 text/plain 普通文本 text/html, text/xhtml Body是(X)HTML内容，web服务器端发送的标准web页面或内容片段 text/javascript Body是一段JavaScript代码 image/png, image/jpeg, image/gif：Body是二进制图像 HTTPS协议HTTPS(Secure Hypertext Transfer Protocol 安全超文本传输协议)是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版。HTTP协议是不安全的，可以轻松对窃听你跟 Web 服务器之间的数据传输在很多情况下，客户和服务器之间传输的是敏感信息，需要防止未经授权的访问 HTTPS协议在TCP协议上加了层SSL协议 网络七层协议 应用层 Http Https 表示层 SSL TLS 会话层 传输层 TCP 网络层 IP 数据链路层 物理层 SSL 包含如下动作：1.验证服务器端2.允许客户端和服务器端选择加密算法和密码，确保双方都支持3.验证客户端(可选)4.使用公钥加密技术来生成共享加密数据5.创建一个加密的 SSL 连接6.基于该 SSL 连接传递 HTTP 请求 TCP协议TCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议连接时三次握手第一次Client端发送SYN报文请求连接第二次Server端接受连接后回复ACK报文，并且为这次连接分配资源第三次Client端接收ACK报文后向Server端发送ACK报文，并分配资源TCP连接建立 断开时四次握手第一次Client发起中断连接，发送FIN报文第二次Server端接到FIN报文后，发送ACK报文，(可能还有数据没有传输完)，Client进入FIN_WAIT状态第三次Server端确定数据已经发送完成，则向Client端发送FIN报文，准备好关闭连接第四次Client端接收FIN报文,知道可以关闭连接，但不相信网络,怕Server端不知道要关闭，发送ACK报文，并进入TIME_WAIT状态Server端收到ACK报文后断开连接Client端等待了一定时间(依赖实现方法)后，没有收到Server回复，表示Server端已正常关闭，Client端也关闭链接TCP连接关闭 AJAXAJAX (Asynchronous Javascript And XML 异步JavaScript和XML)，是指一种创建交互式网页应用的网页开发技术。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求* method：请求的类型；GET 或 POST* url：文件在服务器上的位置* async：true（异步）或 false（同步）** send(string) 将请求发送到服务器* string：仅用于 POST 请求** setRequestHeader(header,value) 向请求添加 HTTP 头* header: 规定头的名称* value: 规定头的值** responseText 获得字符串形式的响应数据。* responseXML 获得XML形式的响应数据。** onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数** readyState 存有 XMLHttpRequest 的状态 从 0 到 4 发生变化* 0: 请求未初始化* 1: 服务器连接已建立* 2: 请求已接收* 3: 请求处理中* 4: 请求已完成，且响应已就绪** status* 200: \"OK\"* 404: 未找到页面* */var xmlhttp = new XMLHttpRequest();xmlhttp.open('POST',url,true);xmlhttp.setRequestHeader('Content-type','application/x-www-form-urlencoded');xmlhttp.send('page=2&amp;size=10');xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.readystate == 4)&#123; if(xmlhttp.status == 200)&#123; console.log(xmlhttp.responseText); &#125; else&#123; //异常 &#125; &#125;&#125; websocketwebsocket协议本质上是一个基于TCP的协议是先通过HTTP/HTTPS协议发起一条特殊的HTTP请求进行握手后创建一个用于交换数据的TCP连接此后服务端与客户端通过此TCP连接进行实时通信 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//客户端var ws = new WebSocket('ws://localhost:8181/');//连接发生错误的回调方法ws.onerror = function()&#123;&#125;//websocket 在任何时候都会处于下面4种状态中的其中一种//CONNECTING (0) 表示还没建立连接//OPEN (1) 已经建立连接，可以进行通讯//CLOSING (2) 通过关闭握手，正在关闭连接//CLOSED (3) 连接已经关闭或无法打开//WebSocket.OPEN = 1;//连接成功建立的回调方法ws.onopen = function(e)&#123; if(ws.readyState === 1)&#123; wsSend('msg'); &#125;&#125;//接收到消息的回调方法ws.onmessage = function(e)&#123; //e.data&#125;//连接关闭的回调方法ws.onclose = function()&#123;&#125;function wsSend(rs)&#123; ws.send(rs);&#125;function wsEnd()&#123; ws.close();&#125;//服务端(Node)var WebSocketServer = require('ws').Server, ws = new WebSocketServer(&#123; port: 8181 &#125;), clients = [], clientNum = 0;ws.on('connection',function(ws)&#123; clientNum ++; clients.push(&#123;'ws':ws&#125;); ws.on('message',function(rs)&#123; wsSend(rs); &#125;)&#125;)function wsSend(rs)&#123; for(var i =0;i&lt;clients.length;i++)&#123; var clientSocket = clients[i].ws; if (clientSocket.readyState === 1) &#123; clientSocket.send(JSON.stringify(rs)); &#125; &#125;&#125;","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"},{"name":"http","slug":"http","permalink":"//blog.fenghou.site/tags/http/"},{"name":"websocket","slug":"websocket","permalink":"//blog.fenghou.site/tags/websocket/"}]},{"title":"Git自动化部署","date":"2016-12-22T11:07:31.000Z","path":"2016/12/22/2016-12-22-git自动化部署/","text":"每次更新完博客,得先push到github上然后在服务器上把代码pull下来部署 一开始 忍了后来 够了 整理一下需要的是本地push成功后服务器上能自动执行pull命令那么问题就变成了如何响应每次的push操作? WebHooksWebhook就是用户通过自定义回调函数的方式来改变Web应用的一种行为，这些回调函数可以由不是该Web应用官方的第三方用户或者开发人员来维护，修改。通过Webhook，你可以自定义一些行为通知到指定的URL去。 那么每次push时候接受到请求，然后执行pull脚本，问题就解决了 github配置github 支持webhook在github项目中选择settingwebhooksPayload URL 请求地址Content type 请求类型Secret 密文(请求之后用作校验) 请求处理通过node接受请求作出响应 1234567891011121314151617181920var http = require('http')var createHandler = require('github-webhook-handler')var handler = createHandler(&#123; path: '/deploy', secret: '' &#125;)http.createServer(function (req, res) &#123; handler(req, res, function (err) &#123; res.statusCode = 404 res.end('no such location') &#125;)&#125;).listen(8989)handler.on('error', function (err) &#123; console.error('Error:', err.message)&#125;)handler.on('push', function (event) &#123; // 调用pull脚本 process.exec('git pull origin master', function (error, stdout, stderr) &#123; if (error !== null) &#123; console.log('exec error: ' + error); &#125; &#125;);&#125;) 这个时候每次push的时候，会发送一个请求到 url:8989/deylop通过node 服务会作出相应操作 服务器部署nginx 方向代理将8989 代理到80端口 1234567server &#123; listen 80; server_name ''; location /deploy &#123; proxy_pass http://localhost:8989; &#125; &#125; 通过forever 启动node 服务","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"},{"name":"git","slug":"git","permalink":"//blog.fenghou.site/tags/git/"}]},{"title":"1px != 1px -- 移动端适配浅析","date":"2016-12-19T11:06:45.000Z","path":"2016/12/19/2016-12-19-移动端适配/","text":"css中我们一般使用px作为单位在pc上css中的1个像素往往对应着电脑屏幕中的1个物理像素这可能会给我们造成一个错觉css中的像素等于设备的物理像素但实际情况却并非如此css中的像素只是一个抽象的单位在不同的设备或不同的环境中css中的1px所代表的设备物理像素是不同的 典型的就是retina屏 首先我们先了解几个概念 viewportviewport 是用户网页的可视区域pc中就是屏幕宽度移动设备中viewport(这个虚拟窗口)比屏幕宽 一般为980 1234567891011&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;移动端布局viewport的宽度设为理想宽度layout viewport 默认的viewport 比屏幕宽 document.documentElement.clientWidthvisual viewport 浏览器可视区域的大小 window.innerWidthideal viewport 最适合移动设备的viewportwidth：控制 viewport 的大小，可以指定的一个值，如果 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。height：和 width 相对应，指定高度。initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。maximum-scale：允许用户缩放到的最大比例。minimum-scale：允许用户缩放到的最小比例。user-scalable：用户是否可以手动缩放。 物理像素(physical pixel)一个物理像素是显示器(手机屏幕)上最小的物理显示单元在操作系统的调度下每一个设备像素都有自己的颜色值和亮度值。 设备独立像素(density-independent pixel)设备独立像素(也叫密度无关像素)可以认为是计算机坐标系统中得一个点这个点代表一个可以由程序使用的虚拟像素(比如: css像素)简单点就是屏幕宽高 设备像素比(device pixel ratio)设备像素比 ＝ 物理像素 / 设备独立像素5,6的dpr=2，1个css像素等于2个物理像素6p的dpr=3,1个css像素等于3个物理像素 那首先我们在移动端布局，viewport肯定不能是默认的值最终viewport宽度等于应该等于设备的宽度我们的布局视图应该是 按照物理像素来布局设备独立像素可获得设备像素比 window.devicePixelRatio现在假设 在iphone6上布局 此时dpr = 2,dip = 375物理像素应该是 dpr * dip = 750div{border-top:1px solid #000;}现在在页面上要实现一个1px的上边框由于移动端布局viewport缩成设备宽度而分辨率没有变所以这时的1px会有2px的效果 这个时候可以手动将viewport 宽度设成物理像素的宽度，然后将整个页面缩小 dpr 倍 1px 的问题解决了，那如何解决在不同手机显示设计稿中的一个100x100的div设计稿 750其中div 100x100750的设计稿对应的是iPhone6结合上面viewport的缩放div{width:100px;height:100px;}在6上跟设计稿是完全相同的而在5(640)上会变大 这个时候可以通过rem在不同设备上动态计算出比例值 假设在750设计稿中 1rem = 100px那么在640设计稿中 1rem = 640/750*100px此时1rem 不管在5上还是6上显示都完全跟在设计稿中显示效果相同 123456789101112//html&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;//动态计算remvar domDocEL = window.document.documentElement, mateViewPort = window.document.querySelector('meta[name=\"viewport\"]'), nBasePsdWidth = 750 / 100, nDpr = window.devicePixelRatio, nScale = 1 / nDpr, nLayout = domDocEL.clientWidth, nRem = nLayout * nDpr / nBasePsdWidth;domDocEL.style.fontSize = rem +'px';mateViewPort.setAttribute('content','width='+nDpr*nLayout+',initial-scale='+nScale+',maximum-scale='+nScale+',minimum-scale='+nScale+',user-scalable=no'); 对于字体可以用写个mixin方法根据不同的dpr设置字号 12345@mixin px2rem($name,$px) &#123; [data-dpr=\"2\"] &amp; &#123; #&#123;$name&#125;: $px*2/2+px; &#125; &#125; 总结移动端布局将viewport设成物理像素的大小,然后在缩放为dpr的倒数倍。dpr不存在？简单点~~~那就指定为1！","tags":[{"name":"css","slug":"css","permalink":"//blog.fenghou.site/tags/css/"},{"name":"rem","slug":"rem","permalink":"//blog.fenghou.site/tags/rem/"}]},{"title":"react","date":"2016-12-18T11:06:01.000Z","path":"2016/12/18/2016-12-18-react/","text":"React相关-整理中 在props里使用 onClick={ this.handleClick.bind(this) }或者 onClick={ (e) =&gt; this.handleClick(e) }或者 onClick={ ::this.handleClick }都会产生性能问题，所以现在eslint在语法检查时就会阻止这几种写法，问题原因是每一次render的时候如果遇到这些写法，都会重新用handleClick函数与this去绑定从而重新创建一个新的函数，影响性能。如果使用下面的写法则不会每次都创建：// 1.constructor() {this.handleClick = this.handleClick.bind(this);}handleClick(e) { / … / }// 2.handleClick = (e) =&gt; { / … / }; 箭头函数不能用？Parsing error: Unexpected token =babel-eslint","tags":[{"name":"react","slug":"react","permalink":"//blog.fenghou.site/tags/react/"}]},{"title":"webpack配置","date":"2016-12-16T11:05:13.000Z","path":"2016/12/16/2016-12-16-webpack/","text":"关于webpack的教程网上一抓一大把就不班门弄斧了这里只是总结一些webpack的实用配置以及个人心得 entry&amp;output12345678910111213141516171819202122232425262728293031323334353637383940414243444546enpty:&#123; index:'./index.js', more:['./more2.js','./more.js'], vendor: ['react', 'react-dom', 'react-router']&#125;putput:&#123; path:'./build', filename:'[name]-[id].js', publicPath:'/assets/', chunkFilename:'[name]-[chunkhash]'&#125;//[id], chunk的id//[name] ,chunk名//[hash], 编译哈希值//[chunkhash] , chunk的hash值 根据模块内容//output.publicPath：设置为想要的资源访问路径。//访问时，则需要通过类似http://localhost:8080/asstes/index-1.js来访问资源，//如果没有设置，则默认从站点根目录加载。//filename应该比较好理解，就是对应于entry里面生成出来的文件名。比如：&#123; entry: &#123; \"index\": \"pages/index.jsx\" &#125;, output: &#123; filename: \"[name].min.js\", chunkFilename: \"[name].min.js\" &#125;&#125;//生成出来的文件名为index.min.js。//chunkname我的理解是未被列在entry中，//却又需要被打包出来的文件命名配置。//什么场景需要呢？我们项目就遇到过，在按需加载（异步）模块的时候，//这样的文件是没有被列在entry中的，如使用CommonJS的方式异步加载模块：require.ensure([\"modules/tips.jsx\"], function(require) &#123; var a = require(\"modules/tips.jsx\"); // ...&#125;, 'tips');//异步加载的模块是要以文件形式加载哦，//所以这时生成的文件名是以chunkname配置的，//生成出的文件名就是tips.min.js。//（require.ensure() API的第三个参数是给这个模块命名，//否则 chunkFilename: \"[name].min.js\" 中的 [name] 是一个自动分配的、可读性很差的id，//这是我在文档很不起眼的地方788发现的。。。）new webpack.optimize.CommonsChunkPlugin(&#123; names: ['vendor'],&#125;) url-loader1234test: /\\.(gif|jpg|png)$/,loader: 'url-loader?limit=1024&amp;name=img/[name].[ext]'//小于1024字节 采用base64//大于1024字节 正常打包到output目录下img文件夹中 js-loader123456789101112131415161718192021222324252627282930//babel //配置 .babelrc //.rc run command 程序启动阶段被调用 //执行babal-loader时自动执行 &#123; \"presets\": [\"es2015\", \"stage-2\"], \"plugins\": [ \"transform-class-properties\", \"transform-runtime\" ] &#125; //webpack.config.js &#123; test: /\\.js$/, exclude: /node_modules/, loader:'babel' &#125;,//不使用.babelrc &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: &#123; presets: [\"es2015\", \"stage-2\"], plugins: [ \"transform-class-properties\", \"transform-runtime\" ] &#125; &#125;, vue-loader1234567891011121314151617181920&#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/,&#125;&#123; test:/\\.vue$/, loader:'vue',&#125;babel: &#123; presets: ['es2015'], plugins: [\"transform-class-properties\", \"transform-runtime\"]&#125;,vue:&#123; loaders:&#123; js:'babel', scss:['vue-style-loader','css','sass'].join('!') &#125;&#125;, css-loaderloader 采取管道流 1loader: ['style','css','scss'].join('!') 提取样式到单独文件插件 extract-text-webpack-plugin 123456789var ExtractTextPlugin = require('extract-text-webpack-plugin');&#123; test: /\\.(scss|sass|css)$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader')&#125;plugins: [ new ExtractTextPlugin('[name].css') //output目录下 ], css样式自动 fix插件 autoprefixer(postcss插件) 12345678910111213141516&#123; test: /\\.(scss|sass|css)$/, loader: ExtractTextPlugin.extract('style-loader', ['css-loader', 'postcss-loader']) &#125;const AUTOPREFIXER_BROWSERS = [ 'Android &gt;= 4', 'Chrome &gt;= 35', 'Firefox &gt;= 31', 'Explorer &gt;= 9', 'iOS &gt;= 7', 'Opera &gt;= 12', 'Safari &gt;= 7.1'] postcss: function() &#123; return [autoprefixer(&#123; browsers: AUTOPREFIXER_BROWSERS &#125;)]; &#125;, file-loader1234&#123; test: /\\.(woff|svg|eot|ttf).$/, loader: \"file-loader?name=fonts/[name].[ext]\"&#125; resolve123456789101112131415161718var moment = require('moment');//编译很慢 也就是说，请求的是 moment 的源码。//实际上，通过 NPM 安装 moment 的时候会同时安装 moment 的源码和压缩后的代码//var moment = require('moment/min/moment-with-locales.min.js');//只不过这样改，可读性会有所下降，//而且每一个用到 moment 的地方都得这么写。//另外，如果同样的问题出现在第三方模块中，修改别人代码就不那么方便了。//下面来看看用 Webpack 怎么解决这个问题。 resolve: &#123; alias: &#123; moment: \"moment/min/moment-with-locales.min.js\" &#125; &#125;//可以用 alias 指定从非npm引入的库，如jquery: path.resolve(__dirname, './bower_components/jquery/dist/jquery.js') ，这样在 import 时可以替换引用路径// require时省略的扩展名，如：require('app') 不需要app.jsextensions: ['','.js','.vue','.scss'], noParsemodule.noParse 是 webpack 的另一个很有用的配置项，如果你 确定一个模块中没有其它新的依赖 就可以配置这项，webpack 将不再扫描这个文件中的依赖。123module: &#123; noParse: [/moment-with-locales/] &#125; devtool通常，JavaScript的解释器会告诉你，第几行第几列代码出错。但是，这对于转换后的代码毫无用处。举例来说，jQuery 1.9压缩后只有3行，每行3万个字符，所有内部变量都改了名字。你看着报错信息，感到毫无头绪，根本不知道它所对应的原始位置。这就是Source map想要解决的问题。 1devtool: '#source-map' hot reload123456789101112//package.json\"scripts\": &#123; \"dev\": \"webpack-dev-server --devtool eval-source-map --progress --colors --hot --inline\", &#125;,--content-base 内容基本路径 不加默认当前目录--colors 输出加颜色path: \"./dist\",filename: \"[name].js\",publicPath: \"abababab\",publicPath 必须设置 这里设置什么名 html里引用就写什么名字&lt;script src=\"/abababab/main.js\"&gt;&lt;/script&gt;npm run dev webpack -w12345//webstrom 会在临时文件夹中创建一个文件用来保存(好像没有出发实际文件的变更)settingAppearance &amp; BehaviorSystem SettingsUse \"safe write\"(save changes to a temporary file first) 勾去掉","tags":[{"name":"webpack","slug":"webpack","permalink":"//blog.fenghou.site/tags/webpack/"}]},{"title":"学点运维，配个服务器","date":"2016-12-15T11:04:25.000Z","path":"2016/12/15/2016-12-15-aliyun-yunwei/","text":"前段时间和同事合租了一个阿里云服务器，60几块钱一个月。服务器上的资源环境很多都是他配的，作为前端，只是在上面放点静态的东西，也没太大兴趣在这方面去摸索然后这货今天离职了。 走之前，悠悠然发了我一个连接阿里云搞活动 服务器免费赠送6个月 果断入手(要买个9块钱的套餐)然后买域名解析DNS配nginx装git搭node 也算是小入门了 But 我想说的是作为一个开发人员and 一个合格的开发人员首先具备的应该是解决问题，查找问题的能力 而不是一有问题不假思索的问别人有时候多学一样本领,就早说一句求人的话 作为我们作为初学者总会碰到各种各样的问题那么，怎么解决？ 举个栗子linux git的安装 忽略前面下载解压过程 ./configure –prefix=/usr/local make &amp; make install 果断报错。。OK 下载各种依赖报错继续安装成功git –version嗯 有版本号easy嘛然后 来 git clone ..error:fatal: Unable to find remote helper for ‘https’又报错，奔溃 这是因为Git环境没有安装完全，需要重新安装 ./configure –prefix=/usr/local make all doc make install install-doc install-man install-html 继续 OK问题解决 1、查看当前git版本：git –version 查看最新版git：访问https://www.kernel.org/pub/software/scm/git/ 或者https://github.com/git/git/releases 2、官网下载： wget https://Github.com/Git/Git/archive/v2.11.0.tar.gz （建议本机迅雷下载rz到服务器,安装yum install lrzsz后rz即可） 解压：tar -zxvf git-2.11.0.tar.gz 3、cd git-2.11.0 4、移除旧版本git：yum remove git 5、make configure 如果报错/bin/sh: autoconf: command not found： 安装libtool即可：yum install install autoconf automake libtool 正常会打印：GEN configure 执行 6、./configure –prefix=/usr/local/git –with-iconv =/usr/local/lib（建议优先尝试后者） 或者 ./configure –prefix=/usr/local/git –with-iconv –with-curl –with-expat=/usr/local/lib（如果没有安装libiconv请自行安装） make &amp;&amp; make install ①如果报错：cache.h:40:18: fatal error: zlib.h: No such file or directory 安装zlib：yum install zlib、yum install zlib-devel ②如果报错：make[1]: *** [perl.mak] Error 2 安装：yum install perl-ExtUtils-MakeMaker package 7、echo “export PATH=$PATH:/usr/local/git/bin” &gt;&gt; /etc/bashrc 8、source /etc/bashrc 9、git –version 编译git时报错： zlib.h: No such file or directory 缺少 zlib的头文件， 开发包没装， yum install zlib （系统默认已经装上） yum install zlib-devel git clone时候提示fatal: Unable to find remote helper for ‘https’ yum install libcurl-devel 然后按照上诉步骤重新安装编译git即可 Linux安装git那么这解决问题的过程 就比解决问题来的跟有用前提是问题是你自己解决的","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"},{"name":"linux","slug":"linux","permalink":"//blog.fenghou.site/tags/linux/"}]},{"title":"In city","date":"2016-12-14T11:03:52.000Z","path":"2016/12/14/2016-12-14-incity/","text":"悠然随心随性随缘 杭州，省会美丽的西湖（我也只去过西湖。。）一年前，在这我开启了前端之旅 那谁说过，在风口，是只猪也能飞起来。何况是在杭州这样的互联网台风中。。 但是风过了，依然在飞的却是鹰 麻雀从不担心树枝会断因为他相信的不是树枝而是自己的翅膀 身处互联网大时代机会很多，机遇很多首先飞起来然后去充实自己不断学习不断进步 最后风即使过了我们也进化成了鹰","tags":[{"name":"随想","slug":"随想","permalink":"//blog.fenghou.site/tags/随想/"}]},{"title":"Node-Spider","date":"2016-12-13T11:03:06.000Z","path":"2016/12/13/2016-12-13-node-spider/","text":"Node学习入门，练习爬虫再适合不过了这里通过爬区某图片网站近(10万张图片)的例子，介绍爬虫的过程 爬虫分析设计抓取的是 ‘http://www.mzitu.com‘ 网站图片大致有五个类目每个类目下分页规则http://www.mzitu.com/类目/page/1http://www.mzitu.com/类目/page/2 每一个有25个专题专题详情页 http://www.mzitu.com/专题id专题详情页分页规则http://www.mzitu.com/专题id/1http://www.mzitu.com/专题id/2 因此第一次鉴于此 爬虫设计如下先获取单个类目下专题(图片和Id)专题图片根据 类目/当前page数/图片 路径保存将获取的id暂存知道获取完全部全部类目专题然后开始获取专题详情确定要获取的专题详情的所有分页数最后爬区所有分页数 用到的模块1234var superagent = require('superagent'); //请求封装模块var async = require('async'); //并发控制模块var cheerio = require('cheerio'); //抓取页面dom节点模块var fs = require(\"fs\"); 数据准备12345678var sUrl = 'http://www.mzitu.com'; //爬取目标var aItems = []; //单个类目下需要爬取的链接var aTagList = ['/','/xinggan','/japan','/taiwan','/mm']; //所有类目var aDirList = ['index','xinggan','japan','taiwan','mm']; //爬取存放路径var nCurrentTag = 0; //当前爬取类目var aIdList = []; //专题Idvar aNextPage = []; //专题详情var aNxtItems = []; //专题详情下需要爬区的链接 获取所有专题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120function start(page)&#123; superagent .get(page) .end(function (err, response) &#123; if (err) &#123; console.log(err.status); &#125; if (response.status === 200) &#123; var $ = cheerio.load(response.text); &#125; var nPageLen = $('.nav-links a.next').prev().text(); // 获取页数 for(var i = 0;i &lt; nPageLen ;i++)&#123; aItems.push(page+'/page/'+(i+1)); &#125; var sName = page.replace('http://www.mzitu.com',''); sName = sName ? sName : 'index'; // 新建类目 存放目录 fs.mkdir(__dirname+'/uploa/'+sName.replace('/',''),function(err)&#123; if(err)&#123; throw err &#125; &#125;) fetchPage(); &#125;);&#125;function fetchPage()&#123; var concurrencyCount = 0; var fetchUrl = function(url,callback)&#123; var fetchStart = new Date().getTime(); concurrencyCount++; console.log('并发数'+concurrencyCount+'====url:'+url); superagent.get(url) .end(function(err,res)&#123; if(err)&#123; // callback(err,url); // return next(err); &#125; var time = new Date().getTime() - fetchStart; // console.log('抓取'+url+'成功,耗时'+time) concurrencyCount--; if(res.status === 200)&#123; var $ = cheerio.load(res.text); &#125; //爬取数据处理 getDetail($,url,function(rs)&#123; // _html += rs; &#125;) callback(); &#125;) &#125; // 控制并发数 async.mapLimit(aItems,5,function(myUrl,callback)&#123; fetchUrl(myUrl,callback); &#125;,function(err,result)&#123; nCurrentTag++; if(nCurrentTag &lt; aTagList.length)&#123; // console.log('====================开始抓取下一个类目===================='); aItems = []; start(sUrl+aTagList[nCurrentTag]); &#125; else&#123; console.log('====================开始抓取详情页========================='); // getNextPage(); &#125; &#125;)&#125;function getDetail($,url,callback)&#123; //确定图片名称 var dirList = url.replace('http://www.mzitu.com/','').split('/'); var dirName = dirList[0]+'/'+dirList[1]+dirList[2]; if(dirList.length &lt; 3)&#123; dirName = 'index/'+dirList[0]+dirList[1]; &#125; var domItemA = $('#pins li a'); // 获取Id var domItem = $('#pins li a img'); //获取图片 var srcList = [] domItem.each(function(idx,element)&#123; var $ele = $(element); var src = $ele.attr('data-original'); var id = $ele.parent().attr('href').replace('http://www.mzitu.com/',''); aSrcList.push(src); aIdList.push(id); &#125;) // 下载专题图片 downImg(aSrcList,dirName);&#125;function downImg(list,dirName)&#123; fs.mkdir(__dirname+'/upload/'+dirName,function(err)&#123; if(err)&#123; throw err &#125; &#125;) var savePath = __dirname+'/uploa/'+dirName+'/' + narr[0] +'_'+ narr[1] + '_' + narr[2]; function binaryParser(res, callback) &#123; res.setEncoding('binary'); var imgData = ''; res.on('data', function (chunk) &#123; imgData += chunk; &#125;); res.on('end', function () &#123; fs.writeFile(savePath, new Buffer(imgData, 'binary'),function(err) &#123; if(err) &#123; console.log(err); &#125; console.log(url+'下载成功') &#125;); &#125;); &#125; var downUrl = function(url,callback)&#123; var narr = url.replace(\"http://i.meizitu.net/thumbs/\", \"\").split(\"/\") supergent.get(url) // .pipe(fs.createWriteStream(savePath)) .parse(binaryParser) .end(function(err,res)&#123; &#125;) &#125; async.mapLimit(list,5,function(myUrl,callback)&#123; downUrl(myUrl,callback); &#125;,function(err,result)&#123;&#125;)&#125; 如何防止网站被爬虫爬取的几种办法","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"}]},{"title":"Node-server","date":"2016-12-13T11:02:26.000Z","path":"2016/12/13/2016-12-13-node-server/","text":"用Node搭建一个静态资源访问服务器 用到的模块 1234var http = require('http'), url = require('url'), path = require('path'), fs = require('fs'); 思路 获取访问路径，以文件后缀判断文件类型12345678910111213var mimetype = &#123; 'txt': 'text/plain', 'html': 'text/html', 'css': 'text/css', 'xml': 'application/xml', 'json': 'application/json', 'js': 'application/javascript', 'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'gif': 'image/gif', 'png': 'image/png', 'svg': 'image/svg+xml'&#125; 获取请求的时候判断请求文件是否存在，决定返回的类型 123456789101112131415161718192021222324http.createServer(function(req,res)&#123; var pathname = url.parse(req.url).pathname, realPath = path.join(__dirname,'/static',pathname); var body = []; req.on('data',function(data)&#123; body.push(data); &#125;) req.on('end',function()&#123; body = Buffer.concat(body); &#125;) fs.exists(realPath,function(ex)&#123; if(ex)&#123; var rs = fs.createReadStream(realPath); res.writeHead(200,&#123; 'Content-Type':mimetype[realPath.split('.').pop()] || 'text/plain' &#125;) rs.on('data',res.write.bind(res)) rs.on('close',res.end.bind(res)); &#125; else&#123; page_404(req,res,realPath); //错误页面 &#125; &#125;)&#125;).listen(3000) 请求不存在 1234567891011121314function page_404(req,res,path)&#123; res.writeHead(404,&#123; 'Content-Type':'text/html' &#125;) res.write('&lt;!doctype html&gt;\\n'); res.write('&lt;title&gt;404 Not Found&lt;/title&gt;\\n'); res.write('&lt;h1&gt;Not Found&lt;/h1&gt;'); res.write( '&lt;p&gt;The requested URL ' + path + ' was not found on this server.&lt;/p&gt;' ); res.end();&#125;","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"}]},{"title":"MarkDown语法","date":"2016-12-12T02:25:27.000Z","path":"2016/12/12/2016-12-12-md-rule/","text":"markdown 语法 AB 亮不亮 我的博客 ES JS JS1 数据结构 树 二叉树 平衡二叉树 满二叉树 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 加删除线像这样用： 删除这些 [x] 支持 @提到某人、#引用、链接、格式化 和 标签 等语法 [x] 需要使用列表语法来激活（无序或有序列表均可） [x] 这是一个已完成项目 [ ] 这是一个未完成项目","tags":[{"name":"markdown","slug":"markdown","permalink":"//blog.fenghou.site/tags/markdown/"}]}]