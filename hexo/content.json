[{"title":"谈谈js的继承","date":"2017-01-03T03:53:25.000Z","path":"2017/01/03/es5-es6-extends/","text":"js中的继承 apply&amp;&amp;call继承类式继承原型链继承Es6 extends","tags":[{"name":"Es6","slug":"Es6","permalink":"https://luyi10year.github.io/tags/Es6/"},{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"}]},{"title":"Js中的设计模式","date":"2017-01-01T10:09:48.000Z","path":"2017/01/01/js-design-patterns/","text":"","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"}]},{"title":"彻底理解Js中的作用域和上下文","date":"2016-12-30T10:06:06.000Z","path":"2016/12/30/es5-scope-closure/","text":"函数的每次调用都有与之紧密相关的作用域和上下文这俩者是完全不同的作用域(Scope) 是基于函数的作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的而上下文(Context)是基于对象的上下文始终是this关键字的值，它是拥有(控制)当前所执行代码的对象的引用。 作用域(Scope)首先只有函数具有作用域也就是说，在一个函数内部声明的变量在函数外部无法访问JavaScript的作用域是词法性质的这这意味着函数运行在定义它的作用域中而不是在调用它的作用域中12345678910function foo()&#123; var a = 10; function bar()&#123; a *= 2; return a; &#125; return bar;&#125;var baz = foo();baz(); //20 Es6之前 局部变量只能存在于函数体中Es6开始支持let声明变量 局部变量能存在于块级作用域通过var声明的变量会出现变量提升的问题 变量的 声明周期声明阶段(Declaration phase)初始化阶段(Initialization phase) 初始化阶段：variable = undefined赋值阶段(Assignment phase) 赋值阶段后：variable = ‘value’ var变量在函数作用域的开始位置就完成了声明阶段(variable)和初始化阶段(var variable)，这两个阶段之间没有任何间隙let变量通过声明阶段(foo)后，会进去暂时性死区，此时变量不可访问，直到初始化阶段(let foo)之后，变量才可以被访问所以变量提升是变量的耦合声明并且在作用域的顶部完成初始化然而let生命周期中将声明和初始化阶段解耦。这一解耦使 let 的变量提升现象消失。 上下文(Context)上下文通常取决于函数是如何被调用的123456789101112131415161718192021222324252627//当一个函数作为对象中的一个方法被调用的时候,this就设置为调用该方法的对象var foo = &#123; bar:function()&#123; console.log(this === foo) &#125;&#125;foo.bar() // true//当使用new操作符创造对象的实例时,函数的作用域内部this的值被设置为新创建的实例let aThis = [];function foo(x)&#123; this.x = x; aThis.push(this); console.log(this); //foo&#123;x:1&#125; //foo&#123;x:2&#125;&#125;foo.prototype.baz = function()&#123; console.log(this.x); //1 //2&#125;new foo(1);new foo(2);aThis.forEach(function(item)&#123; item.baz();&#125;) 执行环境(execution context)执行环境 定义了变量或函数有权访问的数据，决定它们各自的行为Js是单线程的，当JavaScript解释器初始化执行代码时，会默认进入全局执行环境此后函数的每次调用都会创建一个新的执行环境每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境会被推入一个环境栈中在函数执行完后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个便利的机制控制着执行环境可以分为创建和执行两个阶段。在创建阶段，解析器首先会创建一个变量对象（variable object，也称为活动对象 activation object），它由定义在执行环境中的变量、函数声明、和参数组成。在这个阶段，作用域链会被初始化， this 的值也会被最终确定。在执行阶段，代码被解释执行。 作用域链(scope chain)当代码在一个环境中执行时会创建变量对象的一个作用域链作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问作用域链包含了在环境栈中的每个执行环境对应的变量对象内部环境可以通过作用域链访问所有的外部环境但是外部环境不能访问内部环境中的任何变量和函数这些环境之间的联系是线性的、有次序的 闭包闭包是指有权访问另一函数作用域中的变量的函数在函数内定义一个嵌套的函数时，就构成了一个闭包它允许嵌套函数访问外层函数的变量通过返回嵌套函数，允许你维护对外部函数中局部变量、参数、和内函数声明的访问。12345678910111213141516171819202122232425262728293031323334353637383940414243444546//模块模式最流行的闭包类型之一，它允许你模拟公共的、私有的、和特权成员let Module = (function()&#123; var privateProperty = 'foo'; fucntion privateMethod()&#123; &#125; return &#123; publicProperty:'', publicMethod:function()&#123; &#125;, privilegedMethod: function()&#123; return privateMethod(arguments); &#125; &#125;&#125;)()//另一种类型的闭包被称为 立即执行的函数表达式(IIFE) Es5中(function(window)&#123; var foo, bar; function private()&#123; // do something &#125; var Module = &#123; public: function()&#123; // do something &#125; &#125;; window.Module = Module;&#125;)(this);//保护全局命名空间免受变量污染var baz;(function()&#123; var foo = 10; var bar = 2; baz = function()&#123; return foo * bar; &#125;&#125;)()baz(); //20//保护私用private变量 apply&amp;call&amp;bindapply和call内建在所有的函数中(它们是Function对象的原型方法)允许你在自定义上下文中执行函数不同点在于，call函数需要参数列表，而apply 函数需要你提供一个参数数组1234567891011121314151617181920//argumentsfunction foo()&#123; [].slice.apply(arguments); [].sort.apply(arguments,function(a,b)&#123; return a&gt;b; &#125;)&#125;//apply在传递参数时会将数组转变成列表集合//在一些只能处理列表的方法中可以巧妙地处理//求数组最大值let a = [1,2,3];Math.max(1,2,3); //3Math.max.apply(this,a); //3//两个数组合并let a = [1,2], b = [3,4];//a.push(b)//a [1,2,[3,4]];[].push.apply(a,b)//a [1,2,3,4]; 在ES5中引入了 Function.prototype.bind 方法，用于控制函数的执行上下文，它会返回一个新的函数，并且这个新函数会被永久的绑定到 bind 方法的第一个参数所指定的对象上，无论该函数被如何使用。1234567891011//低版本浏览器，我们可以简单的对它进行实现如下(polyfill)if(!('bind' in Function.prototype))&#123; Function.prototype.bind = function()&#123; var fn = this, context = arguments[0], args = Array.prototype.slice.call(arguments, 1); return function()&#123; return fn.apply(context, args.concat(arguments)); &#125; &#125;&#125; Es6箭头函数S6中的箭头函数可以作为 Function.prototype.bind() 的替代品。和普通函数不同，箭头函数没有它自己的this值，它的 this 值继承自外围作用域。12345678910111213141516171819202122232425var Obj = &#123; baz:.. foo:function()&#123; let self = this; [1,2,4,5].forEach(function(item)&#123; self.baz(item); &#125;) &#125;&#125;//Es5 bindvar Obj = &#123; baz:.. foo:function()&#123; [1,2,4,5].forEach(function(item)&#123; self.baz(item); &#125;.bind(this)) &#125;&#125;//Es6箭头函数var Obj = &#123; baz:.. foo:function()&#123; [1,2,4,5].forEach((item)=&gt;this.baz(item)) &#125;&#125;","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"}]},{"title":"ECMA-prototype","date":"2016-12-28T10:00:00.000Z","path":"2016/12/28/js-object-prototype/","text":"要学好Js，首先必须得先理解原型(prototype)why？js作为面向对象的语言，实现面向对象的机制就是原型！ 都说js中一切皆对象,那到底什么是对象呢？ 对象是属性的集合，并有一个原型对象。原型对象可以是空值。按宿主环境分可以分为原生对象：由ECMAScript规范定义其语义的对象内置对象：由ECMAScript实现提供，独立于宿主环境的对象，ECMAScript程序开始执行时就存在(所有内置对象是原生对象)宿主对象：由宿主环境提供的对象，用于完善ECMAScript执行环境(DOM,BOM)按功能分可以分为：普通对象：无原型对象函数对象：有原型对象(函数对象的一个实例) 我们这里只关注函数对象那么到底什么是原型呢？123456789101112131415161718192021222324252627282930313233//凡是通过new Function() 创建的对象都是函数对象function Bar()&#123;&#125;var foo = function()&#123;&#125;var baz = new Function();//Bar foo baz 都是函数对象//原型对象本质是函数对象的一个实例function Bar()&#123;&#125;Bar.prototypevar temp = new Bar();Bar.prototype = temp;var temp = new Function();Function.prototype = temp//构造器：创建和初始化对象的函数对象(在原型对象prototype中,prototype.constructor)//原型对象prototype中都有个预定义的constructor属性，用来引用它的函数对象//每个由构造器创建的对象拥有一个执行构造器prototype的属性值的隐式引用//这个引用称之为原型//每个原型可以拥有指向自己原型的隐式引用(原型的原型),就是所谓的原型链//每个对象都有一个__proto__属性来实现对原型的隐式引用function Person()&#123;&#125;Person.prototype = &#123; name:'Louis', age:'24'&#125;var person = new Person();person.__proto__ = Person.prototypePerson.prototype.__proto__ = Object.prototypeObject.prototype.__proto__ = null//person对象由构造器Person创建//所以person对Person.prototype有隐式引用(__proto__)//Person对象又是由构造器Object创建//所以Person对Object.prototype有隐式引用(__proto__)","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"},{"name":"原型","slug":"原型","permalink":"https://luyi10year.github.io/tags/原型/"}]},{"title":"你真的学好Js了吗","date":"2016-12-27T02:48:41.000Z","path":"2016/12/27/js-base/","text":"在我看来前端(Js)就好比是个剑客江湖江湖中有人练react宝典，有人练vue神功有人锻造webpack利剑…而Js就是这些的基础心法，决定这些宝典,神功最后在你手上的杀伤力那么作为最基础的心法，你真的参透的了吗？ 这里简单的记录些Js的一些特点 面向对象什么是面向对象 一切事物皆对象 对象具有封装和继承特性 对象与对象之间使用消息通信，各自存在信息隐藏 众所周知Java采用面向对象思想构造其语言，它实现了类、继承、多态、接口等机制。但是这些机制，只是实现面向对象编程的一种方式实际上，Js是通过原型的方式来实现面向对象编程的Js中的对象是依靠构造器(constructor)利用原型(prototype)构造出来的1234567891011121314151617//对象的声明//字面式对象声明var person = &#123; name:'Louis', age:'24'&#125;//使用函数构造器构造对象function Person()&#123;&#125;Person.prototype = &#123; name:'Louis', age:'24'&#125;var person = new Person();//这里的new关键字跟java中 的new毫无关系//只是借用了它的关键字new//用来表示调用构造器创建对象 弱类型语言在Js中，定义变量不必声明其类型。但这不意味着变量没有类型。原始类型：布尔型、数值型、字符串类型引用类型：对象类型(数组是一种特殊的对象)、函数类型其他类型：空类型和未定义类型js中的变量可以根据所附的值改变类型原始类型按值传送，在栈内存中存的是变量的值引用类型则按引用传送，在栈内存中存的是 引用对象在堆内存中的地址所以这里涉及到引用类型深拷贝和浅拷贝的问题1234567891011121314151617181920//浅拷贝 把父对象的属性全部拷贝给子对象//如果父元素的属性对应的值是引用类型，那子对象对应的属性的值还是引用类型的内存地址//这个时候就需要深拷贝function deepCopy(pre)&#123; var ch = pre.constructor === Array ? [] : &#123;&#125;; if(typeof pre !== 'object')&#123; ch = pre; &#125; else if(window.JSON)&#123; ch = JSON.parse(JSON.stringify(pre)) &#125; else&#123; for(var i in pre)&#123; ch[i] = typeof pre[i] === 'object' ? (pre[i].constructor === Array ? pre[i].slice() : deepCopy(pre[i])) : pre[i] &#125; &#125; return ch;&#125; 函数是一等对象在JavaScript中，函数是一等对象可以存储在变量中可以作为参数传给其他函数可以作为返回值从其他函数传出还可以在运行时进行构造可以用function(){…}这样的语法创建匿名函数12345(function()&#123; var foo = 20; var bar = 2; alert(foo*bar);&#125;)() 这个函数在定义后便会立即执行匿名函数可以用来创建闭包闭包是一个受到保护的变量空间由内嵌函数生成 对象的易变性JavaScript中,一切都是对象除了三种原始类型(布尔型、数值型、字符串类型)即便是这几种类型在必要时候也会被自动封装成对象而且所有对象都是易变的(mutable)12345678910111213141516171819202122232425262728//为函数添加属性function dispalyError(message)&#123; dispalyError.numTimesExecuted++; alert(message);&#125;dispalyError.numTimesExecuted = 0;//对定义的类和实例化的对象进行修改function Person(name,age)&#123; this.name = name; this.age = age;&#125;Person.prototype = &#123; getName:function()&#123; return this.name; &#125;, getAge:function()&#123; return this.age; &#125;&#125;var alice = new Person('Alice',39);var bill = new Person('Bill',20);Person.prototype.getGreeting = function()&#123; return 'Hi '+ this.getName()+'!';&#125;alice.displayGreeting = function()&#123; alert(this.getGreeting);&#125; 继承","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"}]},{"title":"Let Chat","date":"2016-12-26T04:20:16.000Z","path":"2016/12/26/websockt-chat-node/","text":"简易聊天 https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket","tags":[{"name":"Node","slug":"Node","permalink":"https://luyi10year.github.io/tags/Node/"},{"name":"websocket","slug":"websocket","permalink":"https://luyi10year.github.io/tags/websocket/"}]},{"title":"Git自动化部署","date":"2016-12-22T09:42:46.000Z","path":"2016/12/22/automated-deployment/","text":"每次更新完博客,得先push到github上然后在服务器上把代码pull下来部署 一开始 忍了后来 够了 (码字太累，来首震撼的歌) 整理一下需要的是本地push成功后服务器上能自动执行pull命令那么问题就变成了如何响应每次的push操作? WebHooksWebhook就是用户通过自定义回调函数的方式来改变Web应用的一种行为，这些回调函数可以由不是该Web应用官方的第三方用户或者开发人员来维护，修改。通过Webhook，你可以自定义一些行为通知到指定的URL去。 那么每次push时候接受到请求，然后执行pull脚本，问题就解决了 github配置github 支持webhook在github项目中选择settingwebhooksPayload URL 请求地址Content type 请求类型Secret 密文(请求之后用作校验) 请求处理通过node接受请求作出响应 1234567891011121314151617181920212223var http = require('http')var createHandler = require('github-webhook-handler')var handler = createHandler(&#123; path: '/deploy', secret: '' &#125;)http.createServer(function (req, res) &#123; handler(req, res, function (err) &#123; res.statusCode = 404 res.end('no such location') &#125;)&#125;).listen(8989)handler.on('error', function (err) &#123; console.error('Error:', err.message)&#125;)handler.on('push', function (event) &#123; // 调用pull脚本 process.exec('git pull origin master', function (error, stdout, stderr) &#123; if (error !== null) &#123; console.log('exec error: ' + error); &#125; &#125;);&#125;) 这个时候每次push的时候，会发送一个请求到 url:8989/deylop通过node 服务会作出相应操作 服务器部署nginx 方向代理将8989 代理到80端口12345678server &#123; listen 80; server_name ''; location /deploy &#123; proxy_pass http://localhost:8989; &#125; &#125; 通过forever 启动node 服务","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luyi10year.github.io/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"https://luyi10year.github.io/tags/Git/"},{"name":"服务器","slug":"服务器","permalink":"https://luyi10year.github.io/tags/服务器/"}]},{"title":"谈谈","date":"2016-12-20T06:29:27.000Z","path":"2016/12/20/diary-2016-1220-1430/","text":"","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://luyi10year.github.io/tags/杂谈/"}]},{"title":"1px != 1px -- 移动端适配浅析","date":"2016-12-19T09:28:08.000Z","path":"2016/12/19/rem-layout/","text":"css中我们一般使用px作为单位在pc上css中的1个像素往往对应着电脑屏幕中的1个物理像素这可能会给我们造成一个错觉css中的像素等于设备的物理像素但实际情况却并非如此css中的像素只是一个抽象的单位在不同的设备或不同的环境中css中的1px所代表的设备物理像素是不同的典型的就是retina屏 首先我们先了解几个概念 viewportviewport 是用户网页的可视区域pc中就是屏幕宽度移动设备中viewport(这个虚拟窗口)比屏幕宽 一般为9801234567891011&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;移动端布局viewport的宽度设为理想宽度layout viewport 默认的viewport 比屏幕宽 document.documentElement.clientWidthvisual viewport 浏览器可视区域的大小 window.innerWidthideal viewport 最适合移动设备的viewportwidth：控制 viewport 的大小，可以指定的一个值，如果 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。height：和 width 相对应，指定高度。initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。maximum-scale：允许用户缩放到的最大比例。minimum-scale：允许用户缩放到的最小比例。user-scalable：用户是否可以手动缩放。 物理像素(physical pixel)一个物理像素是显示器(手机屏幕)上最小的物理显示单元在操作系统的调度下每一个设备像素都有自己的颜色值和亮度值。 设备独立像素(density-independent pixel)设备独立像素(也叫密度无关像素)可以认为是计算机坐标系统中得一个点这个点代表一个可以由程序使用的虚拟像素(比如: css像素)简单点就是屏幕宽高 设备像素比(device pixel ratio)设备像素比 ＝ 物理像素 / 设备独立像素5,6的dpr=2，1个css像素等于2个物理像素6p的dpr=3,1个css像素等于3个物理像素 那首先我们在移动端布局，viewport肯定不能是默认的值最终viewport宽度等于应该等于设备的宽度我们的布局视图应该是 按照物理像素来布局设备独立像素可获得设备像素比 window.devicePixelRatio现在假设 在iphone6上布局 此时dpr = 2,dip = 375物理像素应该是 dpr * dip = 750div{ border-top:1px solid #000;}现在在页面上要实现一个1px的上边框由于移动端布局viewport缩成设备宽度而分辨率没有变所以这时的1px会有2px的效果 这个时候可以手动将viewport 宽度设成物理像素的宽度，然后将整个页面缩小 dpr 倍 1px 的问题解决了，那如何解决在不同手机显示设计稿中的一个100x100的div设计稿 750其中div 100x100750的设计稿对应的是iPhone6结合上面viewport的缩放div{ width:100px; height:100px;}在6上跟设计稿是完全相同的而在5(640)上会变大 这个时候可以通过rem在不同设备上动态计算出比例值 假设在750设计稿中 1rem = 100px那么在640设计稿中 1rem = 640/750*100px此时1rem 不管在5上还是6上显示都完全跟在设计稿中显示效果相同1234567891011121314//html&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;//动态计算remvar domDocEL = window.document.documentElement, mateViewPort = window.document.querySelector('meta[name=\"viewport\"]'), nBasePsdWidth = 750 / 100, nDpr = window.devicePixelRatio, nScale = 1 / nDpr, nLayout = domDocEL.clientWidth, nRem = nLayout * nDpr / nBasePsdWidth;domDocEL.style.fontSize = rem +'px';mateViewPort.setAttribute('content','width='+nDpr*nLayout+',initial-scale='+nScale+',maximum-scale='+nScale+',minimum-scale='+nScale+',user-scalable=no'); 对于字体可以用写个mixin方法根据不同的dpr设置字号12345@mixin px2rem($name,$px) &#123; [data-dpr=\"2\"] &amp; &#123; #&#123;$name&#125;: $px*2/2+px; &#125; &#125; 总结移动端布局将viewport设成物理像素的大小,然后在缩放为dpr的倒数倍。dpr不存在？简单点~~~那就指定为1！","tags":[{"name":"Rem","slug":"Rem","permalink":"https://luyi10year.github.io/tags/Rem/"},{"name":"H5","slug":"H5","permalink":"https://luyi10year.github.io/tags/H5/"}]},{"title":"react","date":"2016-12-18T05:50:35.000Z","path":"2016/12/18/react/","text":"整理整理思绪","tags":[{"name":"react","slug":"react","permalink":"https://luyi10year.github.io/tags/react/"}]},{"title":"vue","date":"2016-12-17T05:50:25.000Z","path":"2016/12/17/vue/","text":"整理整理思绪","tags":[{"name":"vue","slug":"vue","permalink":"https://luyi10year.github.io/tags/vue/"}]},{"title":"webpack","date":"2016-12-16T06:29:27.000Z","path":"2016/12/16/webpack/","text":"关于webpack的教程网上一抓一大把就不班门弄斧了这里只是总结一些webpack的实用配置以及个人心得 entry&amp;output12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849enpty:&#123; index:'./index.js', more:['./more2.js','./more.js'], vendor: ['react', 'react-dom', 'react-router']&#125;putput:&#123; path:'./build', filename:'[name]-[id].js', publicPath:'/assets/', chunkFilename:'[name]-[chunkhash]'&#125;//[id], chunk的id//[name] ,chunk名//[hash], 编译哈希值//[chunkhash] , chunk的hash值 根据模块内容//output.publicPath：设置为想要的资源访问路径。//访问时，则需要通过类似http://localhost:8080/asstes/index-1.js来访问资源，//如果没有设置，则默认从站点根目录加载。//filename应该比较好理解，就是对应于entry里面生成出来的文件名。比如：&#123; entry: &#123; \"index\": \"pages/index.jsx\" &#125;, output: &#123; filename: \"[name].min.js\", chunkFilename: \"[name].min.js\" &#125;&#125;//生成出来的文件名为index.min.js。//chunkname我的理解是未被列在entry中，//却又需要被打包出来的文件命名配置。//什么场景需要呢？我们项目就遇到过，在按需加载（异步）模块的时候，//这样的文件是没有被列在entry中的，如使用CommonJS的方式异步加载模块：require.ensure([\"modules/tips.jsx\"], function(require) &#123; var a = require(\"modules/tips.jsx\"); // ...&#125;, 'tips');//异步加载的模块是要以文件形式加载哦，//所以这时生成的文件名是以chunkname配置的，//生成出的文件名就是tips.min.js。//（require.ensure() API的第三个参数是给这个模块命名，//否则 chunkFilename: \"[name].min.js\" 中的 [name] 是一个自动分配的、可读性很差的id，//这是我在文档很不起眼的地方788发现的。。。）new webpack.optimize.CommonsChunkPlugin(&#123; names: ['vendor'],&#125;) url-loader1234test: /\\.(gif|jpg|png)$/,loader: 'url-loader?limit=1024&amp;name=img/[name].[ext]'//小于1024字节 采用base64//大于1024字节 正常打包到output目录下img文件夹中 js-loader1234567891011121314151617181920212223242526272829303132 //babel //配置 .babelrc //.rc run command 程序启动阶段被调用 //执行babal-loader时自动执行 &#123; \"presets\": [\"es2015\", \"stage-2\"], \"plugins\": [ \"transform-class-properties\", \"transform-runtime\" ] &#125; //webpack.config.js &#123; test: /\\.js$/, exclude: /node_modules/, loader:'babel' &#125;,//不使用.babelrc &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: &#123; presets: [\"es2015\", \"stage-2\"], plugins: [ \"transform-class-properties\", \"transform-runtime\" ] &#125; &#125;, vue-loader1234567891011121314151617181920&#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/,&#125;&#123; test:/\\.vue$/, loader:'vue',&#125;babel: &#123; presets: ['es2015'], plugins: [\"transform-class-properties\", \"transform-runtime\"]&#125;,vue:&#123; loaders:&#123; js:'babel', scss:['vue-style-loader','css','sass'].join('!') &#125;&#125;, css-loaderloader 采取管道流1loader: ['style','css','scss'].join('!') 提取样式到单独文件 插件 extract-text-webpack-plugin1234567891011var ExtractTextPlugin = require('extract-text-webpack-plugin');&#123; test: /\\.(scss|sass|css)$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader')&#125;plugins: [ new ExtractTextPlugin('[name].css') //output目录下 ], css样式自动 fix 插件 autoprefixer(postcss插件) 12345678910111213141516&#123; test: /\\.(scss|sass|css)$/, loader: ExtractTextPlugin.extract('style-loader', ['css-loader', 'postcss-loader']) &#125;const AUTOPREFIXER_BROWSERS = [ 'Android &gt;= 4', 'Chrome &gt;= 35', 'Firefox &gt;= 31', 'Explorer &gt;= 9', 'iOS &gt;= 7', 'Opera &gt;= 12', 'Safari &gt;= 7.1'] postcss: function() &#123; return [autoprefixer(&#123; browsers: AUTOPREFIXER_BROWSERS &#125;)]; &#125;, file-loader1234&#123; test: /\\.(woff|svg|eot|ttf).$/, loader: \"file-loader?name=fonts/[name].[ext]\"&#125; resolve12345678910111213141516171819var moment = require('moment');//编译很慢 也就是说，请求的是 moment 的源码。//实际上，通过 NPM 安装 moment 的时候会同时安装 moment 的源码和压缩后的代码//var moment = require('moment/min/moment-with-locales.min.js');//只不过这样改，可读性会有所下降，//而且每一个用到 moment 的地方都得这么写。//另外，如果同样的问题出现在第三方模块中，修改别人代码就不那么方便了。//下面来看看用 Webpack 怎么解决这个问题。 resolve: &#123; alias: &#123; moment: \"moment/min/moment-with-locales.min.js\" &#125; &#125;//可以用 alias 指定从非npm引入的库，如jquery: path.resolve(__dirname, './bower_components/jquery/dist/jquery.js') ，这样在 import 时可以替换引用路径// require时省略的扩展名，如：require('app') 不需要app.jsextensions: ['','.js','.vue','.scss'], noParsemodule.noParse 是 webpack 的另一个很有用的配置项，如果你 确定一个模块中没有其它新的依赖 就可以配置这项，webpack 将不再扫描这个文件中的依赖。123module: &#123; noParse: [/moment-with-locales/] &#125; devtool通常，JavaScript的解释器会告诉你，第几行第几列代码出错。但是，这对于转换后的代码毫无用处。举例来说，jQuery 1.9压缩后只有3行，每行3万个字符，所有内部变量都改了名字。你看着报错信息，感到毫无头绪，根本不知道它所对应的原始位置。这就是Source map想要解决的问题。1devtool: '#source-map' hot reload12345678910111213//package.json\"scripts\": &#123; \"dev\": \"webpack-dev-server --devtool eval-source-map --progress --colors --hot --inline\", &#125;,--content-base 内容基本路径 不加默认当前目录--colors 输出加颜色path: \"./dist\",filename: \"[name].js\",publicPath: \"abababab\",publicPath 必须设置 这里设置什么名 html里引用就写什么名字&lt;script src=\"/abababab/main.js\"&gt;&lt;/script&gt;npm run dev webpack -w12345//webstrom 会在临时文件夹中创建一个文件用来保存(好像没有出发实际文件的变更)settingAppearance &amp; BehaviorSystem SettingsUse \"safe write\"(save changes to a temporary file first) 勾去掉","tags":[{"name":"webpack","slug":"webpack","permalink":"https://luyi10year.github.io/tags/webpack/"}]},{"title":"学点运维，配个服务器","date":"2016-12-15T09:08:08.000Z","path":"2016/12/15/aliyun/","text":"前段时间和同事合租了一个阿里云服务器，60几块钱一个月。服务器上的资源环境很多都是他配的，作为前端，只是在上面放点静态的东西，也没太大兴趣在这方面去摸索然后这货今天离职了。 走之前，悠悠然发了我一个连接阿里云搞活动 传送门 服务器免费赠送6个月 果断入手(要买个9块钱的套餐) 然后买域名解析DNS配nginx装git搭node 也算是小入门了 But 我想说的是作为一个开发人员and 一个合格的开发人员首先具备的应该是解决问题，查找问题的能力 而不是一有问题不假思索的问别人有时候多学一样本领,就早说一句求人的话 作为我们作为初学者总会碰到各种各样的问题那么，怎么解决？ 举个栗子linux git的安装 忽略前面下载解压过程 ./configure –prefix=/usr/localmake &amp; make install 果断报错。。OK 下载各种依赖报错继续安装成功git –version嗯 有版本号easy嘛然后 来 git clone ..error:fatal: Unable to find remote helper for ‘https’又报错，奔溃 这是因为Git环境没有安装完全，需要重新安装 ./configure –prefix=/usr/localmake all docmake install install-doc install-man install-html 继续 OK问题解决 那么这解决问题的过程 就比解决问题来的跟有用前提是问题是你自己解决的","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luyi10year.github.io/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"https://luyi10year.github.io/tags/Git/"},{"name":"服务器","slug":"服务器","permalink":"https://luyi10year.github.io/tags/服务器/"}]},{"title":"In city","date":"2016-12-14T10:40:08.000Z","path":"2016/12/14/in-city/","text":"悠然随心随性随缘杭州，省会美丽的西湖（我也只去过西湖。。）一年前，在这我开启了前端之旅 那谁说过，在风口，是只猪也能飞起来。何况是在杭州这样的互联网台风中。。 但是风过了，依然在飞的却是鹰 麻雀从不担心树枝会断因为他相信的不是树枝而是自己的翅膀 身处互联网大时代机会很多，机遇很多首先飞起来然后去充实自己不断学习不断进步 最后风即使过了我们也进化成了鹰","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://luyi10year.github.io/tags/杂谈/"}]},{"title":"Node","date":"2016-12-13T10:41:55.000Z","path":"2016/12/13/node/","text":"NodeNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 哈哈 先占上到时候再补","tags":[{"name":"Node","slug":"Node","permalink":"https://luyi10year.github.io/tags/Node/"}]}]