[{"title":"canvas 图片裁剪","date":"2017-10-10T08:50:07.000Z","path":"2017/10/10/2017-10-10-canvas-clip-image/","text":"心血来潮想实现一个图片编辑器 需求实现图片根据选择区域裁剪选择区域大小可以拖动改变 实现思路 裁切drawImage(image,x,y,w,h,_x,_y,_w,_h) x 裁切图片中x坐标y 裁切图片中y坐标w 裁切图片中的宽h 裁切图片中的高_x canvas中显示的x坐标_y canvas中显示的y坐标_w canvas中显示的宽_h canvas中显示的高 所以思路是 在图片上显示一个选择区域 可以拖动 获取相对于图片的位置 在canvas中加载图片 拉伸大小 宽度拉伸 可以通过在选择区域中绝对定位一个元素来模拟边框 监听它上面的move事件来处理 旋转 通过控制Img旋转来控制一开始的想法是通过旋转选择区域来选取，但这样选择区域的获取图片数据会很繁琐而且意义不大旋转通过样式transform:rotate(0deg)在js获取样式时 要通过getComputedStyle这个API来获取12345var clipV = window.getComputedStyle(clip,null)var clipTrans = clip.getPropertyValue('transform')// or var clipTrans = clip.transform// 这时候获取的是一个二维矩阵// 型如 matrix(20, 10, 10, 10, 0, 0) 关于matrix matrix(a,b,c,d,e,f)e,f 控制 x, y轴的偏移位置 a,b,c,d 控制旋转 旋转的角度(θ) matrix(cosθ,sinθ,-sinθ,cosθ,0,0) 角度计算 angle = Math.round(Math.atan2(b, a) (180 / Math.PI))缩放计算有旋转时x轴缩放 scaleX = Math.sqrt(a a + b b)y轴缩放 scaleY = Math.sqrt(c c + d * d)无旋转时x轴缩放 scaleX = ay轴缩放 scaleY = b matrix(1,tan(θy),tan(θx),1,0,0)拉伸计算x轴拉伸角度 skewX = Math.atan(c)y轴拉伸角度 skewX = Math.atan(b) css动画界三巨头 transform transitions animation举个例子王者农药 新出一个英雄 浪一技能(transition) 标记敌人 设置过度效果二技能(transform) 命中敌人 变化敌人三技能(animation) 命中目标 设置过度效果 变化敌人并带有过度效果(只产生效果)被动(style.) 二技能命中标记一技能的目标 会使二技能有过度效果；普攻第三次 变化敌人 硝烟弥漫的峡谷中 刚刚结束一场战斗 我方四名英雄死于敌方小兵之手这时。。。我方浪出现在中路 对线敌方诸葛亮 李白 红蓝双buff在手一技能 成功标记诸葛亮(李白逃脱) transition:transform 100ms linear反手 一个二技能 transform:translate(0px,100px)(移动到我方中路一塔下) 命中对方诸葛亮 和 李白李白唰一下出现在我方塔下(效果如闪现) 诸葛亮也慢跑到塔下…浪 double kill对面鲁班 苏烈过来支援 反手一个 大招 animation:scale_leg(腿缩短至十分之一) 100ms 4 alternate linear只见 鲁班 苏烈一会变高 一会变矮 …浪 quadra kill木兰从草丛杀出 一技能 怼脸上 transition:display 100ms linear 蓝条空了普攻 普攻 丝血 闪现接普攻 触发被动缓缓的消失吧，木兰！！ document.querySelector(‘花木兰’).style.display = ‘none’浪 penta kill 总结css相关的还是要经常温故温故 不然真的容易忘了","tags":[{"name":"canvas","slug":"canvas","permalink":"//blog.fenghou.site/tags/canvas/"}]},{"title":"Js类型","date":"2017-09-19T02:02:58.000Z","path":"2017/09/19/2017-09-19-js-input-check/","text":"","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"Node-Session","date":"2017-08-20T02:20:32.000Z","path":"2017/08/20/2017-08-20-node-session-cookie/","text":"","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"},{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"Linux 使用 Mysql","date":"2017-08-18T02:20:08.000Z","path":"2017/08/18/2017-08-18-linux-mysql/","text":"","tags":[{"name":"linux","slug":"linux","permalink":"//blog.fenghou.site/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"//blog.fenghou.site/tags/mysql/"}]},{"title":"Js异步编程","date":"2017-08-02T02:19:25.000Z","path":"2017/08/02/2017-08-02-js-promise/","text":"","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"Vue事件","date":"2017-07-20T02:18:56.000Z","path":"2017/07/20/2017-07-20-vue-event/","text":"vue 中通过[$on]注册事件[$emit]来触发事件这里来模拟一下它内部的实现机制超简易 初始化Vue123456789function V()&#123; this._init()&#125;function initMixin(v)&#123; v.prototype._init = function()&#123; initEvent(this) &#125;&#125;initMixin(V) 初始化事件123function initEvent(v)&#123; v._events = Object.create(null)&#125; 混合事件123456789101112131415161718192021function eventsMixin(v)&#123; v.prototype.$on = function(name,fn)&#123; this._events[name] = fn &#125; v.prototype.$emit = function(event)&#123; let cbs = this._events[event] let args = toArray(arguments,1) cbs.apply(this,args) &#125;&#125;eventsMixin(V)function toArray (list, start) &#123; start = start || 0 let i = list.length - start const ret = new Array(i) while (i--) &#123; ret[i] = list[i + start] &#125; return ret&#125; 调用12345var v = new V()v.$on('click',function(msg)&#123; console.log(msg)&#125;)v.$emit('click','emit')","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"},{"name":"vue","slug":"vue","permalink":"//blog.fenghou.site/tags/vue/"}]},{"title":"Nginx配置https","date":"2017-07-12T09:40:27.000Z","path":"2017/07/12/2017-07-12-nginx-ssl/","text":"最近刚续费阿里云服务器，肉疼中。。。今天先尝试了下 把http改成https 在这里记录一下 Http和Https关于http和https的差别 就不说了反正不是只多了个s就对了~~ Linux中配置nginx服务器上的项目是通过nginx跑起来的所以主要还是围绕着nginx配置展开 ssl on ;我服务器上nginx配置编译的时候没有把ssl的模块编译进去所以在这里报了缺少ssl指令的错误 so 需要重新编译nginx找到nginx下载目录 没了就就重新下~~ ./configure –with-http_ssl_module很好 如果服务器上面已经安装了openssl 那么基本可以编译通过yum install openssl openssl-devel恩 如果编译的时候没有加载默认的 那么就需要手动配置./configure –with-http_ssl_module –with-openssl=/usr/bin/openssl敲黑板 这么写 编译的时候openssl会去从–with-openssl 那里取所以这里必须是源码目录 不应该安装目录 补充：填了安装目录 编译失败 竟然也找到了编译通过的方法。。修改方法12345678910# vi auto/lib/openssl/confCORE_INCS=\"$CORE_INCS $OPENSSL/openssl/include\"CORE_DEPS=\"$CORE_DEPS $OPENSSL/openssl/include/openssl/ssl.h\"CORE_LIBS=\"$CORE_LIBS $OPENSSL/openssl/lib/libssl.a\"CORE_LIBS=\"$CORE_LIBS $OPENSSL/openssl/lib/libcrypto.a\"改为：CORE_INCS=\"$CORE_INCS $OPENSSL/include\"CORE_DEPS=\"$CORE_DEPS $OPENSSL/include/openssl/ssl.h\"CORE_LIBS=\"$CORE_LIBS $OPENSSL/lib/libssl.a\"CORE_LIBS=\"$CORE_LIBS $OPENSSL/lib/libcrypto.a\" 但是 make 的时候还是会报错 so~~ make 打包成功后会在nginx源码目录的objs下生成nginx cp objs/nginx nginx配置目录/sbin拷贝覆盖 即可 然后配置12345678listen 443;ssl on;ssl_certificate /---------------------.pem;ssl_certificate_key /-----------------.key;ssl_session_timeout 5m;ssl_ciphers -----------------------------------------------;ssl_protocols ------------------------;ssl_prefer_server_ciphers on; 配置ssl证书 基本就ok了 sbin/nginx -t nginx: [emerg] getpwnam(“www”) failed 错误的原因是没有创建www这个用户 解决办法 1 在nginx.conf中 把user nobody的注释去掉既可2 /usr/sbin/groupadd -f www /usr/sbin/useradd -g www www 关于证书生成步骤 百度。。。 startSSL 注册申请 生成ctr…捣腾许久 终于配置成功 微信打开失败 不被认证 Symantec Ltd 在阿里云 免费申请ssl证书nginx如果配置是全局httpsbut 受认证只能是 申请ssl时填写的域名xx.xx 申请xx.xx.xx 不被认证 结论不想搞运维的前端不是个好架构 补充今天下班 被分配到 小黑屋封闭开发没空调。。产品大哥 搞了3个立体风扇 设计了一套 小黑屋空气交换系统 棒！but 网慢的代码都提交不了 是什么鬼","tags":[{"name":"nginx","slug":"nginx","permalink":"//blog.fenghou.site/tags/nginx/"},{"name":"https","slug":"https","permalink":"//blog.fenghou.site/tags/https/"}]},{"title":"谈谈我的vue项目架构","date":"2017-06-25T12:17:35.000Z","path":"2017/06/25/2017-06-25-vue-modules/","text":"私人文章–暂无阅读权限","tags":[{"name":"vue","slug":"vue","permalink":"//blog.fenghou.site/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"//blog.fenghou.site/tags/vuex/"}]},{"title":"Node网易云音乐API","date":"2017-06-20T08:30:19.000Z","path":"2017/06/20/2017-06-20-node-simple-netease-cloud-music/","text":"私人文章–暂无阅读权限","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"}]},{"title":"谈前端的请求","date":"2017-05-17T03:28:09.000Z","path":"2017/05/17/2017-05-17-content-type/","text":"私人文章–暂无阅读权限","tags":[{"name":"http","slug":"http","permalink":"//blog.fenghou.site/tags/http/"}]},{"title":"浅析vue数据响应","date":"2017-04-15T12:16:29.000Z","path":"2017/04/15/2017-04-15-vue-observe-watch/","text":"私人文章–暂无阅读权限","tags":[{"name":"vue","slug":"vue","permalink":"//blog.fenghou.site/tags/vue/"}]},{"title":"Nginx在前端","date":"2017-03-31T01:55:58.000Z","path":"2017/03/31/2017-03-31-nginx-proxy-vue/","text":"私人文章–暂无阅读权限","tags":[{"name":"nginx","slug":"nginx","permalink":"//blog.fenghou.site/tags/nginx/"}]},{"title":"骗到手的第八年@陈妞妞@我才是香坊大呲花","date":"2017-03-23T02:22:59.000Z","path":"2017/03/23/2017-03-23-love/","text":"八年九十六个月两千九百二十二天 那会还很瘦的陈妞妞(当然现在也不怎么胖) (是的，陈妞妞现在的形象) 当陈妞妞意识到自己变胖了以后深深的自责，忏悔着but~~ 高中那会我跟陈妞妞说你负责貌美如花我负责赚钱养家 (I Love You) 现在我正在努力陈妞妞不仅仅是花还兼职当上了小仙女~~~ 多年后幼儿园很多小朋友争得面红耳赤“我妈是老师！”“我爸是警察！”“我爸是局长！” 而我家小孩 云淡风轻 一脸不屑“呵，我妈可是仙女！” (该打赏打赏，都别客气)","tags":[{"name":"随笔","slug":"随笔","permalink":"//blog.fenghou.site/tags/随笔/"}]},{"title":"此去经年@我才是香坊大呲花","date":"2017-03-22T06:05:31.000Z","path":"2017/03/22/2017-03-21-diary/","text":"昨天跟同事一起去打球还没开始打，热身阶段投了会儿球完了，跟跑完1000米一样一样的后来还硬是打了快俩小时今天全身酸爽的不行连走路都走不顺 唉 老是真的老了想想上次打球还是去年毕业前最后的寝室南北对抗赛 (拍照那小子，问什么不把我照进去) 那会虽然体重跟现在差了略微几斤但是照样能跑能跳 大学不是一点儿好处没有它能洗去人的浮华同时让人意志消磨多愁善感酒量大增(有吗) 真正的成长或许就是你开始低下了头无论在行走还是坐着的时候当头颅微微低下成为你日常生活中的主要姿势你就真的长大了总仰着脑袋的一定小屁孩以为自己很牛x其实差远了","tags":[{"name":"随想","slug":"随想","permalink":"//blog.fenghou.site/tags/随想/"},{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"基于Vue的CPS后台","date":"2017-02-27T11:17:43.000Z","path":"2017/02/27/2017-02-27-基于Vue的CPS后台/","text":"上周结束了在想去的最后一个项目公众号联盟的推广后台 技术栈vue应该不需要介绍vuex巴拉巴拉巴拉vue-router。。。。webpack这次用的版本是2.x跟1.x的配置还是有点出入 实现将整个后台按功能抽离成单独的模块header 模块footer 模块menu 模块page 分页模块and 具体功能模块balabalabalabala~~~其实也没什么好说的。。。 坑还是有不少值得注意的地方的 路由切换中页面的刷新12345678//监听路由变化watch: &#123; '$route' (to, from) &#123; if (to.fullPath !== from.fullPath) &#123; this.pageInt() // 刷新处理 &#125; &#125; &#125; store交互数据的延迟1234567891011121314151617181920212223242526272829303132333435363738394041//返回异步操作//actionsgetOrder (&#123;commit&#125;, data) &#123; const opts = &#123; type: 'POST', url: '/union/order/list', data: data &#125; return fetchLoading(commit, 'SET_ORDER', opts)&#125;const fetchLoading = (commit, fn, opts) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; beginLoading(commit) Util.fetch(opts) .then(response =&gt; &#123; stopLoading(commit) if (fn) &#123; commit(fn, response) resolve() &#125; else &#123; resolve(response) &#125; &#125;, error =&gt; &#123; stopLoading(commit) const config = &#123; isShow: true, isToast: true, toastConfig: &#123; toastMsg: '系统繁忙,请稍后再试' &#125; &#125; commit('SET_POP', config) console.error(error) &#125;) &#125;)&#125;//模块中调用actions中方法this.getOrder(opts) .then(() =&gt; &#123; this.getPaging(opts) &#125;) 总结估计这周就离职了额，就这样吧","tags":[{"name":"webpack","slug":"webpack","permalink":"//blog.fenghou.site/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"//blog.fenghou.site/tags/vue/"},{"name":"es6","slug":"es6","permalink":"//blog.fenghou.site/tags/es6/"}]},{"title":"Weex","date":"2017-02-21T11:17:14.000Z","path":"2017/02/21/2017-02-21-Weex/","text":"我就是个标题","tags":[{"name":"weex","slug":"weex","permalink":"//blog.fenghou.site/tags/weex/"}]},{"title":"Rax","date":"2017-02-17T11:16:59.000Z","path":"2017/02/17/2017-02-17-Rax/","text":"我就是个标题","tags":[{"name":"rax","slug":"rax","permalink":"//blog.fenghou.site/tags/rax/"}]},{"title":"PReact","date":"2017-02-13T11:16:39.000Z","path":"2017/02/13/2017-02-13-PReact/","text":"我就是个标题","tags":[{"name":"PReact","slug":"PReact","permalink":"//blog.fenghou.site/tags/PReact/"}]},{"title":"wx签名出错-URL","date":"2017-02-13T11:16:16.000Z","path":"2017/02/13/2017-02-13-wx签名出错-URL/","text":"上周调试wx收货地址的时候碰到一个签名出错的问题invalid signature 前提为了增强用户体验在下单页选择收货地址的时候如果是微信用户新增添加微信地址的功能 思路调用wxAPI获取地址信息转换地址信息格式将新地址保存 注意点wx.openAddress方法中cancel回调是取消选项 wx地址选择中北京天津等自治区新增县选项北京市 北京市 朝阳区北京市 县 密云县 问题因为方便测试打开页面的方式都是通过打开指定连接的形式http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1一切OK但是从商品详情页进入在选择SKU下单的时候wx.openAddress会调用不了也就是 直接打开 http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1 正常先进商品详情页 ==&gt; http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1 异常invalid signature 解决直接打开链接wx浏览器会对url连接进行转码(encode)wx浏览器内部连接跳转不会对url进行转码处理 wx验证签名信息的时候会将当前页面的链接进行转码处理(encode) 所以直接打开 http://www.xiangqu.com/order/submit/view?skuMap[q90060] = 1wx的验证的URL = http://www.xiangqu.com/order/submit/view?skuMap%5Bq90060%5D=1服务端验证的URL = http://www.xiangqu.com/order/submit/view?skuMap%5Bq90060%5D=1 间接打开的 http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1wx的验证的URL = http://www.xiangqu.com/order/submit/view?skuMap%5Bq90060%5D=1服务端验证的URL = http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1 解决方法很简单在跳转的时候js先对链接进行转码 延伸在处理url编码问题的时候最好的方法就是Javascript先对URL进行编码不通过浏览器编码保证输出结果和服务器得到数据的一致","tags":[{"name":"wx","slug":"wx","permalink":"//blog.fenghou.site/tags/wx/"}]},{"title":"react-redux","date":"2017-02-05T11:15:42.000Z","path":"2017/02/05/2017-02-05-react-redux/","text":"我就是个标题","tags":[{"name":"react","slug":"react","permalink":"//blog.fenghou.site/tags/react/"}]},{"title":"react-flux","date":"2017-02-04T11:15:20.000Z","path":"2017/02/04/2017-02-04-react-flux/","text":"我就是个标题","tags":[{"name":"react","slug":"react","permalink":"//blog.fenghou.site/tags/react/"}]},{"title":"react-immutable","date":"2017-02-03T11:14:58.000Z","path":"2017/02/03/2017-02-03-react-immutable/","text":"我就是个标题","tags":[{"name":"react","slug":"react","permalink":"//blog.fenghou.site/tags/react/"}]},{"title":"Canvas--毛笔字书法","date":"2017-01-21T11:14:18.000Z","path":"2017/01/21/2017-01-21-Canvas毛笔字书法/","text":"继续Canvas这次记录移动端手写书法的实现 抛出问题canvas在移动端应用书法需要解决两个问题1.笔锋问题2.连贯问题 解决方案首先分析一下毛笔字是有笔锋的又粗有细有勾有钩通过点击时间长短决定画笔大小来模拟毛笔力度 通过touchmove事件获取连续移动的两个点计算两点间的直线距离通过循环在canvas画图 代码上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687let domCanvas = document.querySelector('#Calligraphy'), context = domCanvas.getContext('2d'), CONFIG = &#123; lineMin:8, lineMax:20, radius:0 &#125;; let Calligraphy = function()&#123; this.touchFlog = false; this.hasEvent = []; //move数组 this.upEvent = null; //当前操作 this.limitDis = 80; //移动最少距离 this.radius = CONFIG.radius; this.lineMin = CONFIG.lineMin; this.lineMax = CONFIG.lineMax; &#125; Calligraphy.prototype = &#123; start:function()&#123; //开始执行监听事件 this.bindEventDown = this.eventDown.bind(this); this.bindEventMove = this.eventMove.bind(this); this.bindEventUp= this.eventUp.bind(this); domCanvas.addEventListener('touchstart',this.eventDown) domCanvas.addEventListener('touchmove',this.bindEventMove) domCanvas.addEventListener('touchend',this.bindEventUp) &#125;, eventDown:function(e)&#123; console.log('Down') e.preventDefault(); let target = e.changedTouches[e.changedTouches.length-1]; this.touchFlog = true; this.hasEvent = []; // this.upEvent = this.getPoint(target); //当前操作 &#125;, eventMove:function(e)&#123; console.log('Move'); let target = e.changedTouches[e.changedTouches.length-1]; this.drawFont(this.getPoint(target)) &#125;, eventUp:function()&#123; console.log('Up'); e.preventDefault(); this.moveFlog = false; &#125;, drawFont:function(point)&#123; if(!this.touchFlog) return false; let moEvent = point, upEvent = this.upEvent, upRadius = this.radius, dis = 0, //连续点距离 time = 0; //时间 this.hasEvent.unshift(&#123;time:new Date().getTime(),dis:this.getDistance(upEvent,moEvent)&#125;); for (let n = 0; n &lt; this.hasEvent.length-1; n++) &#123; dis += this.hasEvent[n].dis; time += this.hasEvent[n].time-this.hasEvent[n+1].time; if (dis&gt;this.limitDis) break; &#125; let radius = Math.min(time/dis+this.lineMin,this.lineMax)/2; //计算这次画笔半径 this.radius = radius; this.upEvent = moEvent; let len = Math.round(this.hasEvent[0].dis/2)+1; //跟上次画笔半径渐变 for (let i = 0; i &lt; len; i++) &#123; let x = upEvent.x + (moEvent.x-upEvent.x)/len* i, y = upEvent.y + (moEvent.y-upEvent.y)/len* i, r = upRadius + (radius-upRadius)/len*i; context.beginPath(); context.arc(x,y,r,0,2*Math.PI,true); context.fill(); &#125; &#125;, getPoint:function()&#123; return &#123; x: e.clientX - domCanvas.offsetLeft + (document.body.scrollLeft || document.documentElement.scrollLeft), y: e.clientY - domCanvas.offsetTop + (document.body.scrollLeft || document.documentElement.scrollTop), &#125; &#125;, getDistance: function(pre,next)&#123; let x = next.x - pre.x, y = next.y - pre.y; return Math.sqrt(x*x + y*y); &#125; &#125; let calligrapgy = new Calligraphy(); calligrapgy.start();","tags":[{"name":"canvas","slug":"canvas","permalink":"//blog.fenghou.site/tags/canvas/"}]},{"title":"Canvas--黑凤梨","date":"2017-01-20T11:13:46.000Z","path":"2017/01/20/2017-01-20-Canvas黑凤梨/","text":"之前很火的黑凤梨生成性格图片相信大家印象深刻短时间拉了大量粉丝，同时自个儿也被微信封了我们公司当时也做了一个类似的活动想去治病！ 活动流程通过输入生日年月，确定星座每个新座对应几个不同的病症每个病症对应几段不同的文案和商品诊断结果可以分享 初步想法前端通过canvas实现结果图片通过toDataURL转成Image用微信浏览器自带保存图片功能 遇到的问题设计师希望采用第三方字体那显然在前端实现这有点坑用户流量中文不是就26个字母常用词汇加起来2500 大概7M左右这还是一种字体要实现设计稿要求至少需要三种字体 解决办法将字体资源放到服务器有服务端实现生成图片前端上传生成格式和内容 代码实现在代码实现上前端没有什么大问题主要是数据格式的规定上1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586let XZ = &#123; '1':&#123; division:19, items:['MJ','SP'] &#125;, '2':&#123; division:18, items:['SP','SY'] &#125;, '3':&#123; division:20, items:['SY','BY'] &#125;, '4':&#123; division:19, items:['BY','JN'] &#125;, '5':&#123; division:20, items:['JN','SdZ'] &#125;, '6':&#123; division:21, items:['SdZ','JX'] &#125;, '7':&#123; division:22, items:['JX','SlZ'] &#125;, '8':&#123; division:22, items:['SlZ','CN'] &#125;, '9':&#123; division:22, items:['CN','TC'] &#125;, '10':&#123; division:23, items:['TC','TX'] &#125;, '11':&#123; division:22, items:['TX','SS'] &#125;, '12':&#123; division:21, items:['SS','MJ'] &#125;&#125;//星座的判别let oXz = XZ[domInputMonth]; sXz = domInputDate &lt;= oXz.division ? oXz.item[0] : oXz.item[1];//病症描述的格式规定['$+@70@&amp;方正兰亭特黑简体&amp;**+$$+@50@&amp;方正兰亭特黑简体&amp;想发个朋友圈+$','结果..$+@50@&amp;方正兰亭特黑简体&amp;俩小时+$过去了...','还在$+@110@&amp;方正兰亭特黑简体&amp;选照片+$']文案分行采取数组形式$+ +$ 包含有特殊字体文本&amp; &amp; 特殊字体@ @ 字号** 替换文案(姓名)//生成文案在显示位置通过本地Canvas模拟生成的图片(字体用系统字体代替)context.ctx.font = nSize+'px arial';context.measureText(sContext).width 来获取长度通过指定宽度容器的比较获取x,y坐标//小技巧//数组的随机Array.prototype.shuffle = function(n)&#123; let len = this.length,num = n ? Math.min(n,len) : len,index, arr = this.slice(0),temp, lib = &#123;&#125;; lib.range = function(min,max)&#123; return min + Math.floor(Math.random()*(max-min+1)) &#125; for(let i =0;i&lt;len;i++)&#123; index = lib.range(i,len-1); temp = arr[i]; arr[i] = arr[index]; arr[index] = temp; &#125; return arr.slice(0,num); &#125;//两个数组的合并[a].concat([b]) 返回结果新数组[].push.apply([a],[b]);返回结果[a] 总结虽然好像跟canvas关系不大但是，好像也没有但是。。。","tags":[{"name":"canvas","slug":"canvas","permalink":"//blog.fenghou.site/tags/canvas/"}]},{"title":"Canvas--星空","date":"2017-01-19T11:13:18.000Z","path":"2017/01/19/2017-01-19-Canvas星空/","text":"Canvas 星空效果嗯 是的 就是左上方的星空效果 设计思路其实星空在实现上很简单一个星星就是一个星星对象实例有属性x坐标，y坐标，半径，移动速度和透明度有方法生成坐标，绘制星星 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&#123; /* * 配置选项 * width:画布宽 * height:画布高 * splitHeight:星星密集分割 * stars:星星数量 * maxStar:星星最大半径 * minStar:星星最小半径 * maxSpeed:星星最大移动速度 * minSpeed:星星最小移动速度 * */ let SkySetting = &#123; width:800, height:300, splitHeight:200, stars:400, maxStar:1.2, minStar:0.6, maxSpeed:0.1, minSpeed:0.02, &#125;, domCanvas = document.querySelector('#Star'), context = domCanvas.getContext('2d'); /* * 画布实例 * */ let starSky = function(width,height,stars)&#123; this.width = width; this.height = height; this.stars = stars; this.aStars = []; &#125; starSky.prototype = &#123; /* * 入口 * */ start:function()&#123; domCanvas.width = this.width; domCanvas.height = this.height; context.fillStyle = 'rgba(0,0,0,1)'; context.fillRect(0,0,this.width,this.height); this.render(); &#125;, /* * 重绘 * */ redraw:function()&#123; context.clearRect(0,0,this.width,this.height); context.fillStyle = 'rgba(0,0,0,1)'; context.fillRect(0,0,this.width,this.height); &#125;, /* * 新建星星实例 * 绘制星星 * window.requestAnimationFrame 动画函数 * */ render:function()&#123; this.redraw(); if(this.aStars.length &lt;= this.stars)&#123; let star = new Star(); this.aStars.push(star); &#125; this.aStars.forEach(function(star)&#123; star.draw(); &#125;) window.requestAnimationFrame(()=&gt;&#123; this.render(); &#125;); &#125;, &#125; /* * 星星构造器 * */ let Star = function()&#123; this.randomPoint(); &#125; Star.prototype = &#123; /* * 随机星星数据 * */ randomPoint:function()&#123; let _x = Math.random()*SkySetting.width, _r = SkySetting.minStar + Math.random()*(SkySetting.maxStar - SkySetting.minStar), _ran = Math.random()*10, _rx = Math.random()*(SkySetting.maxSpeed-SkySetting.minSpeed) + SkySetting.minSpeed, _y = _ran &gt; 2 ? Math.random()*SkySetting.splitHeight: Math.random()*SkySetting.height, _alphaMax = Math.random()*0.8 + 0.2, _alphaMin = 0.2, _alpha = 0; this.x = _x; this.y = _y; this.r = _r; this.rx = _rx; this.alpha = _alpha; this.alphaMax = _alphaMax; this.alphaMin = _alphaMin; this.alphaAction = true; &#125;, /* * 绘制星星 * 星星变化 * */ draw:function()&#123; this.x += this.rx; if(this.x + this.r &gt;= SkySetting.width)&#123; this.x = 0; &#125; if(this.alphaAction)&#123; if(this.alpha &lt; this.alphaMax)&#123; this.alpha += 0.05; &#125;else&#123; this.alphaAction = false &#125; &#125; if(!this.alphaAction)&#123; if(this.alpha &gt; this.alphaMin)&#123; this.alpha -= 0.02; &#125; else&#123; this.alphaAction = true; &#125; &#125; context.beginPath(); context.fillStyle = 'rgba(255,255,255,'+this.alpha.toString()+')'; context.arc(this.x,this.y,this.r,0,Math.PI*2,true); context.closePath(); context.fill(); &#125; &#125; /* * 构造星空实例 * */ let sky = new starSky(SkySetting.width,SkySetting.height,SkySetting.stars); sky.start(); &#125;","tags":[{"name":"canvas","slug":"canvas","permalink":"//blog.fenghou.site/tags/canvas/"}]},{"title":"Canvas--刮刮卡","date":"2017-01-18T11:12:27.000Z","path":"2017/01/18/2017-01-18-Canvas刮刮卡/","text":"到年底了，去回顾了下做过的项目发现有很多跟Canvas有关的这里简单记录一点心得方便日后查阅 一个模拟刮奖的活动设计思路获奖结果上实现一个遮层手指滑动位置遮层对应位置色值清空判断清空数据达到设定值，清除遮层 必备APIgetContext()getImageData() //获取画布像素数据 每个像素包含RGBA四个值fill() //填充rect() //矩形arc() //圆globalCompositeOperation //设置或返回如何将一个源（新的）图像绘制到目标（已有）的图像上 touch事件touchstarttouchmovetouchendchangedTouches:touchlist。对于 touchstart 事件, 这个 TouchList 对象列出在此次事件中新增加的触点对于 touchmove 事件，列出和上一次事件相比较，发生了变化的触点对于 touchend ，列出离开触摸平面的触点（这些触点对应已经不接触触摸平面的手指） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&#123; let domCanvas = document.querySelector('#GGL'), context = domCanvas.getContext('2d'); /* * 构建对象 * width * height * filter 取消遮罩百分比 * */ let clipImage = function(height,width,filter)&#123; this.width = width; this.height = height; this.filter = filter; domCanvas.width = this.width; domCanvas.height = this.height; &#125; clipImage.prototype = &#123; /* * 函数入口 * 开始监听事件 * */ start:function()&#123; context.fillStyle = 'gray'; context.fillRect(0,0,this.width,this.height); context.globalCompositeOperation = 'destination-out'; this.bindEventMove = this.eventMove.bind(this); this.bindEventUp= this.eventUp.bind(this); domCanvas.addEventListener('touchstart',this.eventDown) domCanvas.addEventListener('touchmove',this.bindEventMove) domCanvas.addEventListener('touchend',this.bindEventUp) &#125;, eventDown:function()&#123; console.log('Down') &#125;, eventMove:function(e)&#123; console.log('Move'); let target = e.changedTouches[e.changedTouches.length-1]; this.clearMove(target) &#125;, eventUp:function()&#123; console.log('Up'); this.clearMask(); &#125;, /* * 清除划过画布 * */ clearMove:function(target)&#123; let nX = target.clientX, nY = target.clientY; context.beginPath(); context.arc(nX,nY,15,0,Math.PI * 2); context.fill(); &#125;, /* * 判断像素点清除数是否到达指定百分比 * */ clearMask:function()&#123; let nNum = 0, aImageData = context.getImageData(0,0,this.width,this.height).data, nLength = aImageData.length; aImageData.forEach((item)=&gt;&#123; if(item == 0)&#123; nNum++; &#125; &#125;) if(nNum &gt;= nLength * this.filter)&#123; this.finish(); &#125; &#125;, /* * 完成刮奖 * */ finish:function()&#123; context.beginPath(); context.rect(0,0,this.width,this.height); context.fill(); domCanvas.removeEventListener('touchstart',this.eventDown); domCanvas.removeEventListener('touchmove',this.bindEventMove); domCanvas.removeEventListener('touchend',this.bindEventUp); &#125; &#125; let clip = new clipImage(400,400,.3); clip.start(); &#125;","tags":[{"name":"canvas","slug":"canvas","permalink":"//blog.fenghou.site/tags/canvas/"}]},{"title":"谈谈js的继承","date":"2017-01-03T11:11:44.000Z","path":"2017/01/03/2017-01-03-谈谈js的继承/","text":"继承在JavaScript中不像在别的面向对象语言中那样简单JavaScript使用的是基于对象的继承它可以用来模仿基于类的继承Es6中，新增了Class和extends关键字来支持类的继承在这里记录各种继承的实现方式 类式继承JavaScript对象可以模仿Java中的对象通过函数来声明类用关键字new来创建实例这种方式包括两个步骤1.用一个类的声明定义对象的结构2.实例化该类创建一个新对象123456789//类的实例function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(this.sName);&#125;;var Ls = new Person('Ls');Ls.sayName(); 这种类式继承的方式可以分为五种对象冒充，Call，Apply，原型链和混合模式 对象冒充构造函数使用 this 关键字给所有属性和方法赋值因为构造函数只是一个函数所以可使Person构造函数成为Author的方法，然后调用它Author就会收到Person的构造函数中定义的属性和方法123456789101112131415161718function Person(name)&#123; this.name = name; this.sayName=function()&#123; console.log(this.name); &#125; &#125;function Author(name,book)&#123; this.book = book; this.Person = Person; this.Person(name); delete this.Person; this.sayBook = function()&#123; console.log(this.book) &#125;&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook(); apply&amp;&amp;call继承call和apply方法通过改变函数上下文实现继承1234567891011121314151617function Person(name)&#123; this.name = name; this.sayName=function()&#123; console.log(this.name); &#125; &#125;function Author(name,book)&#123; this.book = book; Person.call(this,name); Person.apply(this,[name]); this.sayBook = function()&#123; console.log(this.book) &#125;&#125;var Ls = new Author('Ls','My Book'); Ls.sayName(); Ls.sayBook(); 原型链使子类原型对象指向父类的实例以实现继承,即重写类的原型对象1234567891011121314151617function Person()&#123;&#125;Person.prototype.sName = '';Person.prototype.sayName = function () &#123; console.log(this.sName);&#125;;function Author(book)&#123; this.book = book;&#125;Author.prototype = new Person();Author.prototype.sayBook= function()&#123; console.log(this.book);&#125;;var Ls = new Author('My book');Ls.sName = 'Ls';Ls.sayName();Ls.sayBook(); 这种模式无法使用带参数的构造函数，不支持多重继承 混合模式继承用对象冒充继承构造函数的属性，用原型链继承 prototype 对象的方法123456789101112131415161718function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(this.name);&#125;;function Author(name,book)&#123; Person.call(this,name); this.book = book;&#125;Author.prototype = new Person();Author.prototype.constructor = Author;Author.prototype.sayBook = function()&#123; console.log(this.book);&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook(); 为了简化类的声明，可以把派生子类的整个过程包装在一个名为extend的函数中空函数F，这样可以避免创建Person的新实例,因为它可能会比较庞大增加superclass这个属性弱化Author与Person之间的耦合并且确保constructor属性被正确设置123456789101112131415161718192021222324252627function extend(subClass.superClass)&#123; var F = function()&#123;&#125;; F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass; subClass.superclass = superClass.prototype; if(subClass.prototype.constructor == Object.prototype.constructor)&#123; subClass.prototype.constructor = subClass; &#125;&#125;function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(this.name);&#125;;function Author(name,book)&#123; Author.superclass.constructor.call(this,name); this.book = book;&#125;extend(Author,Person)Author.prototype.sayBook = function()&#123; console.log(this.book);&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook(); JavaScript中的类式继承仅仅是对正正基于类的继承的一种模仿 原型式继承原型式继承与类式继承截然不同它并不需要用类来定义对象结构，只需要创建一个对象这个对象可以被新的对象重用1234567891011121314151617181920212223var Person = &#123; name:'default name', sayName:function()&#123; console.log(this.name); &#125;&#125;var Author = clone(Person);Author.book = 'default book';Author.sayBook = function()&#123; console.log(this.book);&#125;var Ls = clone(Author);Ls.name = 'Ls';Ls.book = 'My Book';Ls.sayName();Ls.sayBook();//clone 通过把F的prototype属性设置为作为参数obj传去的原型对象//函数返回的结果是一个以给定对象为原型对象的空对象function clone(obj)&#123; function F()&#123;&#125; F.prototype = obj; return new F();&#125; Es6 extendsEs6中引入了Class 和extends关键字12345678910111213141516171819202122class Person&#123; constructor(name)&#123; this.name = name; &#125; sayName()&#123; console.log(this.name) &#125; &#125;class Author extends Person&#123; constructor(name,book)&#123; super(name); this.book = book; &#125; sayBook()&#123; console.log(this.book); &#125;&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook();Ls.__proto__ === Author.prototype; //trueAuthor.prototype.__proto__ === Person.prototype; //true","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"彻底理解Js中的作用域和上下文","date":"2016-12-30T11:11:06.000Z","path":"2016/12/30/2016-12-30-彻底理解Js中的作用域和上下文/","text":"函数的每次调用都有与之紧密相关的作用域和上下文这俩者是完全不同的作用域(Scope) 是基于函数的作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的而上下文(Context)是基于对象的上下文始终是this关键字的值，它是拥有(控制)当前所执行代码的对象的引用。 作用域(Scope)首先只有函数具有作用域也就是说，在一个函数内部声明的变量在函数外部无法访问JavaScript的作用域是词法性质的这这意味着函数运行在定义它的作用域中而不是在调用它的作用域中12345678910function foo()&#123; var a = 10; function bar()&#123; a *= 2; return a; &#125; return bar;&#125;var baz = foo();baz(); //20 Es6之前 局部变量只能存在于函数体中Es6开始支持let声明变量 局部变量能存在于块级作用域通过var声明的变量会出现变量提升的问题 变量的 声明周期 声明阶段(Declaration phase) 初始化阶段(Initialization phase) 初始化阶段：variable = undefined 赋值阶段(Assignment phase) 赋值阶段后：variable = ‘value’ var变量在函数作用域的开始位置就完成了声明阶段(variable)和初始化阶段(var variable)，这两个阶段之间没有任何间隙let变量通过声明阶段(foo)后，会进去暂时性死区，此时变量不可访问，直到初始化阶段(let foo)之后，变量才可以被访问所以变量提升是变量的耦合声明并且在作用域的顶部完成初始化然而let生命周期中将声明和初始化阶段解耦。这一解耦使 let 的变量提升现象消失。 上下文(Context)上下文通常取决于函数是如何被调用的1234567891011121314151617181920212223242526//当一个函数作为对象中的一个方法被调用的时候,this就设置为调用该方法的对象var foo = &#123; bar:function()&#123; console.log(this === foo) &#125;&#125;foo.bar() // true//当使用new操作符创造对象的实例时,函数的作用域内部this的值被设置为新创建的实例let aThis = [];function foo(x)&#123; this.x = x; aThis.push(this); console.log(this); //foo&#123;x:1&#125; //foo&#123;x:2&#125;&#125;foo.prototype.baz = function()&#123; console.log(this.x); //1 //2&#125;new foo(1);new foo(2);aThis.forEach(function(item)&#123; item.baz();&#125;) 执行环境(execution context)执行环境 定义了变量或函数有权访问的数据，决定它们各自的行为Js是单线程的，当JavaScript解释器初始化执行代码时，会默认进入全局执行环境此后函数的每次调用都会创建一个新的执行环境每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境会被推入一个环境栈中在函数执行完后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个便利的机制控制着执行环境可以分为创建和执行两个阶段。在创建阶段，解析器首先会创建一个变量对象（variable object，也称为活动对象 activation object），它由定义在执行环境中的变量、函数声明、和参数组成。在这个阶段，作用域链会被初始化， this 的值也会被最终确定。在执行阶段，代码被解释执行。 作用域链(scope chain)当代码在一个环境中执行时会创建变量对象的一个作用域链作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问作用域链包含了在环境栈中的每个执行环境对应的变量对象内部环境可以通过作用域链访问所有的外部环境但是外部环境不能访问内部环境中的任何变量和函数这些环境之间的联系是线性的、有次序的 闭包闭包是指有权访问另一函数作用域中的变量的函数在函数内定义一个嵌套的函数时，就构成了一个闭包它允许嵌套函数访问外层函数的变量通过返回嵌套函数，允许你维护对外部函数中局部变量、参数、和内函数声明的访问。1234567891011121314151617181920212223242526272829303132333435363738//模块模式最流行的闭包类型之一，它允许你模拟公共的、私有的、和特权成员let Module = (function()&#123; var privateProperty = 'foo'; fucntion privateMethod()&#123; &#125; return &#123; publicProperty:'', publicMethod:function()&#123; &#125;, privilegedMethod: function()&#123; return privateMethod(arguments); &#125; &#125;&#125;)()//另一种类型的闭包被称为 立即执行的函数表达式(IIFE) Es5中(function(window)&#123; var foo, bar; function private()&#123; // do something &#125; var Module = &#123; public: function()&#123; // do something &#125; &#125;; window.Module = Module;&#125;)(this);//保护全局命名空间免受变量污染var baz;(function()&#123; var foo = 10; var bar = 2; baz = function()&#123; return foo * bar; &#125;&#125;)()baz(); //20//保护私用private变量 apply&amp;call&amp;bindapply和call内建在所有的函数中(它们是Function对象的原型方法)允许你在自定义上下文中执行函数不同点在于，call函数需要参数列表，而apply 函数需要你提供一个参数数组 1234567891011121314151617181920//argumentsfunction foo()&#123; [].slice.apply(arguments); [].sort.apply(arguments,function(a,b)&#123; return a&gt;b; &#125;)&#125;//apply在传递参数时会将数组转变成列表集合//在一些只能处理列表的方法中可以巧妙地处理//求数组最大值let a = [1,2,3];Math.max(1,2,3); //3Math.max.apply(this,a); //3//两个数组合并let a = [1,2], b = [3,4];//a.push(b)//a [1,2,[3,4]];[].push.apply(a,b)//a [1,2,3,4]; 在ES5中引入了 Function.prototype.bind 方法，用于控制函数的执行上下文，它会返回一个新的函数，并且这个新函数会被永久的绑定到 bind 方法的第一个参数所指定的对象上，无论该函数被如何使用。 1234567891011//低版本浏览器，我们可以简单的对它进行实现如下(polyfill)if(!('bind' in Function.prototype))&#123; Function.prototype.bind = function()&#123; var fn = this, context = arguments[0], args = Array.prototype.slice.call(arguments, 1); return function()&#123; return fn.apply(context, args.concat(arguments)); &#125; &#125;&#125; Es6箭头函数S6中的箭头函数可以作为 Function.prototype.bind() 的替代品。和普通函数不同，箭头函数没有它自己的this值，它的 this 值继承自外围作用域。12345678910111213141516171819202122232425var Obj = &#123; baz:.. foo:function()&#123; let self = this; [1,2,4,5].forEach(function(item)&#123; self.baz(item); &#125;) &#125;&#125;//Es5 bindvar Obj = &#123; baz:.. foo:function()&#123; [1,2,4,5].forEach(function(item)&#123; self.baz(item); &#125;.bind(this)) &#125;&#125;//Es6箭头函数var Obj = &#123; baz:.. foo:function()&#123; [1,2,4,5].forEach((item)=&gt;this.baz(item)) &#125;&#125;","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"ECMA-prototype","date":"2016-12-28T11:09:23.000Z","path":"2016/12/28/2016-12-28-ECMA-prototype/","text":"要学好Js，首先必须得先理解原型(prototype)why？js作为面向对象的语言，实现面向对象的机制就是原型！都说js中一切皆对象,那到底什么是对象呢？ 对象是属性的集合，并有一个原型对象。原型对象可以是空值。 按宿主环境分可以分为 原生对象：由ECMAScript规范定义其语义的对象 内置对象：由ECMAScript实现提供，独立于宿主环境的对象，ECMAScript程序开始执行时就存在(所有内置对象是原生对象) 宿主对象：由宿主环境提供的对象，用于完善ECMAScript执行环境(DOM,BOM) 按功能分可以分为： 普通对象：无原型对象 函数对象：有原型对象(函数对象的一个实例) 我们这里只关注函数对象那么到底什么是原型呢？ 1234567891011121314151617181920212223242526272829303132//凡是通过new Function() 创建的对象都是函数对象function Bar()&#123;&#125;var foo = function()&#123;&#125;var baz = new Function();//Bar foo baz 都是函数对象//原型对象本质是函数对象的一个实例function Bar()&#123;&#125;Bar.prototypevar temp = new Bar();Bar.prototype = temp;var temp = new Function();Function.prototype = temp//构造器：创建和初始化对象的函数对象(在原型对象prototype中,prototype.constructor)//原型对象prototype中都有个预定义的constructor属性，用来引用它的函数对象//每个由构造器创建的对象拥有一个执行构造器prototype的属性值的隐式引用//这个引用称之为原型//每个原型可以拥有指向自己原型的隐式引用(原型的原型),就是所谓的原型链//每个对象都有一个__proto__属性来实现对原型的隐式引用function Person()&#123;&#125;Person.prototype = &#123; name:'Louis', age:'24'&#125;var person = new Person();person.__proto__ = Person.prototypePerson.prototype.__proto__ = Object.prototypeObject.prototype.__proto__ = null//person对象由构造器Person创建//所以person对Person.prototype有隐式引用(__proto__)//Person对象又是由构造器Object创建//所以Person对Object.prototype有隐式引用(__proto__)","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"你真的学好Js了吗","date":"2016-12-27T11:08:58.000Z","path":"2016/12/27/2016-12-27-你真的学好Js/","text":"在我看来前端(Js)就好比是个剑客江湖江湖中有人练react宝典，有人练vue神功有人锻造webpack利剑…而Js就是这些的基础心法，决定这些宝典,神功最后在你手上的杀伤力那么作为最基础的心法，你真的参透的了吗？ 这里简单的记录些Js的一些特点 面向对象什么是面向对象 一切事物皆对象对象具有封装和继承特性对象与对象之间使用消息通信，各自存在信息隐藏 众所周知Java采用面向对象思想构造其语言，它实现了类、继承、多态、接口等机制。但是这些机制，只是实现面向对象编程的一种方式实际上，Js是通过原型的方式来实现面向对象编程的Js中的对象是依靠构造器(constructor)利用原型(prototype)构造出来的 1234567891011121314151617//对象的声明//字面式对象声明var person = &#123; name:'Louis', age:'24'&#125;//使用函数构造器构造对象function Person()&#123;&#125;Person.prototype = &#123; name:'Louis', age:'24'&#125;var person = new Person();//这里的new关键字跟java中 的new毫无关系//只是借用了它的关键字new//用来表示调用构造器创建对象 弱类型语言在Js中，定义变量不必声明其类型。但这不意味着变量没有类型。原始类型：布尔型、数值型、字符串类型引用类型：对象类型(数组是一种特殊的对象)、函数类型其他类型：空类型和未定义类型js中的变量可以根据所附的值改变类型原始类型按值传送，在栈内存中存的是变量的值引用类型则按引用传送，在栈内存中存的是 引用对象在堆内存中的地址所以这里涉及到引用类型深拷贝和浅拷贝的问题 1234567891011121314151617181920//浅拷贝 把父对象的属性全部拷贝给子对象//如果父元素的属性对应的值是引用类型，那子对象对应的属性的值还是引用类型的内存地址//这个时候就需要深拷贝function deepCopy(pre)&#123; var ch = pre.constructor === Array ? [] : &#123;&#125;; if(typeof pre !== 'object')&#123; ch = pre; &#125; else if(window.JSON)&#123; ch = JSON.parse(JSON.stringify(pre)) &#125; else&#123; for(var i in pre)&#123; ch[i] = typeof pre[i] === 'object' ? (pre[i].constructor === Array ? pre[i].slice() : deepCopy(pre[i])) : pre[i] &#125; &#125; return ch;&#125; 函数是一等对象在JavaScript中，函数是一等对象可以存储在变量中可以作为参数传给其他函数可以作为返回值从其他函数传出还可以在运行时进行构造可以用function(){…}这样的语法创建匿名函数 12345(function()&#123; var foo = 20; var bar = 2; alert(foo*bar);&#125;)() 这个函数在定义后便会立即执行匿名函数可以用来创建闭包闭包是一个受到保护的变量空间由内嵌函数生成 对象的易变性JavaScript中,一切都是对象除了三种原始类型(布尔型、数值型、字符串类型)即便是这几种类型在必要时候也会被自动封装成对象而且所有对象都是易变的(mutable) 123456789101112131415161718192021222324252627//为函数添加属性function dispalyError(message)&#123; dispalyError.numTimesExecuted++; alert(message);&#125;dispalyError.numTimesExecuted = 0;//对定义的类和实例化的对象进行修改function Person(name,age)&#123; this.name = name; this.age = age;&#125;Person.prototype = &#123; getName:function()&#123; return this.name; &#125;, getAge:function()&#123; return this.age; &#125;&#125;var alice = new Person('Alice',39);var bill = new Person('Bill',20);Person.prototype.getGreeting = function()&#123; return 'Hi '+ this.getName()+'!';&#125;alice.displayGreeting = function()&#123; alert(this.getGreeting);&#125; 继承继承在JavaScript中不像在别的面向对象语言中那样简单JavaScript使用的是基于对象的继承它也可以用来模仿基于类的继承Es6中新增了extends实现继承后面会有文章相信讲讲继承","tags":[{"name":"js","slug":"js","permalink":"//blog.fenghou.site/tags/js/"}]},{"title":"从实时聊天谈谈通信协议","date":"2016-12-26T11:08:20.000Z","path":"2016/12/26/2016-12-26-实时聊天谈谈通信协议/","text":"作为前端开发人员了解前后端通信协议还是很必须的尤其是在用Node写服务端的时候对于请求的响应处理和返回有很大的帮助客户端与服务端的通信协议有HTTP(HTTPS)协议和WebSocket协议HTTP协议是无状态的，服务端进行处理返回response后很难主动向客户端发送数据WebSocket协议实现了客户端与服务端的全双工通信扩展了客户端与服务端的通信功能使服务端也能主动向客户端发送数据在WebSocket协议提出之前要实现即时通信、实时数据这样的功能，经常会使用轮询(polling)和Comet技术 轮询是最原始的实现实时Web应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。明显地，这种方法会导致过多不必要的请求，浪费流量和服务器资源 Comet技术又可以分为长轮询和流技术。长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个HTTP长连接，服务端会不断更新连接状态以保持HTTP长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。 WebSocket，真正实现了Web的实时通信 Http协议HTTP(Hypertext Transfer Protocol 超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议HTTP限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP的常用请求方法 GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 请求和响应都包含请求头或响应头header和可选的请求体或响应体Body(自由的文本) 只有POST请求包含一个Body Content-type常用的MiME类型 application/x-wwwform-urlencoded 经过编码的键值对请求字符串(Body)，web服务器需要解码字符串获得参数 text/xml,application/xml Body是XML文档 text/plain 普通文本 text/html, text/xhtml Body是(X)HTML内容，web服务器端发送的标准web页面或内容片段 text/javascript Body是一段JavaScript代码 image/png, image/jpeg, image/gif：Body是二进制图像 HTTPS协议HTTPS(Secure Hypertext Transfer Protocol 安全超文本传输协议)是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版。HTTP协议是不安全的，可以轻松对窃听你跟 Web 服务器之间的数据传输在很多情况下，客户和服务器之间传输的是敏感信息，需要防止未经授权的访问 HTTPS协议在TCP协议上加了层SSL协议 网络七层协议 应用层 Http Https 表示层 SSL TLS 会话层 传输层 TCP 网络层 IP 数据链路层 物理层 SSL 包含如下动作：1.验证服务器端2.允许客户端和服务器端选择加密算法和密码，确保双方都支持3.验证客户端(可选)4.使用公钥加密技术来生成共享加密数据5.创建一个加密的 SSL 连接6.基于该 SSL 连接传递 HTTP 请求 TCP协议TCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议连接时三次握手第一次Client端发送SYN报文请求连接第二次Server端接受连接后回复ACK报文，并且为这次连接分配资源第三次Client端接收ACK报文后向Server端发送ACK报文，并分配资源TCP连接建立 断开时四次握手第一次Client发起中断连接，发送FIN报文第二次Server端接到FIN报文后，发送ACK报文，(可能还有数据没有传输完)，Client进入FIN_WAIT状态第三次Server端确定数据已经发送完成，则向Client端发送FIN报文，准备好关闭连接第四次Client端接收FIN报文,知道可以关闭连接，但不相信网络,怕Server端不知道要关闭，发送ACK报文，并进入TIME_WAIT状态Server端收到ACK报文后断开连接Client端等待了一定时间(依赖实现方法)后，没有收到Server回复，表示Server端已正常关闭，Client端也关闭链接TCP连接关闭 AJAXAJAX (Asynchronous Javascript And XML 异步JavaScript和XML)，是指一种创建交互式网页应用的网页开发技术。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求* method：请求的类型；GET 或 POST* url：文件在服务器上的位置* async：true（异步）或 false（同步）** send(string) 将请求发送到服务器* string：仅用于 POST 请求** setRequestHeader(header,value) 向请求添加 HTTP 头* header: 规定头的名称* value: 规定头的值** responseText 获得字符串形式的响应数据。* responseXML 获得XML形式的响应数据。** onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数** readyState 存有 XMLHttpRequest 的状态 从 0 到 4 发生变化* 0: 请求未初始化* 1: 服务器连接已建立* 2: 请求已接收* 3: 请求处理中* 4: 请求已完成，且响应已就绪** status* 200: \"OK\"* 404: 未找到页面* */var xmlhttp = new XMLHttpRequest();xmlhttp.open('POST',url,true);xmlhttp.setRequestHeader('Content-type','application/x-www-form-urlencoded');xmlhttp.send('page=2&amp;size=10');xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.readystate == 4)&#123; if(xmlhttp.status == 200)&#123; console.log(xmlhttp.responseText); &#125; else&#123; //异常 &#125; &#125;&#125; websocketwebsocket协议本质上是一个基于TCP的协议是先通过HTTP/HTTPS协议发起一条特殊的HTTP请求进行握手后创建一个用于交换数据的TCP连接此后服务端与客户端通过此TCP连接进行实时通信 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//客户端var ws = new WebSocket('ws://localhost:8181/');//连接发生错误的回调方法ws.onerror = function()&#123;&#125;//websocket 在任何时候都会处于下面4种状态中的其中一种//CONNECTING (0) 表示还没建立连接//OPEN (1) 已经建立连接，可以进行通讯//CLOSING (2) 通过关闭握手，正在关闭连接//CLOSED (3) 连接已经关闭或无法打开//WebSocket.OPEN = 1;//连接成功建立的回调方法ws.onopen = function(e)&#123; if(ws.readyState === 1)&#123; wsSend('msg'); &#125;&#125;//接收到消息的回调方法ws.onmessage = function(e)&#123; //e.data&#125;//连接关闭的回调方法ws.onclose = function()&#123;&#125;function wsSend(rs)&#123; ws.send(rs);&#125;function wsEnd()&#123; ws.close();&#125;//服务端(Node)var WebSocketServer = require('ws').Server, ws = new WebSocketServer(&#123; port: 8181 &#125;), clients = [], clientNum = 0;ws.on('connection',function(ws)&#123; clientNum ++; clients.push(&#123;'ws':ws&#125;); ws.on('message',function(rs)&#123; wsSend(rs); &#125;)&#125;)function wsSend(rs)&#123; for(var i =0;i&lt;clients.length;i++)&#123; var clientSocket = clients[i].ws; if (clientSocket.readyState === 1) &#123; clientSocket.send(JSON.stringify(rs)); &#125; &#125;&#125;","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"},{"name":"http","slug":"http","permalink":"//blog.fenghou.site/tags/http/"},{"name":"websocket","slug":"websocket","permalink":"//blog.fenghou.site/tags/websocket/"}]},{"title":"Git自动化部署","date":"2016-12-22T11:07:31.000Z","path":"2016/12/22/2016-12-22-git自动化部署/","text":"每次更新完博客,得先push到github上然后在服务器上把代码pull下来部署 一开始 忍了后来 够了 整理一下需要的是本地push成功后服务器上能自动执行pull命令那么问题就变成了如何响应每次的push操作? WebHooksWebhook就是用户通过自定义回调函数的方式来改变Web应用的一种行为，这些回调函数可以由不是该Web应用官方的第三方用户或者开发人员来维护，修改。通过Webhook，你可以自定义一些行为通知到指定的URL去。 那么每次push时候接受到请求，然后执行pull脚本，问题就解决了 github配置github 支持webhook在github项目中选择settingwebhooksPayload URL 请求地址Content type 请求类型Secret 密文(请求之后用作校验) 请求处理通过node接受请求作出响应 1234567891011121314151617181920var http = require('http')var createHandler = require('github-webhook-handler')var handler = createHandler(&#123; path: '/deploy', secret: '' &#125;)http.createServer(function (req, res) &#123; handler(req, res, function (err) &#123; res.statusCode = 404 res.end('no such location') &#125;)&#125;).listen(8989)handler.on('error', function (err) &#123; console.error('Error:', err.message)&#125;)handler.on('push', function (event) &#123; // 调用pull脚本 process.exec('git pull origin master', function (error, stdout, stderr) &#123; if (error !== null) &#123; console.log('exec error: ' + error); &#125; &#125;);&#125;) 这个时候每次push的时候，会发送一个请求到 url:8989/deylop通过node 服务会作出相应操作 服务器部署nginx 方向代理将8989 代理到80端口 1234567server &#123; listen 80; server_name ''; location /deploy &#123; proxy_pass http://localhost:8989; &#125; &#125; 通过forever 启动node 服务","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"},{"name":"git","slug":"git","permalink":"//blog.fenghou.site/tags/git/"}]},{"title":"1px != 1px -- 移动端适配浅析","date":"2016-12-19T11:06:45.000Z","path":"2016/12/19/2016-12-19-移动端适配/","text":"css中我们一般使用px作为单位在pc上css中的1个像素往往对应着电脑屏幕中的1个物理像素这可能会给我们造成一个错觉css中的像素等于设备的物理像素但实际情况却并非如此css中的像素只是一个抽象的单位在不同的设备或不同的环境中css中的1px所代表的设备物理像素是不同的 典型的就是retina屏 首先我们先了解几个概念 viewportviewport 是用户网页的可视区域pc中就是屏幕宽度移动设备中viewport(这个虚拟窗口)比屏幕宽 一般为980 1234567891011&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;移动端布局viewport的宽度设为理想宽度layout viewport 默认的viewport 比屏幕宽 document.documentElement.clientWidthvisual viewport 浏览器可视区域的大小 window.innerWidthideal viewport 最适合移动设备的viewportwidth：控制 viewport 的大小，可以指定的一个值，如果 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。height：和 width 相对应，指定高度。initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。maximum-scale：允许用户缩放到的最大比例。minimum-scale：允许用户缩放到的最小比例。user-scalable：用户是否可以手动缩放。 物理像素(physical pixel)一个物理像素是显示器(手机屏幕)上最小的物理显示单元在操作系统的调度下每一个设备像素都有自己的颜色值和亮度值。 设备独立像素(density-independent pixel)设备独立像素(也叫密度无关像素)可以认为是计算机坐标系统中得一个点这个点代表一个可以由程序使用的虚拟像素(比如: css像素)简单点就是屏幕宽高 设备像素比(device pixel ratio)设备像素比 ＝ 物理像素 / 设备独立像素5,6的dpr=2，1个css像素等于2个物理像素6p的dpr=3,1个css像素等于3个物理像素 那首先我们在移动端布局，viewport肯定不能是默认的值最终viewport宽度等于应该等于设备的宽度我们的布局视图应该是 按照物理像素来布局设备独立像素可获得设备像素比 window.devicePixelRatio现在假设 在iphone6上布局 此时dpr = 2,dip = 375物理像素应该是 dpr * dip = 750div{border-top:1px solid #000;}现在在页面上要实现一个1px的上边框由于移动端布局viewport缩成设备宽度而分辨率没有变所以这时的1px会有2px的效果 这个时候可以手动将viewport 宽度设成物理像素的宽度，然后将整个页面缩小 dpr 倍 1px 的问题解决了，那如何解决在不同手机显示设计稿中的一个100x100的div设计稿 750其中div 100x100750的设计稿对应的是iPhone6结合上面viewport的缩放div{width:100px;height:100px;}在6上跟设计稿是完全相同的而在5(640)上会变大 这个时候可以通过rem在不同设备上动态计算出比例值 假设在750设计稿中 1rem = 100px那么在640设计稿中 1rem = 640/750*100px此时1rem 不管在5上还是6上显示都完全跟在设计稿中显示效果相同 123456789101112//html&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;//动态计算remvar domDocEL = window.document.documentElement, mateViewPort = window.document.querySelector('meta[name=\"viewport\"]'), nBasePsdWidth = 750 / 100, nDpr = window.devicePixelRatio, nScale = 1 / nDpr, nLayout = domDocEL.clientWidth, nRem = nLayout * nDpr / nBasePsdWidth;domDocEL.style.fontSize = rem +'px';mateViewPort.setAttribute('content','width='+nDpr*nLayout+',initial-scale='+nScale+',maximum-scale='+nScale+',minimum-scale='+nScale+',user-scalable=no'); 对于字体可以用写个mixin方法根据不同的dpr设置字号 12345@mixin px2rem($name,$px) &#123; [data-dpr=\"2\"] &amp; &#123; #&#123;$name&#125;: $px*2/2+px; &#125; &#125; 总结移动端布局将viewport设成物理像素的大小,然后在缩放为dpr的倒数倍。dpr不存在？简单点~~~那就指定为1！","tags":[{"name":"css","slug":"css","permalink":"//blog.fenghou.site/tags/css/"},{"name":"rem","slug":"rem","permalink":"//blog.fenghou.site/tags/rem/"}]},{"title":"react","date":"2016-12-18T11:06:01.000Z","path":"2016/12/18/2016-12-18-react/","text":"react 在props里使用 onClick={ this.handleClick.bind(this) }或者 onClick={ (e) =&gt; this.handleClick(e) }或者 onClick={ ::this.handleClick }都会产生性能问题，所以现在eslint在语法检查时就会阻止这几种写法，问题原因是每一次render的时候如果遇到这些写法，都会重新用handleClick函数与this去绑定从而重新创建一个新的函数，影响性能。如果使用下面的写法则不会每次都创建：// 1.constructor() {this.handleClick = this.handleClick.bind(this);}handleClick(e) { / … / }// 2.handleClick = (e) =&gt; { / … / }; 箭头函数不能用？Parsing error: Unexpected token =babel-eslint","tags":[{"name":"react","slug":"react","permalink":"//blog.fenghou.site/tags/react/"}]},{"title":"webpack配置","date":"2016-12-16T11:05:13.000Z","path":"2016/12/16/2016-12-16-webpack/","text":"关于webpack的教程网上一抓一大把就不班门弄斧了这里只是总结一些webpack的实用配置以及个人心得 entry&amp;output12345678910111213141516171819202122232425262728293031323334353637383940414243444546enpty:&#123; index:'./index.js', more:['./more2.js','./more.js'], vendor: ['react', 'react-dom', 'react-router']&#125;putput:&#123; path:'./build', filename:'[name]-[id].js', publicPath:'/assets/', chunkFilename:'[name]-[chunkhash]'&#125;//[id], chunk的id//[name] ,chunk名//[hash], 编译哈希值//[chunkhash] , chunk的hash值 根据模块内容//output.publicPath：设置为想要的资源访问路径。//访问时，则需要通过类似http://localhost:8080/asstes/index-1.js来访问资源，//如果没有设置，则默认从站点根目录加载。//filename应该比较好理解，就是对应于entry里面生成出来的文件名。比如：&#123; entry: &#123; \"index\": \"pages/index.jsx\" &#125;, output: &#123; filename: \"[name].min.js\", chunkFilename: \"[name].min.js\" &#125;&#125;//生成出来的文件名为index.min.js。//chunkname我的理解是未被列在entry中，//却又需要被打包出来的文件命名配置。//什么场景需要呢？我们项目就遇到过，在按需加载（异步）模块的时候，//这样的文件是没有被列在entry中的，如使用CommonJS的方式异步加载模块：require.ensure([\"modules/tips.jsx\"], function(require) &#123; var a = require(\"modules/tips.jsx\"); // ...&#125;, 'tips');//异步加载的模块是要以文件形式加载哦，//所以这时生成的文件名是以chunkname配置的，//生成出的文件名就是tips.min.js。//（require.ensure() API的第三个参数是给这个模块命名，//否则 chunkFilename: \"[name].min.js\" 中的 [name] 是一个自动分配的、可读性很差的id，//这是我在文档很不起眼的地方788发现的。。。）new webpack.optimize.CommonsChunkPlugin(&#123; names: ['vendor'],&#125;) url-loader1234test: /\\.(gif|jpg|png)$/,loader: 'url-loader?limit=1024&amp;name=img/[name].[ext]'//小于1024字节 采用base64//大于1024字节 正常打包到output目录下img文件夹中 js-loader123456789101112131415161718192021222324252627282930//babel //配置 .babelrc //.rc run command 程序启动阶段被调用 //执行babal-loader时自动执行 &#123; \"presets\": [\"es2015\", \"stage-2\"], \"plugins\": [ \"transform-class-properties\", \"transform-runtime\" ] &#125; //webpack.config.js &#123; test: /\\.js$/, exclude: /node_modules/, loader:'babel' &#125;,//不使用.babelrc &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: &#123; presets: [\"es2015\", \"stage-2\"], plugins: [ \"transform-class-properties\", \"transform-runtime\" ] &#125; &#125;, vue-loader1234567891011121314151617181920&#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/,&#125;&#123; test:/\\.vue$/, loader:'vue',&#125;babel: &#123; presets: ['es2015'], plugins: [\"transform-class-properties\", \"transform-runtime\"]&#125;,vue:&#123; loaders:&#123; js:'babel', scss:['vue-style-loader','css','sass'].join('!') &#125;&#125;, css-loaderloader 采取管道流 1loader: ['style','css','scss'].join('!') 提取样式到单独文件插件 extract-text-webpack-plugin 123456789var ExtractTextPlugin = require('extract-text-webpack-plugin');&#123; test: /\\.(scss|sass|css)$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader')&#125;plugins: [ new ExtractTextPlugin('[name].css') //output目录下 ], css样式自动 fix插件 autoprefixer(postcss插件) 12345678910111213141516&#123; test: /\\.(scss|sass|css)$/, loader: ExtractTextPlugin.extract('style-loader', ['css-loader', 'postcss-loader']) &#125;const AUTOPREFIXER_BROWSERS = [ 'Android &gt;= 4', 'Chrome &gt;= 35', 'Firefox &gt;= 31', 'Explorer &gt;= 9', 'iOS &gt;= 7', 'Opera &gt;= 12', 'Safari &gt;= 7.1'] postcss: function() &#123; return [autoprefixer(&#123; browsers: AUTOPREFIXER_BROWSERS &#125;)]; &#125;, file-loader1234&#123; test: /\\.(woff|svg|eot|ttf).$/, loader: \"file-loader?name=fonts/[name].[ext]\"&#125; resolve123456789101112131415161718var moment = require('moment');//编译很慢 也就是说，请求的是 moment 的源码。//实际上，通过 NPM 安装 moment 的时候会同时安装 moment 的源码和压缩后的代码//var moment = require('moment/min/moment-with-locales.min.js');//只不过这样改，可读性会有所下降，//而且每一个用到 moment 的地方都得这么写。//另外，如果同样的问题出现在第三方模块中，修改别人代码就不那么方便了。//下面来看看用 Webpack 怎么解决这个问题。 resolve: &#123; alias: &#123; moment: \"moment/min/moment-with-locales.min.js\" &#125; &#125;//可以用 alias 指定从非npm引入的库，如jquery: path.resolve(__dirname, './bower_components/jquery/dist/jquery.js') ，这样在 import 时可以替换引用路径// require时省略的扩展名，如：require('app') 不需要app.jsextensions: ['','.js','.vue','.scss'], noParsemodule.noParse 是 webpack 的另一个很有用的配置项，如果你 确定一个模块中没有其它新的依赖 就可以配置这项，webpack 将不再扫描这个文件中的依赖。123module: &#123; noParse: [/moment-with-locales/] &#125; devtool通常，JavaScript的解释器会告诉你，第几行第几列代码出错。但是，这对于转换后的代码毫无用处。举例来说，jQuery 1.9压缩后只有3行，每行3万个字符，所有内部变量都改了名字。你看着报错信息，感到毫无头绪，根本不知道它所对应的原始位置。这就是Source map想要解决的问题。 1devtool: '#source-map' hot reload123456789101112//package.json\"scripts\": &#123; \"dev\": \"webpack-dev-server --devtool eval-source-map --progress --colors --hot --inline\", &#125;,--content-base 内容基本路径 不加默认当前目录--colors 输出加颜色path: \"./dist\",filename: \"[name].js\",publicPath: \"abababab\",publicPath 必须设置 这里设置什么名 html里引用就写什么名字&lt;script src=\"/abababab/main.js\"&gt;&lt;/script&gt;npm run dev webpack -w12345//webstrom 会在临时文件夹中创建一个文件用来保存(好像没有出发实际文件的变更)settingAppearance &amp; BehaviorSystem SettingsUse \"safe write\"(save changes to a temporary file first) 勾去掉","tags":[{"name":"webpack","slug":"webpack","permalink":"//blog.fenghou.site/tags/webpack/"}]},{"title":"学点运维，配个服务器","date":"2016-12-15T11:04:25.000Z","path":"2016/12/15/2016-12-15-aliyun-yunwei/","text":"前段时间和同事合租了一个阿里云服务器，60几块钱一个月。服务器上的资源环境很多都是他配的，作为前端，只是在上面放点静态的东西，也没太大兴趣在这方面去摸索然后这货今天离职了。 走之前，悠悠然发了我一个连接阿里云搞活动 服务器免费赠送6个月 果断入手(要买个9块钱的套餐)然后买域名解析DNS配nginx装git搭node 也算是小入门了 But 我想说的是作为一个开发人员and 一个合格的开发人员首先具备的应该是解决问题，查找问题的能力 而不是一有问题不假思索的问别人有时候多学一样本领,就早说一句求人的话 作为我们作为初学者总会碰到各种各样的问题那么，怎么解决？ 举个栗子linux git的安装 忽略前面下载解压过程 ./configure –prefix=/usr/local make &amp; make install 果断报错。。OK 下载各种依赖报错继续安装成功git –version嗯 有版本号easy嘛然后 来 git clone ..error:fatal: Unable to find remote helper for ‘https’又报错，奔溃 这是因为Git环境没有安装完全，需要重新安装 ./configure –prefix=/usr/local make all doc make install install-doc install-man install-html 继续 OK问题解决 那么这解决问题的过程 就比解决问题来的跟有用前提是问题是你自己解决的","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"},{"name":"linux","slug":"linux","permalink":"//blog.fenghou.site/tags/linux/"}]},{"title":"In city","date":"2016-12-14T11:03:52.000Z","path":"2016/12/14/2016-12-14-incity/","text":"悠然随心随性随缘 杭州，省会美丽的西湖（我也只去过西湖。。）一年前，在这我开启了前端之旅 那谁说过，在风口，是只猪也能飞起来。何况是在杭州这样的互联网台风中。。 但是风过了，依然在飞的却是鹰 麻雀从不担心树枝会断因为他相信的不是树枝而是自己的翅膀 身处互联网大时代机会很多，机遇很多首先飞起来然后去充实自己不断学习不断进步 最后风即使过了我们也进化成了鹰","tags":[{"name":"随想","slug":"随想","permalink":"//blog.fenghou.site/tags/随想/"}]},{"title":"Node-Spider","date":"2016-12-13T11:03:06.000Z","path":"2016/12/13/2016-12-13-node-spider/","text":"Node学习入门，练习爬虫再适合不过了这里通过爬区某图片网站近(10万张图片)的例子，介绍爬虫的过程 爬虫分析设计抓取的是 ‘http://www.mzitu.com‘ 网站图片大致有五个类目每个类目下分页规则http://www.mzitu.com/类目/page/1http://www.mzitu.com/类目/page/2 每一个有25个专题专题详情页 http://www.mzitu.com/专题id专题详情页分页规则http://www.mzitu.com/专题id/1http://www.mzitu.com/专题id/2 因此第一次鉴于此 爬虫设计如下先获取单个类目下专题(图片和Id)专题图片根据 类目/当前page数/图片 路径保存将获取的id暂存知道获取完全部全部类目专题然后开始获取专题详情确定要获取的专题详情的所有分页数最后爬区所有分页数 用到的模块1234var superagent = require('superagent'); //请求封装模块var async = require('async'); //并发控制模块var cheerio = require('cheerio'); //抓取页面dom节点模块var fs = require(\"fs\"); 数据准备12345678var sUrl = 'http://www.mzitu.com'; //爬取目标var aItems = []; //单个类目下需要爬取的链接var aTagList = ['/','/xinggan','/japan','/taiwan','/mm']; //所有类目var aDirList = ['index','xinggan','japan','taiwan','mm']; //爬取存放路径var nCurrentTag = 0; //当前爬取类目var aIdList = []; //专题Idvar aNextPage = []; //专题详情var aNxtItems = []; //专题详情下需要爬区的链接 获取所有专题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121function start(page)&#123; superagent .get(page) .end(function (err, response) &#123; if (err) &#123; console.log(err.status); &#125; if (response.status === 200) &#123; var $ = cheerio.load(response.text); &#125; var nPageLen = $('.nav-links a.next').prev().text(); // 获取页数 for(var i = 0;i &lt; nPageLen ;i++)&#123; aItems.push(page+'/page/'+(i+1)); &#125; var sName = page.replace('http://www.mzitu.com',''); sName = sName ? sName : 'index'; // 新建类目 存放目录 fs.mkdir(__dirname+'/uploa/'+sName.replace('/',''),function(err)&#123; if(err)&#123; throw err &#125; &#125;) fetchPage(); &#125;);&#125;function fetchPage()&#123; var concurrencyCount = 0; var fetchUrl = function(url,callback)&#123; var fetchStart = new Date().getTime(); concurrencyCount++; console.log('并发数'+concurrencyCount+'====url:'+url); superagent.get(url) .end(function(err,res)&#123; if(err)&#123; // callback(err,url); // return next(err); &#125; var time = new Date().getTime() - fetchStart; // console.log('抓取'+url+'成功,耗时'+time) concurrencyCount--; if(res.status === 200)&#123; var $ = cheerio.load(res.text); &#125; //爬取数据处理 getDetail($,url,function(rs)&#123; // _html += rs; &#125;) callback(); &#125;) &#125; // 控制并发数 async.mapLimit(aItems,5,function(myUrl,callback)&#123; fetchUrl(myUrl,callback); &#125;,function(err,result)&#123; nCurrentTag++; if(nCurrentTag &lt; aTagList.length)&#123; // console.log('====================开始抓取下一个类目===================='); aItems = []; start(sUrl+aTagList[nCurrentTag]); &#125; else&#123; console.log('====================开始抓取详情页========================='); // getNextPage(); &#125; &#125;)&#125;function getDetail($,url,callback)&#123; //确定图片名称 var dirList = url.replace('http://www.mzitu.com/','').split('/'); var dirName = dirList[0]+'/'+dirList[1]+dirList[2]; if(dirList.length &lt; 3)&#123; dirName = 'index/'+dirList[0]+dirList[1]; &#125; var domItemA = $('#pins li a'); // 获取Id var domItem = $('#pins li a img'); //获取图片 var srcList = [] domItem.each(function(idx,element)&#123; var $ele = $(element); var src = $ele.attr('data-original'); var id = $ele.parent().attr('href').replace('http://www.mzitu.com/',''); aSrcList.push(src); aIdList.push(id); &#125;) // 下载专题图片 downImg(aSrcList,dirName);&#125;function downImg(list,dirName)&#123; fs.mkdir(__dirname+'/upload/'+dirName,function(err)&#123; if(err)&#123; throw err &#125; &#125;) var savePath = __dirname+'/uploa/'+dirName+'/' + narr[0] +'_'+ narr[1] + '_' + narr[2]; function binaryParser(res, callback) &#123; res.setEncoding('binary'); var imgData = ''; res.on('data', function (chunk) &#123; imgData += chunk; &#125;); res.on('end', function () &#123; fs.writeFile(savePath, new Buffer(imgData, 'binary'),function(err) &#123; if(err) &#123; console.log(err); &#125; console.log(url+'下载成功') &#125;); &#125;); &#125; var downUrl = function(url,callback)&#123; var narr = url.replace(\"http://i.meizitu.net/thumbs/\", \"\").split(\"/\") supergent.get(url) // .pipe(fs.createWriteStream(savePath)) .parse(binaryParser) .end(function(err,res)&#123; &#125;) &#125; async.mapLimit(list,5,function(myUrl,callback)&#123; downUrl(myUrl,callback); &#125;,function(err,result)&#123; &#125;)&#125;","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"}]},{"title":"Node-server","date":"2016-12-13T11:02:26.000Z","path":"2016/12/13/2016-12-13-node-server/","text":"用Node搭建一个静态资源访问服务器 用到的模块 1234var http = require('http'), url = require('url'), path = require('path'), fs = require('fs'); 思路 获取访问路径，以文件后缀判断文件类型12345678910111213var mimetype = &#123; 'txt': 'text/plain', 'html': 'text/html', 'css': 'text/css', 'xml': 'application/xml', 'json': 'application/json', 'js': 'application/javascript', 'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'gif': 'image/gif', 'png': 'image/png', 'svg': 'image/svg+xml'&#125; 获取请求的时候判断请求文件是否存在，决定返回的类型 123456789101112131415161718192021222324http.createServer(function(req,res)&#123; var pathname = url.parse(req.url).pathname, realPath = path.join(__dirname,'/static',pathname); var body = []; req.on('data',function(data)&#123; body.push(data); &#125;) req.on('end',function()&#123; body = Buffer.concat(body); &#125;) fs.exists(realPath,function(ex)&#123; if(ex)&#123; var rs = fs.createReadStream(realPath); res.writeHead(200,&#123; 'Content-Type':mimetype[realPath.split('.').pop()] || 'text/plain' &#125;) rs.on('data',res.write.bind(res)) rs.on('close',res.end.bind(res)); &#125; else&#123; page_404(req,res,realPath); //错误页面 &#125; &#125;)&#125;).listen(3000) 请求不存在 1234567891011121314function page_404(req,res,path)&#123; res.writeHead(404,&#123; 'Content-Type':'text/html' &#125;) res.write('&lt;!doctype html&gt;\\n'); res.write('&lt;title&gt;404 Not Found&lt;/title&gt;\\n'); res.write('&lt;h1&gt;Not Found&lt;/h1&gt;'); res.write( '&lt;p&gt;The requested URL ' + path + ' was not found on this server.&lt;/p&gt;' ); res.end();&#125;","tags":[{"name":"node","slug":"node","permalink":"//blog.fenghou.site/tags/node/"}]},{"title":"MarkDown语法","date":"2016-12-12T02:25:27.000Z","path":"2016/12/12/2016-12-12-md-rule/","text":"AB 亮不亮 我的博客 ES JS JS1 数据结构 树 二叉树 平衡二叉树 满二叉树 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 加删除线像这样用： 删除这些 [x] 支持 @提到某人、#引用、链接、格式化 和 标签 等语法 [x] 需要使用列表语法来激活（无序或有序列表均可） [x] 这是一个已完成项目 [ ] 这是一个未完成项目","tags":[{"name":"markdown","slug":"markdown","permalink":"//blog.fenghou.site/tags/markdown/"}]}]