[{"title":"基于Vue的CPS后台","date":"2017-02-27T08:12:34.000Z","path":"2017/02/27/vue-xq-cps/","text":"webpack 2.X vuex vue-router整理中","tags":[{"name":"webpack","slug":"webpack","permalink":"https://luyi10year.github.io/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"https://luyi10year.github.io/tags/vue/"}]},{"title":"Weex","date":"2017-02-21T08:09:34.000Z","path":"2017/02/21/alibab-weex/","text":"整理中","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"},{"name":"Weex","slug":"Weex","permalink":"https://luyi10year.github.io/tags/Weex/"}]},{"title":"Rax","date":"2017-02-17T05:01:30.000Z","path":"2017/02/17/alibab-react-rax/","text":"","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"},{"name":"Rax","slug":"Rax","permalink":"https://luyi10year.github.io/tags/Rax/"},{"name":"React","slug":"React","permalink":"https://luyi10year.github.io/tags/React/"}]},{"title":"PReact","date":"2017-02-13T07:08:18.000Z","path":"2017/02/13/PReact/","text":"整理中","tags":[{"name":"RReact","slug":"RReact","permalink":"https://luyi10year.github.io/tags/RReact/"},{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"}]},{"title":"wx签名出错-URL","date":"2017-02-13T02:16:29.000Z","path":"2017/02/13/wx-js-sdk-location-url/","text":"上周调试wx收货地址的时候碰到一个签名出错的问题invalid signature 前提为了增强用户体验在下单页选择收货地址的时候如果是微信用户新增添加微信地址的功能 思路调用wxAPI获取地址信息转换地址信息格式将新地址保存 注意点wx.openAddress方法中cancel回调是取消选项 wx地址选择中北京天津等自治区新增县选项北京市 北京市 朝阳区北京市 县 密云县 问题因为方便测试打开页面的方式都是通过打开指定连接的形式http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1一切OK但是从商品详情页进入在选择SKU下单的时候wx.openAddress会调用不了也就是 直接打开 http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1 正常先进商品详情页 ==&gt; http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1 异常invalid signature 解决直接打开链接wx浏览器会对url连接进行转码(encode)wx浏览器内部连接跳转不会对url进行转码处理 wx验证签名信息的时候会将当前页面的链接进行转码处理(encode) 所以直接打开 http://www.xiangqu.com/order/submit/view?skuMap[q90060] = 1wx的验证的URL = http://www.xiangqu.com/order/submit/view?skuMap%5Bq90060%5D=1服务端验证的URL = http://www.xiangqu.com/order/submit/view?skuMap%5Bq90060%5D=1 间接打开的 http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1wx的验证的URL = http://www.xiangqu.com/order/submit/view?skuMap%5Bq90060%5D=1服务端验证的URL = http://www.xiangqu.com/order/submit/view?skuMap[q90060]=1 解决方法很简单在跳转的时候js先对链接进行转码 延伸在处理url编码问题的时候最好的方法就是Javascript先对URL进行编码不通过浏览器编码保证输出结果和服务器得到数据的一致","tags":[{"name":"wx","slug":"wx","permalink":"https://luyi10year.github.io/tags/wx/"}]},{"title":"Redux","date":"2017-02-05T02:46:42.000Z","path":"2017/02/05/react-redux/","text":"整理中","tags":[{"name":"react","slug":"react","permalink":"https://luyi10year.github.io/tags/react/"}]},{"title":"react-flux","date":"2017-02-04T02:46:33.000Z","path":"2017/02/04/react-flux/","text":"整理中","tags":[{"name":"react","slug":"react","permalink":"https://luyi10year.github.io/tags/react/"}]},{"title":"react-immutable","date":"2017-02-03T02:45:40.000Z","path":"2017/02/03/react-immutable/","text":"整理中","tags":[{"name":"react","slug":"react","permalink":"https://luyi10year.github.io/tags/react/"}]},{"title":"Canvas--书法毛笔字","date":"2017-01-21T02:43:53.000Z","path":"2017/01/21/canvas-fonts-book/","text":"继续Canvas这次记录移动端手写书法的实现 抛出问题canvas在移动端应用书法需要解决两个问题1.笔锋问题2.连贯问题 解决方案首先分析一下毛笔字是有笔锋的又粗有细有勾有钩通过点击时间长短决定画笔大小来模拟毛笔力度 通过touchmove事件获取连续移动的两个点计算两点间的直线距离通过循环在canvas画图 代码上12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788let domCanvas = document.querySelector('#Calligraphy'), context = domCanvas.getContext('2d'), CONFIG = &#123; lineMin:8, lineMax:20, radius:0 &#125;; let Calligraphy = function()&#123; this.touchFlog = false; this.hasEvent = []; //move数组 this.upEvent = null; //当前操作 this.limitDis = 80; //移动最少距离 this.radius = CONFIG.radius; this.lineMin = CONFIG.lineMin; this.lineMax = CONFIG.lineMax; &#125; Calligraphy.prototype = &#123; start:function()&#123; //开始执行监听事件 this.bindEventDown = this.eventDown.bind(this); this.bindEventMove = this.eventMove.bind(this); this.bindEventUp= this.eventUp.bind(this); domCanvas.addEventListener('touchstart',this.eventDown) domCanvas.addEventListener('touchmove',this.bindEventMove) domCanvas.addEventListener('touchend',this.bindEventUp) &#125;, eventDown:function(e)&#123; console.log('Down') e.preventDefault(); let target = e.changedTouches[e.changedTouches.length-1]; this.touchFlog = true; this.hasEvent = []; // this.upEvent = this.getPoint(target); //当前操作 &#125;, eventMove:function(e)&#123; console.log('Move'); let target = e.changedTouches[e.changedTouches.length-1]; this.drawFont(this.getPoint(target)) &#125;, eventUp:function()&#123; console.log('Up'); e.preventDefault(); this.moveFlog = false; &#125;, drawFont:function(point)&#123; if(!this.touchFlog) return false; let moEvent = point, upEvent = this.upEvent, upRadius = this.radius, dis = 0, //连续点距离 time = 0; //时间 this.hasEvent.unshift(&#123;time:new Date().getTime(),dis:this.getDistance(upEvent,moEvent)&#125;); for (let n = 0; n &lt; this.hasEvent.length-1; n++) &#123; dis += this.hasEvent[n].dis; time += this.hasEvent[n].time-this.hasEvent[n+1].time; if (dis&gt;this.limitDis) break; &#125; let radius = Math.min(time/dis+this.lineMin,this.lineMax)/2; //计算这次画笔半径 this.radius = radius; this.upEvent = moEvent; let len = Math.round(this.hasEvent[0].dis/2)+1; //跟上次画笔半径渐变 for (let i = 0; i &lt; len; i++) &#123; let x = upEvent.x + (moEvent.x-upEvent.x)/len* i, y = upEvent.y + (moEvent.y-upEvent.y)/len* i, r = upRadius + (radius-upRadius)/len*i; context.beginPath(); context.arc(x,y,r,0,2*Math.PI,true); context.fill(); &#125; &#125;, getPoint:function()&#123; return &#123; x: e.clientX - domCanvas.offsetLeft + (document.body.scrollLeft || document.documentElement.scrollLeft), y: e.clientY - domCanvas.offsetTop + (document.body.scrollLeft || document.documentElement.scrollTop), &#125; &#125;, getDistance: function(pre,next)&#123; let x = next.x - pre.x, y = next.y - pre.y; return Math.sqrt(x*x + y*y); &#125; &#125; let calligrapgy = new Calligraphy(); calligrapgy.start();","tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://luyi10year.github.io/tags/Canvas/"},{"name":"H5","slug":"H5","permalink":"https://luyi10year.github.io/tags/H5/"}]},{"title":"Canvas--黑凤梨","date":"2017-01-20T02:43:38.000Z","path":"2017/01/20/canvas-fonts-image/","text":"之前很火的黑凤梨生成性格图片相信大家印象深刻短时间拉了大量粉丝，同时自个儿也被微信封了 我们公司当时也做了一个类似的活动想去治病！ 活动流程通过输入生日年月，确定星座每个新座对应几个不同的病症每个病症对应几段不同的文案和商品诊断结果可以分享 初步想法前端通过canvas实现结果图片通过toDataURL转成Image用微信浏览器自带保存图片功能 遇到的问题设计师希望采用第三方字体那显然在前端实现这有点坑用户流量中文不是就26个字母常用词汇加起来2500 大概7M左右这还是一种字体要实现设计稿要求至少需要三种字体 解决办法将字体资源放到服务器有服务端实现生成图片前端上传生成格式和内容 代码实现在代码实现上前端没有什么大问题主要是数据格式的规定上12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091let XZ = &#123; '1':&#123; division:19, items:['MJ','SP'] &#125;, '2':&#123; division:18, items:['SP','SY'] &#125;, '3':&#123; division:20, items:['SY','BY'] &#125;, '4':&#123; division:19, items:['BY','JN'] &#125;, '5':&#123; division:20, items:['JN','SdZ'] &#125;, '6':&#123; division:21, items:['SdZ','JX'] &#125;, '7':&#123; division:22, items:['JX','SlZ'] &#125;, '8':&#123; division:22, items:['SlZ','CN'] &#125;, '9':&#123; division:22, items:['CN','TC'] &#125;, '10':&#123; division:23, items:['TC','TX'] &#125;, '11':&#123; division:22, items:['TX','SS'] &#125;, '12':&#123; division:21, items:['SS','MJ'] &#125;&#125;//星座的判别let oXz = XZ[domInputMonth]; sXz = domInputDate &lt;= oXz.division ? oXz.item[0] : oXz.item[1];//病症描述的格式规定['$+@70@&amp;方正兰亭特黑简体&amp;**+$$+@50@&amp;方正兰亭特黑简体&amp;想发个朋友圈+$','结果..$+@50@&amp;方正兰亭特黑简体&amp;俩小时+$过去了...','还在$+@110@&amp;方正兰亭特黑简体&amp;选照片+$']文案分行采取数组形式$+ +$ 包含有特殊字体文本&amp; &amp; 特殊字体@ @ 字号** 替换文案(姓名)//生成文案在显示位置通过本地Canvas模拟生成的图片(字体用系统字体代替)context.ctx.font = nSize+'px arial';context.measureText(sContext).width 来获取长度通过指定宽度容器的比较获取x,y坐标//小技巧//数组的随机Array.prototype.shuffle = function(n)&#123; let len = this.length,num = n ? Math.min(n,len) : len,index, arr = this.slice(0),temp, lib = &#123;&#125;; lib.range = function(min,max)&#123; return min + Math.floor(Math.random()*(max-min+1)) &#125; for(let i =0;i&lt;len;i++)&#123; index = lib.range(i,len-1); temp = arr[i]; arr[i] = arr[index]; arr[index] = temp; &#125; return arr.slice(0,num); &#125;//两个数组的合并[a].concat([b]) 返回结果新数组[].push.apply([a],[b]);返回结果[a] 总结虽然好像跟canvas关系不大但是，好像也没有但是。。。","tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://luyi10year.github.io/tags/Canvas/"},{"name":"H5","slug":"H5","permalink":"https://luyi10year.github.io/tags/H5/"}]},{"title":"Canvas--星空","date":"2017-01-19T02:43:25.000Z","path":"2017/01/19/canvas-snow/","text":"Canvas 星空效果嗯 是的 就是左上方的星空效果 星空效果设计思路其实星空在实现上很简单一个星星就是一个星星对象实例有属性x坐标，y坐标，半径，移动速度和透明度有方法生成坐标，绘制星星 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&#123; /* * 配置选项 * width:画布宽 * height:画布高 * splitHeight:星星密集分割 * stars:星星数量 * maxStar:星星最大半径 * minStar:星星最小半径 * maxSpeed:星星最大移动速度 * minSpeed:星星最小移动速度 * */ let SkySetting = &#123; width:800, height:300, splitHeight:200, stars:400, maxStar:1.2, minStar:0.6, maxSpeed:0.1, minSpeed:0.02, &#125;, domCanvas = document.querySelector('#Star'), context = domCanvas.getContext('2d'); /* * 画布实例 * */ let starSky = function(width,height,stars)&#123; this.width = width; this.height = height; this.stars = stars; this.aStars = []; &#125; starSky.prototype = &#123; /* * 入口 * */ start:function()&#123; domCanvas.width = this.width; domCanvas.height = this.height; context.fillStyle = 'rgba(0,0,0,1)'; context.fillRect(0,0,this.width,this.height); this.render(); &#125;, /* * 重绘 * */ redraw:function()&#123; context.clearRect(0,0,this.width,this.height); context.fillStyle = 'rgba(0,0,0,1)'; context.fillRect(0,0,this.width,this.height); &#125;, /* * 新建星星实例 * 绘制星星 * window.requestAnimationFrame 动画函数 * */ render:function()&#123; this.redraw(); if(this.aStars.length &lt;= this.stars)&#123; let star = new Star(); this.aStars.push(star); &#125; this.aStars.forEach(function(star)&#123; star.draw(); &#125;) window.requestAnimationFrame(()=&gt;&#123; this.render(); &#125;); &#125;, &#125; /* * 星星构造器 * */ let Star = function()&#123; this.randomPoint(); &#125; Star.prototype = &#123; /* * 随机星星数据 * */ randomPoint:function()&#123; let _x = Math.random()*SkySetting.width, _r = SkySetting.minStar + Math.random()*(SkySetting.maxStar - SkySetting.minStar), _ran = Math.random()*10, _rx = Math.random()*(SkySetting.maxSpeed-SkySetting.minSpeed) + SkySetting.minSpeed, _y = _ran &gt; 2 ? Math.random()*SkySetting.splitHeight: Math.random()*SkySetting.height, _alphaMax = Math.random()*0.8 + 0.2, _alphaMin = 0.2, _alpha = 0; this.x = _x; this.y = _y; this.r = _r; this.rx = _rx; this.alpha = _alpha; this.alphaMax = _alphaMax; this.alphaMin = _alphaMin; this.alphaAction = true; &#125;, /* * 绘制星星 * 星星变化 * */ draw:function()&#123; this.x += this.rx; if(this.x + this.r &gt;= SkySetting.width)&#123; this.x = 0; &#125; if(this.alphaAction)&#123; if(this.alpha &lt; this.alphaMax)&#123; this.alpha += 0.05; &#125;else&#123; this.alphaAction = false &#125; &#125; if(!this.alphaAction)&#123; if(this.alpha &gt; this.alphaMin)&#123; this.alpha -= 0.02; &#125; else&#123; this.alphaAction = true; &#125; &#125; context.beginPath(); context.fillStyle = 'rgba(255,255,255,'+this.alpha.toString()+')'; context.arc(this.x,this.y,this.r,0,Math.PI*2,true); context.closePath(); context.fill(); &#125; &#125; /* * 构造星空实例 * */ let sky = new starSky(SkySetting.width,SkySetting.height,SkySetting.stars); sky.start(); &#125;","tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://luyi10year.github.io/tags/Canvas/"},{"name":"H5","slug":"H5","permalink":"https://luyi10year.github.io/tags/H5/"}]},{"title":"Canvas--刮刮卡","date":"2017-01-18T02:43:15.000Z","path":"2017/01/18/canvas-xiaoxiaole/","text":"到年底了，去回顾了下做过的项目发现有很多跟Canvas有关的这里简单记录一点心得方便日后查阅 一个模拟刮奖的活动设计思路获奖结果上实现一个遮层手指滑动位置遮层对应位置色值清空判断清空数据达到设定值，清除遮层 必备APIgetContext()getImageData() //获取画布像素数据 每个像素包含RGBA四个值fill() //填充rect() //矩形arc() //圆globalCompositeOperation //设置或返回如何将一个源（新的）图像绘制到目标（已有）的图像上 touch事件touchstarttouchmovetouchendchangedTouches:touchlist。对于 touchstart 事件, 这个 TouchList 对象列出在此次事件中新增加的触点对于 touchmove 事件，列出和上一次事件相比较，发生了变化的触点对于 touchend ，列出离开触摸平面的触点（这些触点对应已经不接触触摸平面的手指） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&#123; let domCanvas = document.querySelector('#GGL'), context = domCanvas.getContext('2d'); /* * 构建对象 * width * height * filter 取消遮罩百分比 * */ let clipImage = function(height,width,filter)&#123; this.width = width; this.height = height; this.filter = filter; domCanvas.width = this.width; domCanvas.height = this.height; &#125; clipImage.prototype = &#123; /* * 函数入口 * 开始监听事件 * */ start:function()&#123; context.fillStyle = 'gray'; context.fillRect(0,0,this.width,this.height); context.globalCompositeOperation = 'destination-out'; this.bindEventMove = this.eventMove.bind(this); this.bindEventUp= this.eventUp.bind(this); domCanvas.addEventListener('touchstart',this.eventDown) domCanvas.addEventListener('touchmove',this.bindEventMove) domCanvas.addEventListener('touchend',this.bindEventUp) &#125;, eventDown:function()&#123; console.log('Down') &#125;, eventMove:function(e)&#123; console.log('Move'); let target = e.changedTouches[e.changedTouches.length-1]; this.clearMove(target) &#125;, eventUp:function()&#123; console.log('Up'); this.clearMask(); &#125;, /* * 清除划过画布 * */ clearMove:function(target)&#123; let nX = target.clientX, nY = target.clientY; context.beginPath(); context.arc(nX,nY,15,0,Math.PI * 2); context.fill(); &#125;, /* * 判断像素点清除数是否到达指定百分比 * */ clearMask:function()&#123; let nNum = 0, aImageData = context.getImageData(0,0,this.width,this.height).data, nLength = aImageData.length; aImageData.forEach((item)=&gt;&#123; if(item == 0)&#123; nNum++; &#125; &#125;) if(nNum &gt;= nLength * this.filter)&#123; this.finish(); &#125; &#125;, /* * 完成刮奖 * */ finish:function()&#123; context.beginPath(); context.rect(0,0,this.width,this.height); context.fill(); domCanvas.removeEventListener('touchstart',this.eventDown); domCanvas.removeEventListener('touchmove',this.bindEventMove); domCanvas.removeEventListener('touchend',this.bindEventUp); &#125; &#125; let clip = new clipImage(400,400,.3); clip.start(); &#125;","tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://luyi10year.github.io/tags/Canvas/"},{"name":"H5","slug":"H5","permalink":"https://luyi10year.github.io/tags/H5/"}]},{"title":"从微信小程序的登录谈谈前端的登录机制","date":"2017-01-16T06:00:56.000Z","path":"2017/01/16/weapp-login-vs-web-login/","text":"上周一周的忙碌，结束了小程序的初版上线今天拉了楼上同事的代码瞬间打击回解放前","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://luyi10year.github.io/tags/微信小程序/"},{"name":"session","slug":"session","permalink":"https://luyi10year.github.io/tags/session/"},{"name":"cookie","slug":"cookie","permalink":"https://luyi10year.github.io/tags/cookie/"}]},{"title":"谈谈js的继承","date":"2017-01-03T03:53:25.000Z","path":"2017/01/03/es5-es6-extends/","text":"继承在JavaScript中不像在别的面向对象语言中那样简单JavaScript使用的是基于对象的继承它可以用来模仿基于类的继承 Es6中，新增了Class和extends关键字来支持类的继承在这里记录各种继承的实现方式 类式继承JavaScript对象可以模仿Java中的对象通过函数来声明类用关键字new来创建实例这种方式包括两个步骤1.用一个类的声明定义对象的结构2.实例化该类创建一个新对象123456789//类的实例function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(this.sName);&#125;;var Ls = new Person('Ls');Ls.sayName(); 这种类式继承的方式可以分为五种对象冒充，Call，Apply，原型链和混合模式 对象冒充构造函数使用 this 关键字给所有属性和方法赋值因为构造函数只是一个函数所以可使Person构造函数成为Author的方法，然后调用它Author就会收到Person的构造函数中定义的属性和方法123456789101112131415161718function Person(name)&#123; this.name = name; this.sayName=function()&#123; console.log(this.name); &#125; &#125;function Author(name,book)&#123; this.book = book; this.Person = Person; this.Person(name); delete this.Person; this.sayBook = function()&#123; console.log(this.book) &#125;&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook(); apply&amp;&amp;call继承call和apply方法通过改变函数上下文实现继承1234567891011121314151617function Person(name)&#123; this.name = name; this.sayName=function()&#123; console.log(this.name); &#125; &#125;function Author(name,book)&#123; this.book = book; Person.call(this,name); Person.apply(this,[name]); this.sayBook = function()&#123; console.log(this.book) &#125;&#125;var Ls = new Author('Ls','My Book'); Ls.sayName(); Ls.sayBook(); 原型链使子类原型对象指向父类的实例以实现继承,即重写类的原型对象123456789101112131415161718function Person()&#123;&#125;Person.prototype.sName = '';Person.prototype.sayName = function () &#123; console.log(this.sName);&#125;;function Author(book)&#123; this.book = book;&#125;Author.prototype = new Person();Author.prototype.sayBook= function()&#123; console.log(this.book);&#125;;var Ls = new Author('My book');Ls.sName = 'Ls';Ls.sayName();Ls.sayBook(); 这种模式无法使用带参数的构造函数，不支持多重继承 混合模式继承用对象冒充继承构造函数的属性，用原型链继承 prototype 对象的方法 12345678910111213141516171819function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(this.name);&#125;;function Author(name,book)&#123; Person.call(this,name); this.book = book;&#125;Author.prototype = new Person();Author.prototype.constructor = Author;Author.prototype.sayBook = function()&#123; console.log(this.book);&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook(); 为了简化类的声明，可以把派生子类的整个过程包装在一个名为extend的函数中空函数F，这样可以避免创建Person的新实例,因为它可能会比较庞大增加superclass这个属性弱化Author与Person之间的耦合并且确保constructor属性被正确设置123456789101112131415161718192021222324252627282930function extend(subClass.superClass)&#123; var F = function()&#123;&#125;; F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass; subClass.superclass = superClass.prototype; if(subClass.prototype.constructor == Object.prototype.constructor)&#123; subClass.prototype.constructor = subClass; &#125;&#125;function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(this.name);&#125;;function Author(name,book)&#123; Author.superclass.constructor.call(this,name); this.book = book;&#125;extend(Author,Person)Author.prototype.sayBook = function()&#123; console.log(this.book);&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook(); JavaScript中的类式继承仅仅是对正正基于类的继承的一种模仿 原型式继承原型式继承与类式继承截然不同它并不需要用类来定义对象结构，只需要创建一个对象这个对象可以被新的对象重用123456789101112131415161718192021222324var Person = &#123; name:'default name', sayName:function()&#123; console.log(this.name); &#125;&#125;var Author = clone(Person);Author.book = 'default book';Author.sayBook = function()&#123; console.log(this.book);&#125;var Ls = clone(Author);Ls.name = 'Ls';Ls.book = 'My Book';Ls.sayName();Ls.sayBook();//clone 通过把F的prototype属性设置为作为参数obj传去的原型对象//函数返回的结果是一个以给定对象为原型对象的空对象function clone(obj)&#123; function F()&#123;&#125; F.prototype = obj; return new F();&#125; Es6 extendsEs6中引入了Class 和extends关键字 1234567891011121314151617181920212223class Person&#123; constructor(name)&#123; this.name = name; &#125; sayName()&#123; console.log(this.name) &#125; &#125;class Author extends Person&#123; constructor(name,book)&#123; super(name); this.book = book; &#125; sayBook()&#123; console.log(this.book); &#125;&#125;var Ls = new Author('Ls','My Book');Ls.sayName();Ls.sayBook();Ls.__proto__ === Author.prototype; //trueAuthor.prototype.__proto__ === Person.prototype; //true","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"},{"name":"Es6","slug":"Es6","permalink":"https://luyi10year.github.io/tags/Es6/"}]},{"title":"Js中的设计模式","date":"2017-01-01T10:09:48.000Z","path":"2017/01/01/js-design-patterns/","text":"整理中","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"}]},{"title":"彻底理解Js中的作用域和上下文","date":"2016-12-30T10:06:06.000Z","path":"2016/12/30/es5-scope-closure/","text":"函数的每次调用都有与之紧密相关的作用域和上下文这俩者是完全不同的作用域(Scope) 是基于函数的作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的而上下文(Context)是基于对象的上下文始终是this关键字的值，它是拥有(控制)当前所执行代码的对象的引用。 作用域(Scope)首先只有函数具有作用域也就是说，在一个函数内部声明的变量在函数外部无法访问JavaScript的作用域是词法性质的这这意味着函数运行在定义它的作用域中而不是在调用它的作用域中12345678910function foo()&#123; var a = 10; function bar()&#123; a *= 2; return a; &#125; return bar;&#125;var baz = foo();baz(); //20 Es6之前 局部变量只能存在于函数体中Es6开始支持let声明变量 局部变量能存在于块级作用域通过var声明的变量会出现变量提升的问题 变量的 声明周期声明阶段(Declaration phase)初始化阶段(Initialization phase) 初始化阶段：variable = undefined赋值阶段(Assignment phase) 赋值阶段后：variable = ‘value’ var变量在函数作用域的开始位置就完成了声明阶段(variable)和初始化阶段(var variable)，这两个阶段之间没有任何间隙let变量通过声明阶段(foo)后，会进去暂时性死区，此时变量不可访问，直到初始化阶段(let foo)之后，变量才可以被访问所以变量提升是变量的耦合声明并且在作用域的顶部完成初始化然而let生命周期中将声明和初始化阶段解耦。这一解耦使 let 的变量提升现象消失。 上下文(Context)上下文通常取决于函数是如何被调用的123456789101112131415161718192021222324252627//当一个函数作为对象中的一个方法被调用的时候,this就设置为调用该方法的对象var foo = &#123; bar:function()&#123; console.log(this === foo) &#125;&#125;foo.bar() // true//当使用new操作符创造对象的实例时,函数的作用域内部this的值被设置为新创建的实例let aThis = [];function foo(x)&#123; this.x = x; aThis.push(this); console.log(this); //foo&#123;x:1&#125; //foo&#123;x:2&#125;&#125;foo.prototype.baz = function()&#123; console.log(this.x); //1 //2&#125;new foo(1);new foo(2);aThis.forEach(function(item)&#123; item.baz();&#125;) 执行环境(execution context)执行环境 定义了变量或函数有权访问的数据，决定它们各自的行为Js是单线程的，当JavaScript解释器初始化执行代码时，会默认进入全局执行环境此后函数的每次调用都会创建一个新的执行环境每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境会被推入一个环境栈中在函数执行完后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个便利的机制控制着执行环境可以分为创建和执行两个阶段。在创建阶段，解析器首先会创建一个变量对象（variable object，也称为活动对象 activation object），它由定义在执行环境中的变量、函数声明、和参数组成。在这个阶段，作用域链会被初始化， this 的值也会被最终确定。在执行阶段，代码被解释执行。 作用域链(scope chain)当代码在一个环境中执行时会创建变量对象的一个作用域链作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问作用域链包含了在环境栈中的每个执行环境对应的变量对象内部环境可以通过作用域链访问所有的外部环境但是外部环境不能访问内部环境中的任何变量和函数这些环境之间的联系是线性的、有次序的 闭包闭包是指有权访问另一函数作用域中的变量的函数在函数内定义一个嵌套的函数时，就构成了一个闭包它允许嵌套函数访问外层函数的变量通过返回嵌套函数，允许你维护对外部函数中局部变量、参数、和内函数声明的访问。12345678910111213141516171819202122232425262728293031323334353637383940414243444546//模块模式最流行的闭包类型之一，它允许你模拟公共的、私有的、和特权成员let Module = (function()&#123; var privateProperty = 'foo'; fucntion privateMethod()&#123; &#125; return &#123; publicProperty:'', publicMethod:function()&#123; &#125;, privilegedMethod: function()&#123; return privateMethod(arguments); &#125; &#125;&#125;)()//另一种类型的闭包被称为 立即执行的函数表达式(IIFE) Es5中(function(window)&#123; var foo, bar; function private()&#123; // do something &#125; var Module = &#123; public: function()&#123; // do something &#125; &#125;; window.Module = Module;&#125;)(this);//保护全局命名空间免受变量污染var baz;(function()&#123; var foo = 10; var bar = 2; baz = function()&#123; return foo * bar; &#125;&#125;)()baz(); //20//保护私用private变量 apply&amp;call&amp;bindapply和call内建在所有的函数中(它们是Function对象的原型方法)允许你在自定义上下文中执行函数不同点在于，call函数需要参数列表，而apply 函数需要你提供一个参数数组1234567891011121314151617181920//argumentsfunction foo()&#123; [].slice.apply(arguments); [].sort.apply(arguments,function(a,b)&#123; return a&gt;b; &#125;)&#125;//apply在传递参数时会将数组转变成列表集合//在一些只能处理列表的方法中可以巧妙地处理//求数组最大值let a = [1,2,3];Math.max(1,2,3); //3Math.max.apply(this,a); //3//两个数组合并let a = [1,2], b = [3,4];//a.push(b)//a [1,2,[3,4]];[].push.apply(a,b)//a [1,2,3,4]; 在ES5中引入了 Function.prototype.bind 方法，用于控制函数的执行上下文，它会返回一个新的函数，并且这个新函数会被永久的绑定到 bind 方法的第一个参数所指定的对象上，无论该函数被如何使用。1234567891011//低版本浏览器，我们可以简单的对它进行实现如下(polyfill)if(!('bind' in Function.prototype))&#123; Function.prototype.bind = function()&#123; var fn = this, context = arguments[0], args = Array.prototype.slice.call(arguments, 1); return function()&#123; return fn.apply(context, args.concat(arguments)); &#125; &#125;&#125; Es6箭头函数S6中的箭头函数可以作为 Function.prototype.bind() 的替代品。和普通函数不同，箭头函数没有它自己的this值，它的 this 值继承自外围作用域。12345678910111213141516171819202122232425var Obj = &#123; baz:.. foo:function()&#123; let self = this; [1,2,4,5].forEach(function(item)&#123; self.baz(item); &#125;) &#125;&#125;//Es5 bindvar Obj = &#123; baz:.. foo:function()&#123; [1,2,4,5].forEach(function(item)&#123; self.baz(item); &#125;.bind(this)) &#125;&#125;//Es6箭头函数var Obj = &#123; baz:.. foo:function()&#123; [1,2,4,5].forEach((item)=&gt;this.baz(item)) &#125;&#125;","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"}]},{"title":"ECMA-prototype","date":"2016-12-28T10:00:00.000Z","path":"2016/12/28/js-object-prototype/","text":"要学好Js，首先必须得先理解原型(prototype)why？js作为面向对象的语言，实现面向对象的机制就是原型！ 都说js中一切皆对象,那到底什么是对象呢？ 对象是属性的集合，并有一个原型对象。原型对象可以是空值。按宿主环境分可以分为原生对象：由ECMAScript规范定义其语义的对象内置对象：由ECMAScript实现提供，独立于宿主环境的对象，ECMAScript程序开始执行时就存在(所有内置对象是原生对象)宿主对象：由宿主环境提供的对象，用于完善ECMAScript执行环境(DOM,BOM)按功能分可以分为：普通对象：无原型对象函数对象：有原型对象(函数对象的一个实例) 我们这里只关注函数对象那么到底什么是原型呢？123456789101112131415161718192021222324252627282930313233//凡是通过new Function() 创建的对象都是函数对象function Bar()&#123;&#125;var foo = function()&#123;&#125;var baz = new Function();//Bar foo baz 都是函数对象//原型对象本质是函数对象的一个实例function Bar()&#123;&#125;Bar.prototypevar temp = new Bar();Bar.prototype = temp;var temp = new Function();Function.prototype = temp//构造器：创建和初始化对象的函数对象(在原型对象prototype中,prototype.constructor)//原型对象prototype中都有个预定义的constructor属性，用来引用它的函数对象//每个由构造器创建的对象拥有一个执行构造器prototype的属性值的隐式引用//这个引用称之为原型//每个原型可以拥有指向自己原型的隐式引用(原型的原型),就是所谓的原型链//每个对象都有一个__proto__属性来实现对原型的隐式引用function Person()&#123;&#125;Person.prototype = &#123; name:'Louis', age:'24'&#125;var person = new Person();person.__proto__ = Person.prototypePerson.prototype.__proto__ = Object.prototypeObject.prototype.__proto__ = null//person对象由构造器Person创建//所以person对Person.prototype有隐式引用(__proto__)//Person对象又是由构造器Object创建//所以Person对Object.prototype有隐式引用(__proto__)","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"},{"name":"原型","slug":"原型","permalink":"https://luyi10year.github.io/tags/原型/"}]},{"title":"你真的学好Js了吗","date":"2016-12-27T02:48:41.000Z","path":"2016/12/27/js-base/","text":"在我看来前端(Js)就好比是个剑客江湖江湖中有人练react宝典，有人练vue神功有人锻造webpack利剑…而Js就是这些的基础心法，决定这些宝典,神功最后在你手上的杀伤力那么作为最基础的心法，你真的参透的了吗？ 这里简单的记录些Js的一些特点 面向对象什么是面向对象 一切事物皆对象 对象具有封装和继承特性 对象与对象之间使用消息通信，各自存在信息隐藏 众所周知Java采用面向对象思想构造其语言，它实现了类、继承、多态、接口等机制。但是这些机制，只是实现面向对象编程的一种方式实际上，Js是通过原型的方式来实现面向对象编程的Js中的对象是依靠构造器(constructor)利用原型(prototype)构造出来的1234567891011121314151617//对象的声明//字面式对象声明var person = &#123; name:'Louis', age:'24'&#125;//使用函数构造器构造对象function Person()&#123;&#125;Person.prototype = &#123; name:'Louis', age:'24'&#125;var person = new Person();//这里的new关键字跟java中 的new毫无关系//只是借用了它的关键字new//用来表示调用构造器创建对象 弱类型语言在Js中，定义变量不必声明其类型。但这不意味着变量没有类型。原始类型：布尔型、数值型、字符串类型引用类型：对象类型(数组是一种特殊的对象)、函数类型其他类型：空类型和未定义类型js中的变量可以根据所附的值改变类型原始类型按值传送，在栈内存中存的是变量的值引用类型则按引用传送，在栈内存中存的是 引用对象在堆内存中的地址所以这里涉及到引用类型深拷贝和浅拷贝的问题1234567891011121314151617181920//浅拷贝 把父对象的属性全部拷贝给子对象//如果父元素的属性对应的值是引用类型，那子对象对应的属性的值还是引用类型的内存地址//这个时候就需要深拷贝function deepCopy(pre)&#123; var ch = pre.constructor === Array ? [] : &#123;&#125;; if(typeof pre !== 'object')&#123; ch = pre; &#125; else if(window.JSON)&#123; ch = JSON.parse(JSON.stringify(pre)) &#125; else&#123; for(var i in pre)&#123; ch[i] = typeof pre[i] === 'object' ? (pre[i].constructor === Array ? pre[i].slice() : deepCopy(pre[i])) : pre[i] &#125; &#125; return ch;&#125; 函数是一等对象在JavaScript中，函数是一等对象可以存储在变量中可以作为参数传给其他函数可以作为返回值从其他函数传出还可以在运行时进行构造可以用function(){…}这样的语法创建匿名函数12345(function()&#123; var foo = 20; var bar = 2; alert(foo*bar);&#125;)() 这个函数在定义后便会立即执行匿名函数可以用来创建闭包闭包是一个受到保护的变量空间由内嵌函数生成 对象的易变性JavaScript中,一切都是对象除了三种原始类型(布尔型、数值型、字符串类型)即便是这几种类型在必要时候也会被自动封装成对象而且所有对象都是易变的(mutable)12345678910111213141516171819202122232425262728//为函数添加属性function dispalyError(message)&#123; dispalyError.numTimesExecuted++; alert(message);&#125;dispalyError.numTimesExecuted = 0;//对定义的类和实例化的对象进行修改function Person(name,age)&#123; this.name = name; this.age = age;&#125;Person.prototype = &#123; getName:function()&#123; return this.name; &#125;, getAge:function()&#123; return this.age; &#125;&#125;var alice = new Person('Alice',39);var bill = new Person('Bill',20);Person.prototype.getGreeting = function()&#123; return 'Hi '+ this.getName()+'!';&#125;alice.displayGreeting = function()&#123; alert(this.getGreeting);&#125; 继承继承在JavaScript中不像在别的面向对象语言中那样简单JavaScript使用的是基于对象的继承它也可以用来模仿基于类的继承Es6中新增了extends实现继承后面会有文章相信讲讲继承","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"}]},{"title":"从实时聊天谈谈通信协议","date":"2016-12-26T04:20:16.000Z","path":"2016/12/26/websockt-chat-node/","text":"作为前端开发人员了解前后端通信协议还是很必须的尤其是在用Node写服务端的时候对于请求的响应处理和返回有很大的帮助客户端与服务端的通信协议有HTTP(HTTPS)协议和WebSocket协议HTTP协议是无状态的，服务端进行处理返回response后很难主动向客户端发送数据WebSocket协议实现了客户端与服务端的全双工通信扩展了客户端与服务端的通信功能使服务端也能主动向客户端发送数据在WebSocket协议提出之前要实现即时通信、实时数据这样的功能，经常会使用轮询(polling)和Comet技术 轮询是最原始的实现实时Web应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。明显地，这种方法会导致过多不必要的请求，浪费流量和服务器资源 Comet技术又可以分为长轮询和流技术。长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个HTTP长连接，服务端会不断更新连接状态以保持HTTP长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。 WebSocket，真正实现了Web的实时通信 Http协议HTTP(Hypertext Transfer Protocol 超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议HTTP限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP的常用请求方法GET 请求获取Request-URI所标识的资源POST 在Request-URI所标识的资源后附加新的数据HEAD 请求获取由Request-URI所标识的资源的响应消息报头 请求和响应都包含请求头或响应头header和可选的请求体或响应体Body(自由的文本)只有POST请求包含一个BodyContent-type常用的MiME类型application/x-wwwform-urlencoded 经过编码的键值对请求字符串(Body)，web服务器需要解码字符串获得参数text/xml,application/xml Body是XML文档text/plain 普通文本text/html, text/xhtml Body是(X)HTML内容，web服务器端发送的标准web页面或内容片段text/javascript Body是一段JavaScript代码image/png, image/jpeg, image/gif：Body是二进制图像 HTTPS协议HTTPS(Secure Hypertext Transfer Protocol 安全超文本传输协议)是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版。HTTP协议是不安全的，可以轻松对窃听你跟 Web 服务器之间的数据传输在很多情况下，客户和服务器之间传输的是敏感信息，需要防止未经授权的访问 HTTPS协议在TCP协议上加了层SSL协议 网络七层协议应用层 Http Https表示层 SSL TLS会话层传输层 TCP网络层 IP数据链路层物理层 SSL 包含如下动作：1.验证服务器端2.允许客户端和服务器端选择加密算法和密码，确保双方都支持3.验证客户端(可选)4.使用公钥加密技术来生成共享加密数据5.创建一个加密的 SSL 连接6.基于该 SSL 连接传递 HTTP 请求 TCP协议TCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议连接时三次握手第一次Client端发送SYN报文请求连接第二次Server端接受连接后回复ACK报文，并且为这次连接分配资源第三次Client端接收ACK报文后向Server端发送ACK报文，并分配资源TCP连接建立 断开时四次握手第一次Client发起中断连接，发送FIN报文第二次Server端接到FIN报文后，发送ACK报文，(可能还有数据没有传输完)，Client进入FIN_WAIT状态第三次Server端确定数据已经发送完成，则向Client端发送FIN报文，准备好关闭连接第四次Client端接收FIN报文,知道可以关闭连接，但不相信网络,怕Server端不知道要关闭，发送ACK报文，并进入TIME_WAIT状态Server端收到ACK报文后断开连接Client端等待了一定时间(依赖实现方法)后，没有收到Server回复，表示Server端已正常关闭，Client端也关闭链接TCP连接关闭 AJAXAJAX (Asynchronous Javascript And XML 异步JavaScript和XML)，是指一种创建交互式网页应用的网页开发技术。1234567891011121314151617181920212223242526272829303132333435363738394041424344/** open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求* method：请求的类型；GET 或 POST* url：文件在服务器上的位置* async：true（异步）或 false（同步）** send(string) 将请求发送到服务器* string：仅用于 POST 请求** setRequestHeader(header,value) 向请求添加 HTTP 头* header: 规定头的名称* value: 规定头的值** responseText 获得字符串形式的响应数据。* responseXML 获得XML形式的响应数据。** onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数** readyState 存有 XMLHttpRequest 的状态 从 0 到 4 发生变化* 0: 请求未初始化* 1: 服务器连接已建立* 2: 请求已接收* 3: 请求处理中* 4: 请求已完成，且响应已就绪** status* 200: \"OK\"* 404: 未找到页面* */var xmlhttp = new XMLHttpRequest();xmlhttp.open('POST',url,true);xmlhttp.setRequestHeader('Content-type','application/x-www-form-urlencoded');xmlhttp.send('page=2&amp;size=10');xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.readystate == 4)&#123; if(xmlhttp.status == 200)&#123; console.log(xmlhttp.responseText); &#125; else&#123; //异常 &#125; &#125;&#125; websocketwebsocket协议本质上是一个基于TCP的协议是先通过HTTP/HTTPS协议发起一条特殊的HTTP请求进行握手后创建一个用于交换数据的TCP连接此后服务端与客户端通过此TCP连接进行实时通信 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//客户端var ws = new WebSocket('ws://localhost:8181/');//连接发生错误的回调方法ws.onerror = function()&#123;&#125;//websocket 在任何时候都会处于下面4种状态中的其中一种//CONNECTING (0) 表示还没建立连接//OPEN (1) 已经建立连接，可以进行通讯//CLOSING (2) 通过关闭握手，正在关闭连接//CLOSED (3) 连接已经关闭或无法打开//WebSocket.OPEN = 1;//连接成功建立的回调方法ws.onopen = function(e)&#123; if(ws.readyState === 1)&#123; wsSend('msg'); &#125;&#125;//接收到消息的回调方法ws.onmessage = function(e)&#123; //e.data&#125;//连接关闭的回调方法ws.onclose = function()&#123;&#125;function wsSend(rs)&#123; ws.send(rs);&#125;function wsEnd()&#123; ws.close();&#125;//服务端(Node)var WebSocketServer = require('ws').Server, ws = new WebSocketServer(&#123; port: 8181 &#125;), clients = [], clientNum = 0;ws.on('connection',function(ws)&#123; clientNum ++; clients.push(&#123;'ws':ws&#125;); ws.on('message',function(rs)&#123; wsSend(rs); &#125;)&#125;)function wsSend(rs)&#123; for(var i =0;i&lt;clients.length;i++)&#123; var clientSocket = clients[i].ws; if (clientSocket.readyState === 1) &#123; clientSocket.send(JSON.stringify(rs)); &#125; &#125;&#125;","tags":[{"name":"Node","slug":"Node","permalink":"https://luyi10year.github.io/tags/Node/"},{"name":"websocket","slug":"websocket","permalink":"https://luyi10year.github.io/tags/websocket/"}]},{"title":"Git自动化部署","date":"2016-12-22T09:42:46.000Z","path":"2016/12/22/automated-deployment/","text":"每次更新完博客,得先push到github上然后在服务器上把代码pull下来部署 一开始 忍了后来 够了 (码字太累，来首震撼的歌) 整理一下需要的是本地push成功后服务器上能自动执行pull命令那么问题就变成了如何响应每次的push操作? WebHooksWebhook就是用户通过自定义回调函数的方式来改变Web应用的一种行为，这些回调函数可以由不是该Web应用官方的第三方用户或者开发人员来维护，修改。通过Webhook，你可以自定义一些行为通知到指定的URL去。 那么每次push时候接受到请求，然后执行pull脚本，问题就解决了 github配置github 支持webhook在github项目中选择settingwebhooksPayload URL 请求地址Content type 请求类型Secret 密文(请求之后用作校验) 请求处理通过node接受请求作出响应 1234567891011121314151617181920212223var http = require('http')var createHandler = require('github-webhook-handler')var handler = createHandler(&#123; path: '/deploy', secret: '' &#125;)http.createServer(function (req, res) &#123; handler(req, res, function (err) &#123; res.statusCode = 404 res.end('no such location') &#125;)&#125;).listen(8989)handler.on('error', function (err) &#123; console.error('Error:', err.message)&#125;)handler.on('push', function (event) &#123; // 调用pull脚本 process.exec('git pull origin master', function (error, stdout, stderr) &#123; if (error !== null) &#123; console.log('exec error: ' + error); &#125; &#125;);&#125;) 这个时候每次push的时候，会发送一个请求到 url:8989/deylop通过node 服务会作出相应操作 服务器部署nginx 方向代理将8989 代理到80端口12345678server &#123; listen 80; server_name ''; location /deploy &#123; proxy_pass http://localhost:8989; &#125; &#125; 通过forever 启动node 服务","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luyi10year.github.io/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"https://luyi10year.github.io/tags/Git/"},{"name":"服务器","slug":"服务器","permalink":"https://luyi10year.github.io/tags/服务器/"}]},{"title":"谈谈","date":"2016-12-20T06:29:27.000Z","path":"2016/12/20/diary-2016-1220-1430/","text":"","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://luyi10year.github.io/tags/杂谈/"}]},{"title":"1px != 1px -- 移动端适配浅析","date":"2016-12-19T09:28:08.000Z","path":"2016/12/19/rem-layout/","text":"css中我们一般使用px作为单位在pc上css中的1个像素往往对应着电脑屏幕中的1个物理像素这可能会给我们造成一个错觉css中的像素等于设备的物理像素但实际情况却并非如此css中的像素只是一个抽象的单位在不同的设备或不同的环境中css中的1px所代表的设备物理像素是不同的典型的就是retina屏 首先我们先了解几个概念 viewportviewport 是用户网页的可视区域pc中就是屏幕宽度移动设备中viewport(这个虚拟窗口)比屏幕宽 一般为9801234567891011&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;移动端布局viewport的宽度设为理想宽度layout viewport 默认的viewport 比屏幕宽 document.documentElement.clientWidthvisual viewport 浏览器可视区域的大小 window.innerWidthideal viewport 最适合移动设备的viewportwidth：控制 viewport 的大小，可以指定的一个值，如果 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。height：和 width 相对应，指定高度。initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。maximum-scale：允许用户缩放到的最大比例。minimum-scale：允许用户缩放到的最小比例。user-scalable：用户是否可以手动缩放。 物理像素(physical pixel)一个物理像素是显示器(手机屏幕)上最小的物理显示单元在操作系统的调度下每一个设备像素都有自己的颜色值和亮度值。 设备独立像素(density-independent pixel)设备独立像素(也叫密度无关像素)可以认为是计算机坐标系统中得一个点这个点代表一个可以由程序使用的虚拟像素(比如: css像素)简单点就是屏幕宽高 设备像素比(device pixel ratio)设备像素比 ＝ 物理像素 / 设备独立像素5,6的dpr=2，1个css像素等于2个物理像素6p的dpr=3,1个css像素等于3个物理像素 那首先我们在移动端布局，viewport肯定不能是默认的值最终viewport宽度等于应该等于设备的宽度我们的布局视图应该是 按照物理像素来布局设备独立像素可获得设备像素比 window.devicePixelRatio现在假设 在iphone6上布局 此时dpr = 2,dip = 375物理像素应该是 dpr * dip = 750div{ border-top:1px solid #000;}现在在页面上要实现一个1px的上边框由于移动端布局viewport缩成设备宽度而分辨率没有变所以这时的1px会有2px的效果 这个时候可以手动将viewport 宽度设成物理像素的宽度，然后将整个页面缩小 dpr 倍 1px 的问题解决了，那如何解决在不同手机显示设计稿中的一个100x100的div设计稿 750其中div 100x100750的设计稿对应的是iPhone6结合上面viewport的缩放div{ width:100px; height:100px;}在6上跟设计稿是完全相同的而在5(640)上会变大 这个时候可以通过rem在不同设备上动态计算出比例值 假设在750设计稿中 1rem = 100px那么在640设计稿中 1rem = 640/750*100px此时1rem 不管在5上还是6上显示都完全跟在设计稿中显示效果相同1234567891011121314//html&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;//动态计算remvar domDocEL = window.document.documentElement, mateViewPort = window.document.querySelector('meta[name=\"viewport\"]'), nBasePsdWidth = 750 / 100, nDpr = window.devicePixelRatio, nScale = 1 / nDpr, nLayout = domDocEL.clientWidth, nRem = nLayout * nDpr / nBasePsdWidth;domDocEL.style.fontSize = rem +'px';mateViewPort.setAttribute('content','width='+nDpr*nLayout+',initial-scale='+nScale+',maximum-scale='+nScale+',minimum-scale='+nScale+',user-scalable=no'); 对于字体可以用写个mixin方法根据不同的dpr设置字号12345@mixin px2rem($name,$px) &#123; [data-dpr=\"2\"] &amp; &#123; #&#123;$name&#125;: $px*2/2+px; &#125; &#125; 总结移动端布局将viewport设成物理像素的大小,然后在缩放为dpr的倒数倍。dpr不存在？简单点~~~那就指定为1！","tags":[{"name":"H5","slug":"H5","permalink":"https://luyi10year.github.io/tags/H5/"},{"name":"Rem","slug":"Rem","permalink":"https://luyi10year.github.io/tags/Rem/"}]},{"title":"react","date":"2016-12-18T05:50:35.000Z","path":"2016/12/18/react/","text":"整理整理思绪在props里使用 onClick={ this.handleClick.bind(this) }或者 onClick={ (e) =&gt; this.handleClick(e) }或者 onClick={ ::this.handleClick }都会产生性能问题，所以现在eslint在语法检查时就会阻止这几种写法，问题原因是每一次render的时候如果遇到这些写法，都会重新用handleClick函数与this去绑定从而重新创建一个新的函数，影响性能。如果使用下面的写法则不会每次都创建：// 1.constructor() { this.handleClick = this.handleClick.bind(this);}handleClick(e) { / … / }// 2.handleClick = (e) =&gt; { / … / }; 箭头函数不能用？Parsing error: Unexpected token =babel-eslint","tags":[{"name":"react","slug":"react","permalink":"https://luyi10year.github.io/tags/react/"}]},{"title":"vue","date":"2016-12-17T05:50:25.000Z","path":"2016/12/17/vue/","text":"整理整理思绪","tags":[{"name":"vue","slug":"vue","permalink":"https://luyi10year.github.io/tags/vue/"}]},{"title":"webpack","date":"2016-12-16T06:29:27.000Z","path":"2016/12/16/webpack/","text":"关于webpack的教程网上一抓一大把就不班门弄斧了这里只是总结一些webpack的实用配置以及个人心得 entry&amp;output12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849enpty:&#123; index:'./index.js', more:['./more2.js','./more.js'], vendor: ['react', 'react-dom', 'react-router']&#125;putput:&#123; path:'./build', filename:'[name]-[id].js', publicPath:'/assets/', chunkFilename:'[name]-[chunkhash]'&#125;//[id], chunk的id//[name] ,chunk名//[hash], 编译哈希值//[chunkhash] , chunk的hash值 根据模块内容//output.publicPath：设置为想要的资源访问路径。//访问时，则需要通过类似http://localhost:8080/asstes/index-1.js来访问资源，//如果没有设置，则默认从站点根目录加载。//filename应该比较好理解，就是对应于entry里面生成出来的文件名。比如：&#123; entry: &#123; \"index\": \"pages/index.jsx\" &#125;, output: &#123; filename: \"[name].min.js\", chunkFilename: \"[name].min.js\" &#125;&#125;//生成出来的文件名为index.min.js。//chunkname我的理解是未被列在entry中，//却又需要被打包出来的文件命名配置。//什么场景需要呢？我们项目就遇到过，在按需加载（异步）模块的时候，//这样的文件是没有被列在entry中的，如使用CommonJS的方式异步加载模块：require.ensure([\"modules/tips.jsx\"], function(require) &#123; var a = require(\"modules/tips.jsx\"); // ...&#125;, 'tips');//异步加载的模块是要以文件形式加载哦，//所以这时生成的文件名是以chunkname配置的，//生成出的文件名就是tips.min.js。//（require.ensure() API的第三个参数是给这个模块命名，//否则 chunkFilename: \"[name].min.js\" 中的 [name] 是一个自动分配的、可读性很差的id，//这是我在文档很不起眼的地方788发现的。。。）new webpack.optimize.CommonsChunkPlugin(&#123; names: ['vendor'],&#125;) url-loader1234test: /\\.(gif|jpg|png)$/,loader: 'url-loader?limit=1024&amp;name=img/[name].[ext]'//小于1024字节 采用base64//大于1024字节 正常打包到output目录下img文件夹中 js-loader1234567891011121314151617181920212223242526272829303132 //babel //配置 .babelrc //.rc run command 程序启动阶段被调用 //执行babal-loader时自动执行 &#123; \"presets\": [\"es2015\", \"stage-2\"], \"plugins\": [ \"transform-class-properties\", \"transform-runtime\" ] &#125; //webpack.config.js &#123; test: /\\.js$/, exclude: /node_modules/, loader:'babel' &#125;,//不使用.babelrc &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: &#123; presets: [\"es2015\", \"stage-2\"], plugins: [ \"transform-class-properties\", \"transform-runtime\" ] &#125; &#125;, vue-loader1234567891011121314151617181920&#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/,&#125;&#123; test:/\\.vue$/, loader:'vue',&#125;babel: &#123; presets: ['es2015'], plugins: [\"transform-class-properties\", \"transform-runtime\"]&#125;,vue:&#123; loaders:&#123; js:'babel', scss:['vue-style-loader','css','sass'].join('!') &#125;&#125;, css-loaderloader 采取管道流1loader: ['style','css','scss'].join('!') 提取样式到单独文件 插件 extract-text-webpack-plugin1234567891011var ExtractTextPlugin = require('extract-text-webpack-plugin');&#123; test: /\\.(scss|sass|css)$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader')&#125;plugins: [ new ExtractTextPlugin('[name].css') //output目录下 ], css样式自动 fix 插件 autoprefixer(postcss插件) 12345678910111213141516&#123; test: /\\.(scss|sass|css)$/, loader: ExtractTextPlugin.extract('style-loader', ['css-loader', 'postcss-loader']) &#125;const AUTOPREFIXER_BROWSERS = [ 'Android &gt;= 4', 'Chrome &gt;= 35', 'Firefox &gt;= 31', 'Explorer &gt;= 9', 'iOS &gt;= 7', 'Opera &gt;= 12', 'Safari &gt;= 7.1'] postcss: function() &#123; return [autoprefixer(&#123; browsers: AUTOPREFIXER_BROWSERS &#125;)]; &#125;, file-loader1234&#123; test: /\\.(woff|svg|eot|ttf).$/, loader: \"file-loader?name=fonts/[name].[ext]\"&#125; resolve12345678910111213141516171819var moment = require('moment');//编译很慢 也就是说，请求的是 moment 的源码。//实际上，通过 NPM 安装 moment 的时候会同时安装 moment 的源码和压缩后的代码//var moment = require('moment/min/moment-with-locales.min.js');//只不过这样改，可读性会有所下降，//而且每一个用到 moment 的地方都得这么写。//另外，如果同样的问题出现在第三方模块中，修改别人代码就不那么方便了。//下面来看看用 Webpack 怎么解决这个问题。 resolve: &#123; alias: &#123; moment: \"moment/min/moment-with-locales.min.js\" &#125; &#125;//可以用 alias 指定从非npm引入的库，如jquery: path.resolve(__dirname, './bower_components/jquery/dist/jquery.js') ，这样在 import 时可以替换引用路径// require时省略的扩展名，如：require('app') 不需要app.jsextensions: ['','.js','.vue','.scss'], noParsemodule.noParse 是 webpack 的另一个很有用的配置项，如果你 确定一个模块中没有其它新的依赖 就可以配置这项，webpack 将不再扫描这个文件中的依赖。123module: &#123; noParse: [/moment-with-locales/] &#125; devtool通常，JavaScript的解释器会告诉你，第几行第几列代码出错。但是，这对于转换后的代码毫无用处。举例来说，jQuery 1.9压缩后只有3行，每行3万个字符，所有内部变量都改了名字。你看着报错信息，感到毫无头绪，根本不知道它所对应的原始位置。这就是Source map想要解决的问题。1devtool: '#source-map' hot reload12345678910111213//package.json\"scripts\": &#123; \"dev\": \"webpack-dev-server --devtool eval-source-map --progress --colors --hot --inline\", &#125;,--content-base 内容基本路径 不加默认当前目录--colors 输出加颜色path: \"./dist\",filename: \"[name].js\",publicPath: \"abababab\",publicPath 必须设置 这里设置什么名 html里引用就写什么名字&lt;script src=\"/abababab/main.js\"&gt;&lt;/script&gt;npm run dev webpack -w12345//webstrom 会在临时文件夹中创建一个文件用来保存(好像没有出发实际文件的变更)settingAppearance &amp; BehaviorSystem SettingsUse \"safe write\"(save changes to a temporary file first) 勾去掉","tags":[{"name":"webpack","slug":"webpack","permalink":"https://luyi10year.github.io/tags/webpack/"}]},{"title":"学点运维，配个服务器","date":"2016-12-15T09:08:08.000Z","path":"2016/12/15/aliyun/","text":"前段时间和同事合租了一个阿里云服务器，60几块钱一个月。服务器上的资源环境很多都是他配的，作为前端，只是在上面放点静态的东西，也没太大兴趣在这方面去摸索然后这货今天离职了。 走之前，悠悠然发了我一个连接阿里云搞活动 传送门 服务器免费赠送6个月 果断入手(要买个9块钱的套餐) 然后买域名解析DNS配nginx装git搭node 也算是小入门了 But 我想说的是作为一个开发人员and 一个合格的开发人员首先具备的应该是解决问题，查找问题的能力 而不是一有问题不假思索的问别人有时候多学一样本领,就早说一句求人的话 作为我们作为初学者总会碰到各种各样的问题那么，怎么解决？ 举个栗子linux git的安装 忽略前面下载解压过程 ./configure –prefix=/usr/localmake &amp; make install 果断报错。。OK 下载各种依赖报错继续安装成功git –version嗯 有版本号easy嘛然后 来 git clone ..error:fatal: Unable to find remote helper for ‘https’又报错，奔溃 这是因为Git环境没有安装完全，需要重新安装 ./configure –prefix=/usr/localmake all docmake install install-doc install-man install-html 继续 OK问题解决 那么这解决问题的过程 就比解决问题来的跟有用前提是问题是你自己解决的","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luyi10year.github.io/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"https://luyi10year.github.io/tags/Git/"},{"name":"服务器","slug":"服务器","permalink":"https://luyi10year.github.io/tags/服务器/"}]},{"title":"In city","date":"2016-12-14T10:40:08.000Z","path":"2016/12/14/in-city/","text":"悠然随心随性随缘杭州，省会美丽的西湖（我也只去过西湖。。）一年前，在这我开启了前端之旅 那谁说过，在风口，是只猪也能飞起来。何况是在杭州这样的互联网台风中。。 但是风过了，依然在飞的却是鹰 麻雀从不担心树枝会断因为他相信的不是树枝而是自己的翅膀 身处互联网大时代机会很多，机遇很多首先飞起来然后去充实自己不断学习不断进步 最后风即使过了我们也进化成了鹰","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://luyi10year.github.io/tags/杂谈/"}]},{"title":"Node-Spider","date":"2016-12-13T10:41:55.000Z","path":"2016/12/13/node-spider/","text":"Node学习入门，练习爬虫再适合不过了这里通过爬区某图片网站近(10万张图片)的例子，介绍爬虫的过程 爬虫分析设计抓取的是 ‘http://www.mzitu.com‘ 网站图片大致有五个类目每个类目下分页规则http://www.mzitu.com/类目/page/1http://www.mzitu.com/类目/page/2 每一个有25个专题专题详情页 http://www.mzitu.com/专题id专题详情页分页规则http://www.mzitu.com/专题id/1http://www.mzitu.com/专题id/2 因此第一次鉴于此 爬虫设计如下先获取单个类目下专题(图片和Id)专题图片根据 类目/当前page数/图片 路径保存将获取的id暂存知道获取完全部全部类目专题然后开始获取专题详情确定要获取的专题详情的所有分页数最后爬区所有分页数 用到的模块1234var superagent = require('superagent'); //请求封装模块var async = require('async'); //并发控制模块var cheerio = require('cheerio'); //抓取页面dom节点模块var fs = require(\"fs\"); 数据准备12345678var sUrl = 'http://www.mzitu.com'; //爬取目标var aItems = []; //单个类目下需要爬取的链接var aTagList = ['/','/xinggan','/japan','/taiwan','/mm']; //所有类目var aDirList = ['index','xinggan','japan','taiwan','mm']; //爬取存放路径var nCurrentTag = 0; //当前爬取类目var aIdList = []; //专题Idvar aNextPage = []; //专题详情var aNxtItems = []; //专题详情下需要爬区的链接 获取所有专题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127function start(page)&#123; superagent .get(page) .end(function (err, response) &#123; if (err) &#123; console.log(err.status); &#125; if (response.status === 200) &#123; var $ = cheerio.load(response.text); &#125; var nPageLen = $('.nav-links a.next').prev().text(); // 获取页数 for(var i = 0;i &lt; nPageLen ;i++)&#123; aItems.push(page+'/page/'+(i+1)); &#125; var sName = page.replace('http://www.mzitu.com',''); sName = sName ? sName : 'index'; // 新建类目 存放目录 fs.mkdir(__dirname+'/uploa/'+sName.replace('/',''),function(err)&#123; if(err)&#123; throw err &#125; &#125;) fetchPage(); &#125;);&#125;function fetchPage()&#123; var concurrencyCount = 0; var fetchUrl = function(url,callback)&#123; var fetchStart = new Date().getTime(); concurrencyCount++; console.log('并发数'+concurrencyCount+'====url:'+url); superagent.get(url) .end(function(err,res)&#123; if(err)&#123; // callback(err,url); // return next(err); &#125; var time = new Date().getTime() - fetchStart; // console.log('抓取'+url+'成功,耗时'+time) concurrencyCount--; if(res.status === 200)&#123; var $ = cheerio.load(res.text); &#125; //爬取数据处理 getDetail($,url,function(rs)&#123; // _html += rs; &#125;) callback(); &#125;) &#125; // 控制并发数 async.mapLimit(aItems,5,function(myUrl,callback)&#123; fetchUrl(myUrl,callback); &#125;,function(err,result)&#123; nCurrentTag++; if(nCurrentTag &lt; aTagList.length)&#123; // console.log('====================开始抓取下一个类目===================='); aItems = []; start(sUrl+aTagList[nCurrentTag]); &#125; else&#123; console.log('====================开始抓取详情页========================='); // getNextPage(); &#125; &#125;)&#125;function getDetail($,url,callback)&#123; //确定图片名称 var dirList = url.replace('http://www.mzitu.com/','').split('/'); var dirName = dirList[0]+'/'+dirList[1]+dirList[2]; if(dirList.length &lt; 3)&#123; dirName = 'index/'+dirList[0]+dirList[1]; &#125; var domItemA = $('#pins li a'); // 获取Id var domItem = $('#pins li a img'); //获取图片 var srcList = [] domItem.each(function(idx,element)&#123; var $ele = $(element); var src = $ele.attr('data-original'); var id = $ele.parent().attr('href').replace('http://www.mzitu.com/',''); aSrcList.push(src); aIdList.push(id); &#125;) // 下载专题图片 downImg(aSrcList,dirName);&#125;function downImg(list,dirName)&#123; fs.mkdir(__dirname+'/upload/'+dirName,function(err)&#123; if(err)&#123; throw err &#125; &#125;) var savePath = __dirname+'/uploa/'+dirName+'/' + narr[0] +'_'+ narr[1] + '_' + narr[2]; function binaryParser(res, callback) &#123; res.setEncoding('binary'); var imgData = ''; res.on('data', function (chunk) &#123; imgData += chunk; &#125;); res.on('end', function () &#123; fs.writeFile(savePath, new Buffer(imgData, 'binary'),function(err) &#123; if(err) &#123; console.log(err); &#125; console.log(url+'下载成功') &#125;); &#125;); &#125; var downUrl = function(url,callback)&#123; var narr = url.replace(\"http://i.meizitu.net/thumbs/\", \"\").split(\"/\") supergent.get(url) // .pipe(fs.createWriteStream(savePath)) .parse(binaryParser) .end(function(err,res)&#123; &#125;) &#125; async.mapLimit(list,5,function(myUrl,callback)&#123; downUrl(myUrl,callback); &#125;,function(err,result)&#123; &#125;)&#125;","tags":[{"name":"Node","slug":"Node","permalink":"https://luyi10year.github.io/tags/Node/"}]},{"title":"Node-Module-API","date":"2016-12-13T08:12:42.000Z","path":"2016/12/13/node-module-api/","text":"","tags":[{"name":"Node","slug":"Node","permalink":"https://luyi10year.github.io/tags/Node/"}]},{"title":"Node-server","date":"2016-12-13T07:43:25.000Z","path":"2016/12/13/node-server/","text":"用Node搭建一个静态资源访问服务器 用到的模块1234var http = require('http'), url = require('url'), path = require('path'), fs = require('fs'); 思路 获取访问路径，以文件后缀判断文件类型12345678910111213var mimetype = &#123; 'txt': 'text/plain', 'html': 'text/html', 'css': 'text/css', 'xml': 'application/xml', 'json': 'application/json', 'js': 'application/javascript', 'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'gif': 'image/gif', 'png': 'image/png', 'svg': 'image/svg+xml'&#125; 获取请求的时候判断请求文件是否存在，决定返回的类型 123456789101112131415161718192021222324http.createServer(function(req,res)&#123; var pathname = url.parse(req.url).pathname, realPath = path.join(__dirname,'/static',pathname); var body = []; req.on('data',function(data)&#123; body.push(data); &#125;) req.on('end',function()&#123; body = Buffer.concat(body); &#125;) fs.exists(realPath,function(ex)&#123; if(ex)&#123; var rs = fs.createReadStream(realPath); res.writeHead(200,&#123; 'Content-Type':mimetype[realPath.split('.').pop()] || 'text/plain' &#125;) rs.on('data',res.write.bind(res)) rs.on('close',res.end.bind(res)); &#125; else&#123; page_404(req,res,realPath); //错误页面 &#125; &#125;)&#125;).listen(3000) 请求不存在 1234567891011121314function page_404(req,res,path)&#123; res.writeHead(404,&#123; 'Content-Type':'text/html' &#125;) res.write('&lt;!doctype html&gt;\\n'); res.write('&lt;title&gt;404 Not Found&lt;/title&gt;\\n'); res.write('&lt;h1&gt;Not Found&lt;/h1&gt;'); res.write( '&lt;p&gt;The requested URL ' + path + ' was not found on this server.&lt;/p&gt;' ); res.end();&#125;","tags":[{"name":"Node","slug":"Node","permalink":"https://luyi10year.github.io/tags/Node/"}]},{"title":"Node-各个模块","date":"2016-12-12T10:41:55.000Z","path":"2016/12/12/node-base/","text":"NodeNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 哈哈 先占上到时候再补","tags":[{"name":"Node","slug":"Node","permalink":"https://luyi10year.github.io/tags/Node/"}]}]