[{"title":"谈谈js的继承","date":"2017-01-03T03:53:25.000Z","path":"2017/01/03/es5-es6-extends/","text":"js中的继承 类式继承原型链继承Es6 extends","tags":[{"name":"Es6","slug":"Es6","permalink":"https://luyi10year.github.io/tags/Es6/"},{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"}]},{"title":"Js中的设计模式","date":"2017-01-01T10:09:48.000Z","path":"2017/01/01/js-design-patterns/","text":"","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"}]},{"title":"Js中的作用域和闭包","date":"2016-12-30T10:06:06.000Z","path":"2016/12/30/es5-scope-closure/","text":"","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"}]},{"title":"ECMA-prototype","date":"2016-12-28T10:00:00.000Z","path":"2016/12/28/js-object-prototype/","text":"要学好Js，首先必须得先理解原型(prototype)why？js作为面向对象的语言，实现面向对象的机制就是原型！ 都说js中一切皆对象,那到底什么是对象呢？ 对象是属性的集合，并有一个原型对象。原型对象可以是空值。按宿主环境分可以分为原生对象：由ECMAScript规范定义其语义的对象内置对象：由ECMAScript实现提供，独立于宿主环境的对象，ECMAScript程序开始执行时就存在(所有内置对象是原生对象)宿主对象：由宿主环境提供的对象，用于完善ECMAScript执行环境(DOM,BOM)按功能分可以分为：普通对象：无原型对象函数对象：有原型对象(函数对象的一个实例) 我们这里只关注函数对象 1234567891011121314151617181920212223242526272829303132//凡是通过new Function() 创建的对象都是函数对象function Bar()&#123;&#125;var foo = function()&#123;&#125;var baz = new Function();//Bar foo baz 都是函数对象//原型对象本质是函数对象的一个实例function Bar()&#123;&#125;Bar.prototypevar temp = new Bar();Bar.prototype = temp;//构造器：创建和初始化对象的函数对象(在原型对象prototype中,prototype.constructor)//原型对象prototype中都有个预定义的constructor属性，用来引用它的函数对象//每个由构造器创建的对象拥有一个执行构造器prototype的属性值的隐式引用//这个引用称之为原型//每个原型可以拥有指向自己原型的隐式引用(原型的原型),就是所谓的原型链//每个对象都有一个__proto__属性来实现对原型的隐式引用function Person()&#123;&#125;Person.prototype = &#123; name:'Louis', age:'24'&#125;var person = new Person();person.__proto__ = Person.prototypePerson.prototype.__proto__ = Object.prototypeObject.prototype.__proto__ = null//person对象由构造器Person创建//所以person对Person.prototype有隐式引用(__proto__)//Person对象又是由构造器Object创建//所以Person对Object.prototype有隐式引用(__proto__)","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"},{"name":"原型","slug":"原型","permalink":"https://luyi10year.github.io/tags/原型/"}]},{"title":"你真的学好Js了吗","date":"2016-12-27T02:48:41.000Z","path":"2016/12/27/js-base/","text":"在我看来前端(Js)就好比是个剑客江湖江湖中有人练react宝典，有人练vue神功有人锻造webpack利剑…而Js就是这些的基础心法，决定这些宝典,神功最后在你手上的杀伤力那么作为最基础的心法，你真的参透的了吗？ 这里简单的记录些Js的一些特点 面向对象什么是面向对象 一切事物皆对象 对象具有封装和继承特性 对象与对象之间使用消息通信，各自存在信息隐藏 众所周知Java采用面向对象思想构造其语言，它实现了类、继承、多态、接口等机制。但是这些机制，只是实现面向对象编程的一种方式实际上，Js是通过原型的方式来实现面向对象编程的Js中的对象是依靠构造器(constructor)利用原型(prototype)构造出来的1234567891011121314151617//对象的声明//字面式对象声明var person = &#123; name:'Louis', age:'24'&#125;//使用函数构造器构造对象function Person()&#123;&#125;Person.prototype = &#123; name:'Louis', age:'24'&#125;var person = new Person();//这里的new关键字跟java中 的new毫无关系//只是借用了它的关键字new//用来表示调用构造器创建对象 弱类型语言在Js中，定义变量不必声明其类型。但这不意味着变量没有类型。原始类型：布尔型、数值型、字符串类型引用类型：对象类型(数组是一种特殊的对象)、函数类型其他类型：空类型和未定义类型js中的变量可以根据所附的值改变类型原始类型按值传送，在栈内存中存的是变量的值引用类型则按引用传送，在栈内存中存的是 引用对象在堆内存中的地址所以这里涉及到引用类型深拷贝和浅拷贝的问题1234567891011121314151617181920//浅拷贝 把父对象的属性全部拷贝给子对象//如果父元素的属性对应的值是引用类型，那子对象对应的属性的值还是引用类型的内存地址//这个时候就需要深拷贝function deepCopy(pre)&#123; var ch = pre.constructor === Array ? [] : &#123;&#125;; if(typeof pre !== 'object')&#123; ch = pre; &#125; else if(window.JSON)&#123; ch = JSON.parse(JSON.stringify(pre)) &#125; else&#123; for(var i in pre)&#123; ch[i] = typeof pre[i] === 'object' ? (pre[i].constructor === Array ? pre[i].slice() : deepCopy(pre[i])) : pre[i] &#125; &#125; return ch;&#125; 函数是一等对象对象易变继承","tags":[{"name":"js","slug":"js","permalink":"https://luyi10year.github.io/tags/js/"}]},{"title":"Let Chat","date":"2016-12-26T04:20:16.000Z","path":"2016/12/26/websockt-chat-node/","text":"简易聊天 https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket","tags":[{"name":"Node","slug":"Node","permalink":"https://luyi10year.github.io/tags/Node/"},{"name":"websocket","slug":"websocket","permalink":"https://luyi10year.github.io/tags/websocket/"}]},{"title":"Git自动化部署","date":"2016-12-22T09:42:46.000Z","path":"2016/12/22/automated-deployment/","text":"每次更新完博客,得先push到github上然后在服务器上把代码pull下来部署 一开始 忍了后来 够了 (码字太累，来首震撼的歌) 整理一下需要的是本地push成功后服务器上能自动执行pull命令那么问题就变成了如何响应每次的push操作? WebHooksWebhook就是用户通过自定义回调函数的方式来改变Web应用的一种行为，这些回调函数可以由不是该Web应用官方的第三方用户或者开发人员来维护，修改。通过Webhook，你可以自定义一些行为通知到指定的URL去。 那么每次push时候接受到请求，然后执行pull脚本，问题就解决了 github配置github 支持webhook在github项目中选择settingwebhooksPayload URL 请求地址Content type 请求类型Secret 密文(请求之后用作校验) 请求处理通过node接受请求作出响应 1234567891011121314151617181920212223var http = require('http')var createHandler = require('github-webhook-handler')var handler = createHandler(&#123; path: '/deploy', secret: '' &#125;)http.createServer(function (req, res) &#123; handler(req, res, function (err) &#123; res.statusCode = 404 res.end('no such location') &#125;)&#125;).listen(8989)handler.on('error', function (err) &#123; console.error('Error:', err.message)&#125;)handler.on('push', function (event) &#123; // 调用pull脚本 process.exec('git pull origin master', function (error, stdout, stderr) &#123; if (error !== null) &#123; console.log('exec error: ' + error); &#125; &#125;);&#125;) 这个时候每次push的时候，会发送一个请求到 url:8989/deylop通过node 服务会作出相应操作 服务器部署nginx 方向代理将8989 代理到80端口12345678server &#123; listen 80; server_name ''; location /deploy &#123; proxy_pass http://localhost:8989; &#125; &#125; 通过forever 启动node 服务","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luyi10year.github.io/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"https://luyi10year.github.io/tags/Git/"},{"name":"服务器","slug":"服务器","permalink":"https://luyi10year.github.io/tags/服务器/"}]},{"title":"谈谈","date":"2016-12-20T06:29:27.000Z","path":"2016/12/20/diary-2016-1220-1430/","text":"","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://luyi10year.github.io/tags/杂谈/"}]},{"title":"1px != 1px -- 移动端适配浅析","date":"2016-12-19T09:28:08.000Z","path":"2016/12/19/rem-layout/","text":"css中我们一般使用px作为单位在pc上css中的1个像素往往对应着电脑屏幕中的1个物理像素这可能会给我们造成一个错觉css中的像素等于设备的物理像素但实际情况却并非如此css中的像素只是一个抽象的单位在不同的设备或不同的环境中css中的1px所代表的设备物理像素是不同的典型的就是retina屏 首先我们先了解几个概念 viewportviewport 是用户网页的可视区域pc中就是屏幕宽度移动设备中viewport(这个虚拟窗口)比屏幕宽 一般为9801234567891011&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;移动端布局viewport的宽度设为理想宽度layout viewport 默认的viewport 比屏幕宽 document.documentElement.clientWidthvisual viewport 浏览器可视区域的大小 window.innerWidthideal viewport 最适合移动设备的viewportwidth：控制 viewport 的大小，可以指定的一个值，如果 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。height：和 width 相对应，指定高度。initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。maximum-scale：允许用户缩放到的最大比例。minimum-scale：允许用户缩放到的最小比例。user-scalable：用户是否可以手动缩放。 物理像素(physical pixel)一个物理像素是显示器(手机屏幕)上最小的物理显示单元在操作系统的调度下每一个设备像素都有自己的颜色值和亮度值。 设备独立像素(density-independent pixel)设备独立像素(也叫密度无关像素)可以认为是计算机坐标系统中得一个点这个点代表一个可以由程序使用的虚拟像素(比如: css像素)简单点就是屏幕宽高 设备像素比(device pixel ratio)设备像素比 ＝ 物理像素 / 设备独立像素5,6的dpr=2，1个css像素等于2个物理像素6p的dpr=3,1个css像素等于3个物理像素 那首先我们在移动端布局，viewport肯定不能是默认的值最终viewport宽度等于应该等于设备的宽度我们的布局视图应该是 按照物理像素来布局设备独立像素可获得设备像素比 window.devicePixelRatio现在假设 在iphone6上布局 此时dpr = 2,dip = 375物理像素应该是 dpr * dip = 750div{ border-top:1px solid #000;}现在在页面上要实现一个1px的上边框由于移动端布局viewport缩成设备宽度而分辨率没有变所以这时的1px会有2px的效果 这个时候可以手动将viewport 宽度设成物理像素的宽度，然后将整个页面缩小 dpr 倍 1px 的问题解决了，那如何解决在不同手机显示设计稿中的一个100x100的div设计稿 750其中div 100x100750的设计稿对应的是iPhone6结合上面viewport的缩放div{ width:100px; height:100px;}在6上跟设计稿是完全相同的而在5(640)上会变大 这个时候可以通过rem在不同设备上动态计算出比例值 假设在750设计稿中 1rem = 100px那么在640设计稿中 1rem = 640/750*100px此时1rem 不管在5上还是6上显示都完全跟在设计稿中显示效果相同1234567891011121314//html&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;//动态计算remvar domDocEL = window.document.documentElement, mateViewPort = window.document.querySelector('meta[name=\"viewport\"]'), nBasePsdWidth = 750 / 100, nDpr = window.devicePixelRatio, nScale = 1 / nDpr, nLayout = domDocEL.clientWidth, nRem = nLayout * nDpr / nBasePsdWidth;domDocEL.style.fontSize = rem +'px';mateViewPort.setAttribute('content','width='+nDpr*nLayout+',initial-scale='+nScale+',maximum-scale='+nScale+',minimum-scale='+nScale+',user-scalable=no'); 对于字体可以用写个mixin方法根据不同的dpr设置字号12345@mixin px2rem($name,$px) &#123; [data-dpr=\"2\"] &amp; &#123; #&#123;$name&#125;: $px*2/2+px; &#125; &#125; 总结移动端布局将viewport设成物理像素的大小,然后在缩放为dpr的倒数倍。dpr不存在？简单点~~~那就指定为1！","tags":[{"name":"Rem","slug":"Rem","permalink":"https://luyi10year.github.io/tags/Rem/"},{"name":"H5","slug":"H5","permalink":"https://luyi10year.github.io/tags/H5/"}]},{"title":"react","date":"2016-12-18T05:50:35.000Z","path":"2016/12/18/react/","text":"整理整理思绪","tags":[{"name":"react","slug":"react","permalink":"https://luyi10year.github.io/tags/react/"}]},{"title":"vue","date":"2016-12-17T05:50:25.000Z","path":"2016/12/17/vue/","text":"整理整理思绪","tags":[{"name":"vue","slug":"vue","permalink":"https://luyi10year.github.io/tags/vue/"}]},{"title":"webpack","date":"2016-12-16T06:29:27.000Z","path":"2016/12/16/webpack/","text":"关于webpack的教程网上一抓一大把就不班门弄斧了这里只是总结一些webpack的实用配置以及个人心得 entry&amp;output12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849enpty:&#123; index:'./index.js', more:['./more2.js','./more.js'], vendor: ['react', 'react-dom', 'react-router']&#125;putput:&#123; path:'./build', filename:'[name]-[id].js', publicPath:'/assets/', chunkFilename:'[name]-[chunkhash]'&#125;//[id], chunk的id//[name] ,chunk名//[hash], 编译哈希值//[chunkhash] , chunk的hash值 根据模块内容//output.publicPath：设置为想要的资源访问路径。//访问时，则需要通过类似http://localhost:8080/asstes/index-1.js来访问资源，//如果没有设置，则默认从站点根目录加载。//filename应该比较好理解，就是对应于entry里面生成出来的文件名。比如：&#123; entry: &#123; \"index\": \"pages/index.jsx\" &#125;, output: &#123; filename: \"[name].min.js\", chunkFilename: \"[name].min.js\" &#125;&#125;//生成出来的文件名为index.min.js。//chunkname我的理解是未被列在entry中，//却又需要被打包出来的文件命名配置。//什么场景需要呢？我们项目就遇到过，在按需加载（异步）模块的时候，//这样的文件是没有被列在entry中的，如使用CommonJS的方式异步加载模块：require.ensure([\"modules/tips.jsx\"], function(require) &#123; var a = require(\"modules/tips.jsx\"); // ...&#125;, 'tips');//异步加载的模块是要以文件形式加载哦，//所以这时生成的文件名是以chunkname配置的，//生成出的文件名就是tips.min.js。//（require.ensure() API的第三个参数是给这个模块命名，//否则 chunkFilename: \"[name].min.js\" 中的 [name] 是一个自动分配的、可读性很差的id，//这是我在文档很不起眼的地方788发现的。。。）new webpack.optimize.CommonsChunkPlugin(&#123; names: ['vendor'],&#125;) url-loader1234test: /\\.(gif|jpg|png)$/,loader: 'url-loader?limit=1024&amp;name=img/[name].[ext]'//小于1024字节 采用base64//大于1024字节 正常打包到output目录下img文件夹中 js-loader1234567891011121314151617181920212223242526272829303132 //babel //配置 .babelrc //.rc run command 程序启动阶段被调用 //执行babal-loader时自动执行 &#123; \"presets\": [\"es2015\", \"stage-2\"], \"plugins\": [ \"transform-class-properties\", \"transform-runtime\" ] &#125; //webpack.config.js &#123; test: /\\.js$/, exclude: /node_modules/, loader:'babel' &#125;,//不使用.babelrc &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: &#123; presets: [\"es2015\", \"stage-2\"], plugins: [ \"transform-class-properties\", \"transform-runtime\" ] &#125; &#125;, vue-loader1234567891011121314151617181920&#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/,&#125;&#123; test:/\\.vue$/, loader:'vue',&#125;babel: &#123; presets: ['es2015'], plugins: [\"transform-class-properties\", \"transform-runtime\"]&#125;,vue:&#123; loaders:&#123; js:'babel', scss:['vue-style-loader','css','sass'].join('!') &#125;&#125;, css-loaderloader 采取管道流1loader: ['style','css','scss'].join('!') 提取样式到单独文件 插件 extract-text-webpack-plugin1234567891011var ExtractTextPlugin = require('extract-text-webpack-plugin');&#123; test: /\\.(scss|sass|css)$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader')&#125;plugins: [ new ExtractTextPlugin('[name].css') //output目录下 ], css样式自动 fix 插件 autoprefixer(postcss插件) 12345678910111213141516&#123; test: /\\.(scss|sass|css)$/, loader: ExtractTextPlugin.extract('style-loader', ['css-loader', 'postcss-loader']) &#125;const AUTOPREFIXER_BROWSERS = [ 'Android &gt;= 4', 'Chrome &gt;= 35', 'Firefox &gt;= 31', 'Explorer &gt;= 9', 'iOS &gt;= 7', 'Opera &gt;= 12', 'Safari &gt;= 7.1'] postcss: function() &#123; return [autoprefixer(&#123; browsers: AUTOPREFIXER_BROWSERS &#125;)]; &#125;, file-loader1234&#123; test: /\\.(woff|svg|eot|ttf).$/, loader: \"file-loader?name=fonts/[name].[ext]\"&#125; resolve12345678910111213141516171819var moment = require('moment');//编译很慢 也就是说，请求的是 moment 的源码。//实际上，通过 NPM 安装 moment 的时候会同时安装 moment 的源码和压缩后的代码//var moment = require('moment/min/moment-with-locales.min.js');//只不过这样改，可读性会有所下降，//而且每一个用到 moment 的地方都得这么写。//另外，如果同样的问题出现在第三方模块中，修改别人代码就不那么方便了。//下面来看看用 Webpack 怎么解决这个问题。 resolve: &#123; alias: &#123; moment: \"moment/min/moment-with-locales.min.js\" &#125; &#125;//可以用 alias 指定从非npm引入的库，如jquery: path.resolve(__dirname, './bower_components/jquery/dist/jquery.js') ，这样在 import 时可以替换引用路径// require时省略的扩展名，如：require('app') 不需要app.jsextensions: ['','.js','.vue','.scss'], noParsemodule.noParse 是 webpack 的另一个很有用的配置项，如果你 确定一个模块中没有其它新的依赖 就可以配置这项，webpack 将不再扫描这个文件中的依赖。123module: &#123; noParse: [/moment-with-locales/] &#125; devtool通常，JavaScript的解释器会告诉你，第几行第几列代码出错。但是，这对于转换后的代码毫无用处。举例来说，jQuery 1.9压缩后只有3行，每行3万个字符，所有内部变量都改了名字。你看着报错信息，感到毫无头绪，根本不知道它所对应的原始位置。这就是Source map想要解决的问题。1devtool: '#source-map' hot reload12345678910111213//package.json\"scripts\": &#123; \"dev\": \"webpack-dev-server --devtool eval-source-map --progress --colors --hot --inline\", &#125;,--content-base 内容基本路径 不加默认当前目录--colors 输出加颜色path: \"./dist\",filename: \"[name].js\",publicPath: \"abababab\",publicPath 必须设置 这里设置什么名 html里引用就写什么名字&lt;script src=\"/abababab/main.js\"&gt;&lt;/script&gt;npm run dev webpack -w12345//webstrom 会在临时文件夹中创建一个文件用来保存(好像没有出发实际文件的变更)settingAppearance &amp; BehaviorSystem SettingsUse \"safe write\"(save changes to a temporary file first) 勾去掉","tags":[{"name":"webpack","slug":"webpack","permalink":"https://luyi10year.github.io/tags/webpack/"}]},{"title":"学点运维，配个服务器","date":"2016-12-15T09:08:08.000Z","path":"2016/12/15/aliyun/","text":"前段时间和同事合租了一个阿里云服务器，60几块钱一个月。服务器上的资源环境很多都是他配的，作为前端，只是在上面放点静态的东西，也没太大兴趣在这方面去摸索然后这货今天离职了。 走之前，悠悠然发了我一个连接阿里云搞活动 传送门 服务器免费赠送6个月 果断入手(要买个9块钱的套餐) 然后买域名解析DNS配nginx装git搭node 也算是小入门了 But 我想说的是作为一个开发人员and 一个合格的开发人员首先具备的应该是解决问题，查找问题的能力 而不是一有问题不假思索的问别人有时候多学一样本领,就早说一句求人的话 作为我们作为初学者总会碰到各种各样的问题那么，怎么解决？ 举个栗子linux git的安装 忽略前面下载解压过程 ./configure –prefix=/usr/localmake &amp; make install 果断报错。。OK 下载各种依赖报错继续安装成功git –version嗯 有版本号easy嘛然后 来 git clone ..error:fatal: Unable to find remote helper for ‘https’又报错，奔溃 这是因为Git环境没有安装完全，需要重新安装 ./configure –prefix=/usr/localmake all docmake install install-doc install-man install-html 继续 OK问题解决 那么这解决问题的过程 就比解决问题来的跟有用前提是问题是你自己解决的","tags":[{"name":"Linux","slug":"Linux","permalink":"https://luyi10year.github.io/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"https://luyi10year.github.io/tags/Git/"},{"name":"服务器","slug":"服务器","permalink":"https://luyi10year.github.io/tags/服务器/"}]},{"title":"In city","date":"2016-12-14T10:40:08.000Z","path":"2016/12/14/in-city/","text":"悠然随心随性随缘杭州，省会美丽的西湖（我也只去过西湖。。）一年前，在这我开启了前端之旅 那谁说过，在风口，是只猪也能飞起来。何况是在杭州这样的互联网台风中。。 但是风过了，依然在飞的却是鹰 麻雀从不担心树枝会断因为他相信的不是树枝而是自己的翅膀 身处互联网大时代机会很多，机遇很多首先飞起来然后去充实自己不断学习不断进步 最后风即使过了我们也进化成了鹰","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://luyi10year.github.io/tags/杂谈/"}]},{"title":"Node","date":"2016-12-13T10:41:55.000Z","path":"2016/12/13/node/","text":"NodeNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 哈哈 先占上到时候再补","tags":[{"name":"Node","slug":"Node","permalink":"https://luyi10year.github.io/tags/Node/"}]}]